
---
### Проверка доступных сетевых пространств (SMB share)

![[Протоколы удалённого доступа#SMBMAP]]

![[Протоколы удалённого доступа#SMBCLIENT]]

---

Находясь внутри машины можно получить базовую информацию о ней.

---
### Версия машины

```powershell-session
Get-WmiObject -Class win32_OperatingSystem | select Version,BuildNumber
```

Существует множество способов узнать версию и номер сборки системы. Эту информацию легко получить с помощью класса `win32_OperatingSystem`, который показывает, что мы находимся на хосте `Windows 10` с номером сборки `19041`.

![[Pasted image 20250917180201.png]]

| Operating System Names               | Version Number |
| ------------------------------------ | -------------- |
| Windows NT 4                         | 4.0            |
| Windows 2000                         | 5.0            |
| Windows XP                           | 5.1            |
| Windows Server 2003, 2003 R2         | 5.2            |
| Windows Vista, Server 2008           | 6.0            |
| Windows 7, Server 2008 R2            | 6.1            |
| Windows 8, Server 2012               | 6.2            |
| Windows 8.1, Server 2012 R2          | 6.3            |
| Windows 10, Server 2016, Server 2019 | 10.0           |
### Службы и сервисы на машине

Другие полезные классы, которые можно использовать с `Get-WmiObject`: 
- `Win32_Process` для получения списка процессов, 
- `Win32_Service` для получения списка служб,
- `Win32_Bios` для получения информации о базовой системе ввода-вывода (BIOS). BIOS — это микропрограмма, устанавливаемая на материнскую плату компьютера и управляющая основными функциями компьютера, такими как управление питанием, интерфейсами ввода-вывода и конфигурацией системы.
- `ComputerName`  для получения информации об удалённых компьютерах. 

`Get-WmiObject` можно использовать для запуска и остановки служб на локальных и удалённых компьютерах и т. д. Дополнительная информация - [Get-WmiObject: Query WMI for Computer Information](https://adamtheautomator.com/get-wmiobject/).

### Привилегии

Привилегии можно читать и выдавать с помощью утилиты `icacls`.

Прочитать права на директорию:
```
icacls [директория]
```
- по умолчанию директория - текущая.

Уровень доступа к ресурсам указан после каждого пользователя в выходных данных. Возможные параметры наследования:

- (CI): наследование контейнера
- (OI): наследование объекта
- (IO): только наследование
- (NP): не распространять наследование
- (I): разрешение, унаследованное от родительского контейнера

```cmd-session
C:\htb> icacls c:\windows
c:\windows NT SERVICE\TrustedInstaller:(F)
           NT SERVICE\TrustedInstaller:(CI)(IO)(F)
           NT AUTHORITY\SYSTEM:(M)
           NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(F)
           BUILTIN\Administrators:(M)
           BUILTIN\Administrators:(OI)(CI)(IO)(F)
           BUILTIN\Users:(RX)
           BUILTIN\Users:(OI)(CI)(IO)(GR,GE)
           CREATOR OWNER:(OI)(CI)(IO)(F)
           APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(RX)
           APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(OI)(CI)(IO)(GR,GE)
           APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(RX)
           APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(OI)(CI)(IO)(GR,GE)

Successfully processed 1 files; Failed processing 0 files
```

В приведенном выше примере учётная запись `NT AUTHORITY\SYSTEM` имеет разрешения на наследование объекта, наследование контейнера, только наследование и полный доступ. Это означает, что эта учётная запись имеет полный контроль над всеми объектами файловой системы в этом каталоге и подкаталогах.

Базовые разрешения доступа следующие:
- F: полный доступ
- D: доступ на удаление
- N: нет доступа
- M: доступ на изменение
- RX: доступ на чтение и выполнение
- R: доступ только на чтение
- W: доступ только на запись

Используя команду `icacls c:\users /grant joe:f`, мы можем предоставить пользователю joe полный контроль над каталогом, но, учитывая, что (oi) и (ci) не были включены в команду, пользователь joe будет иметь права только на папку `c:\users`, но не на подкаталоги пользователя и файлы, содержащиеся в них.
```cmd-session
C:\htb> icacls c:\users /grant joe:f
processed file: c:\users
Successfully processed 1 files; Failed processing 0 files
```

```cmd-session
C:\htb> >icacls c:\users
c:\users WS01\joe:(F)
         NT AUTHORITY\SYSTEM:(OI)(CI)(F)
         BUILTIN\Administrators:(OI)(CI)(F)
         BUILTIN\Users:(RX)
         BUILTIN\Users:(OI)(CI)(IO)(GR,GE)
         Everyone:(RX)
         Everyone:(OI)(CI)(IO)(GR,GE)

Successfully processed 1 files; Failed processing 0 files
```

Эти разрешения можно отозвать с помощью команды `icacls c:\users /remove joe`.

Полный список аргументов командной строки icacls и подробные настройки разрешений можно найти [здесь](https://ss64.com/nt/icacls.html).

---

# Службы и процессы

Запрашивать список служб и управлять ими можно с помощью `sc.exe` и `Get-Service`.

Вывести информацию о запущенных службах и оставить только первые 2:
```powershell-session
Get-Service | ? {$_.Status -eq "Running"} | select -First 2 |fl
```
- `fl` - дополнительные подробности. Иначе будут выведены только названия.
Ответ:
```powershell-session
Name                : AdobeARMservice
DisplayName         : Adobe Acrobat Update Service
Status              : Running
DependentServices   : {}
ServicesDependedOn  : {}
CanPauseAndContinue : False
CanShutdown         : False
CanStop             : True
ServiceType         : Win32OwnProcess

Name                : Appinfo
DisplayName         : Application Information
Status              : Running
DependentServices   : {}
ServicesDependedOn  : {RpcSs, ProfSvc}
CanPauseAndContinue : False
CanShutdown         : False
CanStop             : True
ServiceType         : Win32OwnProcess, Win32ShareProcess
```

В Windows у нас есть некоторые [критически важные системные службы](https://docs.microsoft.com/en-us/windows/win32/rstmgr/critical-system-services), которые не могут быть остановлены и перезапущены без перезагрузки системы. Если мы обновляем какой-либо файл или ресурс, используемый одной из этих служб, нам необходимо перезагрузить систему.

|Служба|Описание|
|---|---|
|smss.exe|Подсистема диспетчера сессий. Отвечает за обработку сессий в системе.|
|csrss.exe|Процесс выполнения клиент-сервера. Пользовательская часть подсистемы Windows.|
|wininit.exe|Запускает файл Wininit .ini файл, в котором перечислены все изменения, которые должны быть внесены в Windows при перезагрузке компьютера после установки программы.|
|logonui.exe|Используется для облегчения входа пользователя в ПК|
|lsass.exe|Локальный сервер проверки подлинности безопасности проверяет действительность входа пользователя в систему на ПК или сервере. Он генерирует процесс, отвечающий за аутентификацию пользователей для службы Winlogon.|
|services.exe|Управляет работой запуска и остановки служб.|
|winlogon.exe|Отвечает за обработку безопасной последовательности внимания, загрузку профиля пользователя при входе в систему и блокировку компьютера при запуске скринсейвера.|
|Система|Фоновый системный процесс, на котором работает ядро Windows.|
|svchost.exe с RPCSS|Управляет системными службами, которые запускаются из библиотек динамической компоновки (файлы с расширением .dll), такими как «Автоматические обновления», «Брандмауэр Windows» и «Plug and Play». Использует службу удаленного вызова процедур (RPC) (RPCSS).|
|svchost.exe с Dcom/PnP|Управляет системными службами, которые запускаются из библиотек динамической компоновки (файлы с расширением .dll), такими как «Автоматические обновления», «Брандмауэр Windows» и «Plug and Play». Использует службы Distributed Component Object Model (DCOM) и Plug and Play (PnP).|

По [этой ссылке](https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_components#Services) есть список компонентов Windows, включая ключевые службы.

---
## sysinternals

Иногда инструменты администрирования windows sysinternals можно использовать без установки: `\\live.sysinternals.com\tools` - путь вызова sysinternals.

Например, мы можем запустить procdump.exe прямо из этой общей папки, не загружая ее непосредственно на диск:
```cmd-session
C:\htb> \\live.sysinternals.com\tools\procdump.exe -accepteula

ProcDump v9.0 - Sysinternals process dump utility
Copyright (C) 2009-2017 Mark Russinovich and Andrew Richards
Sysinternals - www.sysinternals.com

Monitors a process and writes a dump file when the process exceeds the
specified criteria or has an exception.

Capture Usage:
   procdump.exe [-mm] [-ma] [-mp] [-mc Mask] [-md Callback_DLL] [-mk]
                [-n Count]
                [-s Seconds]
                [-c|-cl CPU_Usage [-u]]
                [-m|-ml Commit_Usage]
                [-p|-pl Counter_Threshold]
                [-h]
                [-e [1 [-g] [-b]]]
                [-l]
                [-t]
                [-f  Include_Filter, ...]
                [-fx Exclude_Filter, ...]
                [-o]
                [-r [1..5] [-a]]
                [-wer]
                [-64]
                {
                 {{[-w] Process_Name | Service_Name | PID} [Dump_File | Dump_Folder]}
                |
                 {-x Dump_Folder Image_File [Argument, ...]}
                }
				
<SNIP>
```

Набор включает в себя такие инструменты, как `Process Explorer`, улучшенная версия `Task Manager`, и `Process Monitor`, которые можно использовать для мониторинга файловой системы, реестра и сетевой активности, связанной с любым процессом, выполняемым в системе. Некоторые дополнительные инструменты — `TCPView`, который используется для мониторинга интернет-активности, и `PSExec`, который можно использовать для удаленного управления/подключения к системам по протоколу SMB.

Эти инструменты могут быть полезны специалистам по тестированию на проникновение, например, для обнаружения интересных процессов и возможных путей повышения привилегий, а также для горизонтального перемещения.

---

## sc - управление сервисами

---

#### Получить данные о службе

`sc` можно использовать для настройки и управления сервисами. Давайте поэкспериментируем с несколькими командами.
```cmd-session
C:\Users\htb-student>sc qc wuauserv
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: wuauserv
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 3   DEMAND_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\WINDOWS\system32\svchost.exe -k netsvcs -p
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : Windows Update
        DEPENDENCIES       : rpcss
        SERVICE_START_NAME : LocalSystem
```
- Команда `sc qc` используется для запроса к службе.
- Если бы мы хотели запросить службу на устройстве по сети, мы могли бы указать имя хоста или IP-адрес сразу после `sc`: 
  ```
  sc //{hostname or ip of box} query ServiceName
	```
- Здесь `wuauserv` - название службы Windows Update Service.

---

#### Запуск и остановка служб

```cmd-session
sc stop wuauserv
```
Результат:
```
[SC] OpenService FAILED 5:

Access is denied.
```

Если бы мы расследовали ситуацию, подозревая, что в системе есть ВПО, `sc` дал бы нам возможность быстро искать и анализировать часто используемые и вновь создаваемые сервисы. Кроме того, он гораздо более удобен для скриптов, чем использование инструментов с графическим интерфейсом, таких как `services.msc`.

#### Изменить путь к исполняемому файлу службы

```cmd-session
C:\WINDOWS\system32> sc config wuauserv binPath=C:\Winbows\Perfectlylegitprogram.exe

[SC] ChangeServiceConfig SUCCESS

C:\WINDOWS\system32> sc qc wuauserv

[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: wuauserv
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 3   DEMAND_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Winbows\Perfectlylegitprogram.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : Windows Update
        DEPENDENCIES       : rpcss
        SERVICE_START_NAME : LocalSystem
```

---

#### Проверка разрешений службы/файла: `sc sdshow`

---

##### Пример использования

```cmd-session
C:\WINDOWS\system32> sc sdshow wuauserv

D:(A;;CCLCSWRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)S:(AU;FA;CCDCLCSWRPWPDTLOSDRCWDWO;;;WD)
```

1. Утилита для парсинга и разбора SDDL на github: [SDDL Viewer](https://github.com/advancedmonitoring/SDDLViewer).
2. Гайд habr: [Как смотреть SDDL и не ломать глаза о точки с запятыми / Хабр](https://habr.com/ru/companies/pm/articles/442662/)

---
##### Теория

Каждый именованный объект windows имеет дескриптор безопасности. Дескрипторы безопасности идентифицируют владельца объекта и основную группу, содержащую `Discretionary Access Control List` (`DACL`) и `System Access Control List` (`SACL`).

Как правило, **DACL используется для управления доступом к объекту**, а **SACL — для учета и регистрации попыток доступа**. В этом разделе будет рассмотрен список DACL, но те же концепции будут применимы и к SACL.

`Security Descriptor Definition Language` **( SDDL )** — это строка с описаниями прав доступа в текстовом виде. Чаще всего состоит из 3 частей: владельца, группы и прав доступа DACL. Иногда ещё добавляется часть SACL — аудиторская часть (если действия с объектом подойдут под правила SACL, то будет создано системное событие, которое легко отслеживать различными системами). Описатель выглядит так:  
  
```
O:<владелец>G:<группа>D:<правила доступа DACL>S:<правила аудита SACL>`
```

Владелец и группа может указываться как SID пользователя или группы ОС, либо как специальные сокращения. Список сокращений групп и пользователей - [Строки SID - Win32 apps | Microsoft Learn](https://learn.microsoft.com/ru-ru/windows/win32/secauthz/sid-strings).

Правила доступа состоят из перечисления флагов DACL и строк ACE (Access Control Entries). Подробный разбор ACE представлен по [ссылке](https://docs.microsoft.com/ru-ru/windows/desktop/SecAuthZ/ace-strings). Тут нас ждёт очередной подводный камень — не всегда по сокращению можно точно указать действие. Они, так сказать, контекстозавимые. Например, если речь идёт о правах работы с сервисами, то WP — это «остановка сервиса», если о файлах, то «исполнение», а если о папках, то «траверс» (доступ к файлам в папке по имени, при отсутствии возможности перечислить содержимое). Некоторые описания есть [тут](https://docs.microsoft.com/en-us/windows/desktop/secauthz/ace-strings), некоторые [здесь](https://skanthak.homepage.t-online.de/download/SDDL.INF), с миру по нитке.

Рассмотрим SDDL следующего вида:
```
D:(A;;CCLCSWRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)
```

Прочтём весь дескриптор безопасности для службы `Windows Update` (`wuauserv`) в следующем порядке, начиная с первой буквы и набора скобок:

`D:(A;;CCLCSWRPLORC;;;AU)`

1. `D:` - последующие символы являются разрешениями DACL
2. `AU` - определяет субъекта безопасности "Аутентифицированные пользователи"
3. `A;;` - доступ разрешен
4. `CC` - SERVICE_QUERY_CONFIG - это запрос к менеджеру управления службами (SCM) для настройки службы
5. `LC` - SERVICE_QUERY_STATUS - это запрос к менеджеру управления службой (SCM) для текущего состояния службы
6. `SW` - SERVICE_ENUMERATE_DEPENDENTS - в нем будет перечислен список зависимых служб
7. RP - SERVICE_START - он запустит службу
8. LO - SERVICE_INTERROGATE - он будет запрашивать у службы ее текущее состояние
9. RC - READ_CONTROL - он будет запрашивать дескриптор безопасности службы

Когда мы читаем дескриптор безопасности `;;CCLCSWRPLORC;;;`, может быть легко заблудиться в, казалось бы, случайном порядке символов, но помните, что мы, по сути, просматриваем записи контроля доступа в списке управления доступом. Каждый набор из 2 символов между точками с запятой представляет действия, разрешенные для выполнения конкретным пользователем или группой.

После последнего набора точек с запятой символы указывают субъекта безопасности (пользователя и/или группу), которому разрешено выполнять эти действия - `;;;AU`

Символ сразу после открывающих скобок и перед первым набором точек с запятой определяет, являются ли действия разрешенными или запрещенными - `A;;`

Весь этот дескриптор безопасности, связанный со службой `Windows Update` (`wuauserv`), имеет три набора записей управления доступом, поскольку существуют три разных участника безопасности. К каждому участнику безопасности применяются определенные разрешения.

---

## Проверка разрешений службы с помощью PowerShell

С помощью командлета PowerShell `Get-Acl` мы можем проверить разрешения службы, указав путь к определенной службе в реестре.

```powershell-session
PS C:\Users\htb-student> Get-ACL -Path HKLM:\System\CurrentControlSet\Services\wuauserv | Format-List

Path   : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\wuauserv
Owner  : NT AUTHORITY\SYSTEM
Group  : NT AUTHORITY\SYSTEM
Access : BUILTIN\Users Allow  ReadKey
         BUILTIN\Users Allow  -2147483648
         BUILTIN\Administrators Allow  FullControl
         BUILTIN\Administrators Allow  268435456
         NT AUTHORITY\SYSTEM Allow  FullControl
         NT AUTHORITY\SYSTEM Allow  268435456
         CREATOR OWNER Allow  268435456
         APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES Allow  ReadKey
         APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES Allow  -2147483648
         S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479-3232135806-4053264122-3456934681 Allow
         ReadKey
         S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479-3232135806-4053264122-3456934681 Allow
         -2147483648
Audit  :
Sddl   : O:SYG:SYD:AI(A;ID;KR;;;BU)(A;CIIOID;GR;;;BU)(A;ID;KA;;;BA)(A;CIIOID;GA;;;BA)(A;ID;KA;;;SY)(A;CIIOID;GA;;;SY)(A
         ;CIIOID;GA;;;CO)(A;ID;KR;;;AC)(A;CIIOID;GR;;;AC)(A;ID;KR;;;S-1-15-3-1024-1065365936-1281604716-3511738428-1654
         721687-432734479-3232135806-4053264122-3456934681)(A;CIIOID;GR;;;S-1-15-3-1024-1065365936-1281604716-351173842
         8-1654721687-432734479-3232135806-4053264122-3456934681)
```

Эта команда возвращает определенные разрешения учетной записи в удобном для чтения формате и в SDDL. Кроме того, в SDDL присутствует идентификатор безопасности, представляющий каждого участника безопасности (пользователя и/или группу). Это то, чего мы не получаем при запуске `sc` из командной строки.

---

# Командлеты

---

## PowerShell 

---
### Алиасы

Некоторые командлеты имеют алеасы (псевдонимы), их можно просмотреть `get-alias`:
```powershell-session
PS C:\htb> get-alias

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           % -> ForEach-Object
Alias           ? -> Where-Object
Alias           ac -> Add-Content
Alias           asnp -> Add-PSSnapin
Alias           cat -> Get-Content
Alias           cd -> Set-Location
Alias           CFS -> ConvertFrom-String                          3.1.0.0    Microsoft.PowerShell.Utility
Alias           chdir -> Set-Location
Alias           clc -> Clear-Content
Alias           clear -> Clear-Host
Alias           clhy -> Clear-History
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
```

Мы также можем настроить свои собственные псевдонимы с помощью `New-Alias` и получить псевдоним для любого командлета с помощью `Get-Alias -Name`.
```powershell-session
PS C:\htb> New-Alias -Name "Show-Files" Get-ChildItem
PS C:\> Get-Alias -Name "Show-Files"

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           Show-Files
```

---
### Справка  

В PowerShell есть справочная система для командлетов, функций, скриптов и концепций. Он не установлен по умолчанию, но мы можем либо выполнить команду `Get-Help <cmdlet-name> -Online`, чтобы открыть онлайн-справку для командлета, либо выполнить функцию в нашем веб-браузере. Мы можем набрать `Update-Help` для загрузки и установки справочных файлов локально.

При вводе команды, такой как `Get-Help Get-AppPackage`, будет возвращена только частичная справка, если файлы справки не установлены.

```powershell-session
PS C:\htb>  Get-Help Get-AppPackage

NAME
    Get-AppxPackage

SYNTAX
    Get-AppxPackage [[-Name] <string>] [[-Publisher] <string>] [-AllUsers] [-PackageTypeFilter {None | Main |
    Framework | Resource | Bundle | Xap | Optional | All}] [-User <string>] [-Volume <AppxVolume>]
    [<CommonParameters>]


ALIASES
    Get-AppPackage


REMARKS
    Get-Help cannot find the Help files for this cmdlet on this computer. It is displaying only partial help.
        -- To download and install Help files for the module that includes this cmdlet, use Update-Help.
```

---

### ## Политика исполнения

Иногда мы обнаруживаем, что не можем запускать скрипты в системе. Это связано с функцией безопасности под названием `execution policy`, которая пытается предотвратить выполнение вредоносных скриптов. Возможные политики:

| **Политика**   | **Описание**                                                                                                                                                                                                                                                                                        |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `AllSigned`    | Все скрипты могут выполняться, но доверенный издатель должен подписывать скрипты и файлы конфигурации. Это включает в себя как удаленные, так и локальные скрипты. Перед запуском мы получаем запрос на скрипты, подписанные издателями, которых мы еще не указали как доверенные или недоверенные. |
| `Bypass`       | Никакие скрипты или конфигурационные файлы не блокируются, и пользователь не получает никаких предупреждений или подсказок.                                                                                                                                                                         |
| `Default`      | Устанавливает политику выполнения по умолчанию для настольных компьютеров Windows и для серверов Windows.                                                                                                                                                                                           |
| `RemoteSigned` | Скрипты могут выполняться, но для них требуется цифровая подпись на скриптах, загруженных из Интернета. Цифровые подписи не требуются для скриптов, написанных локально.                                                                                                                            |
| `Restricted`   | Позволяет выполнять отдельные команды, но не позволяет запускать скрипты. Все типы файлов скриптов, включая файлы конфигурации (`.ps1xml`), файлы скриптов модулей (`.psm1`) и профили PowerShell (`.ps1`), блокируются.                                                                            |
| `Undefined`    | Политика выполнения для текущей области не задана. Если для политики выполнения ALL задано значение undefined, то будет использоваться политика выполнения по умолчанию.                                                                                                                            |
| `Unrestricted` | Это стандартная политика выполнения для компьютеров, отличных от Windows, и ее нельзя изменить. Эта политика разрешает выполнение неподписанных сценариев, но предупреждает пользователя перед запуском сценариев, которые не находятся в зоне локальной интрасети.                                 |

**Посмотреть политики выполнения** для всех областей видимости:
```powershell-session
PS C:\htb> Get-ExecutionPolicy -List

        Scope ExecutionPolicy
        ----- ---------------
MachinePolicy       Undefined
   UserPolicy       Undefined
      Process       Undefined
  CurrentUser       Undefined
 LocalMachine    RemoteSigned
```

Политика выполнения не предназначена для управления безопасностью, ограничивающей действия пользователя. Пользователь может легко обойти политику, введя содержимое скрипта непосредственно в окне PowerShell, загрузив и вызвав скрипт или указав скрипт в виде закодированной команды. Его также можно обойти, настроив политику выполнения (если у пользователя есть соответствующие права) или установив политику выполнения для текущей области процесса (что может сделать практически любой пользователь, так как это не требует изменения конфигурации и будет установлено только на время сеанса пользователя).

Ниже приведен пример изменения политики выполнения для текущего процесса (сессии).
```powershell-session
PS C:\htb> Set-ExecutionPolicy Bypass -Scope Process

Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing the execution policy might expose
you to the security risks described in the about_Execution_Policies help topic at
https:/go.microsoft.com/fwlink/?LinkID=135170. Do you want to change the execution policy?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): Y
```
Теперь мы видим, что политика выполнения была изменена:
```powershell-session
PS C:\htb>  Get-ExecutionPolicy -List

        Scope ExecutionPolicy
        ----- ---------------
MachinePolicy       Undefined
   UserPolicy       Undefined
      Process          Bypass
  CurrentUser       Undefined
 LocalMachine    RemoteSigned
```

---

## # Windows Management Instrumentation (WMI)

**WMI** — это подсистема PowerShell, которая предоставляет системным администраторам мощные инструменты для мониторинга системы. Целью WMI является консолидация управления устройствами и приложениями в корпоративных сетях. WMI является основной частью операционной системы Windows и поставляется предустановленным, начиная с Windows 2000. Она состоит из следующих компонентов:

| **Имя компонента**     | **Описание**                                                                                                                                                                                   |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| WMI service            | Процесс инструментария управления Windows, который выполняется автоматически при загрузке и выступает в качестве посредника между WMI providers, репозиторием WMI и управляющими приложениями. |
| Управляемые объекты    | Любые логические или физические компоненты, которыми можно управлять с помощью WMI.                                                                                                            |
| WMI providers          | Объекты, которые отслеживают события/данные, связанные с конкретным объектом.                                                                                                                  |
| Классы                 | Они используются WMI providers для передачи данных в службу WMI.                                                                                                                               |
| Методы                 | Они прикреплены к классам и позволяют выполнять действия. Например, методы можно использовать для запуска/остановки процессов на удаленных компьютерах.                                        |
| Репозиторий WMI        | База данных, в которой хранятся все статические данные, относящиеся к WMI.                                                                                                                     |
| Диспетчер объектов CIM | Система, которая запрашивает данные у поставщиков WMI и возвращает их запрашивающему приложению.                                                                                               |
| WMI API                | Предоставляет приложениям доступ к инфраструктуре WMI.                                                                                                                                         |
| WMI Consumer           | Отправляет запросы к объектам через диспетчер объектов CIM.                                                                                                                                    |

Вот некоторые из вариантов использования WMI:
- Информация о состоянии локальных/удаленных систем
- Настройка параметров безопасности на удаленных компьютерах/приложениях
- Настройка и изменение разрешений пользователей и групп
- Настройка/изменение свойств системы
- Выполнение кода
- Процессы планирования
- Настройка логирования

Все эти задачи могут быть выполнены с помощью комбинации PowerShell и интерфейса командной строки WMI (WMIC). WMI можно запустить через командную строку Windows, введя команду `WMIC` для открытия интерактивной оболочки или выполнив команду `wmic computersystem get name` напрямую, например для получения имени хоста. Мы можем просмотреть список команд и псевдонимов WMIC, набрав `WMIC /?`.

В следующем примере команды перечислены сведения об операционной системе:
```cmd-session
C:\htb> wmic os list brief

BuildNumber  Organization  RegisteredUser  SerialNumber             SystemDirectory      Version
19041                      Owner           00123-00123-00123-AAOEM  C:\Windows\system32  10.0.19041
```

WMIC использует aliases и связанные с ними verbs, adverbs, и switches. Приведенный выше пример команды `LIST` используется для отображения данных, а adverb `BRIEF` — для предоставления только основного набора свойств. Подробный список verbs, adverbs, и switches доступен [здесь](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic). WMI можно использовать с PowerShell с помощью [модуля](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1) `Get-WmiObject`. Этот модуль используется для получения экземпляров классов WMI или информации о доступных классах. Этот модуль можно использовать как на локальных, так и на удаленных машинах.

Здесь мы можем получить информацию об операционной системе:
```powershell-session
PS C:\htb> Get-WmiObject -Class Win32_OperatingSystem | select SystemDirectory,BuildNumber,SerialNumber,Version | ft

SystemDirectory     BuildNumber SerialNumber            Version
---------------     ----------- ------------            -------
C:\Windows\system32 19041       00123-00123-00123-AAOEM 10.0.19041
```

Также мы можем использовать [модуль](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod?view=powershell-5.1) `Invoke-WmiMethod`, который используется для вызова методов объектов WMI. Простой пример — переименование файла. Мы видим, что команда выполнена правильно, потому что для параметра `ReturnValue` установлено значение 0.
```powershell-session
PS C:\htb> Invoke-WmiMethod -Path "CIM_DataFile.Name='C:\users\public\spns.csv'" -Name Rename -ArgumentList "C:\Users\Public\kerberoasted_users.csv"


__GENUS          : 2
__CLASS          : __PARAMETERS
__SUPERCLASS     :
__DYNASTY        : __PARAMETERS
__RELPATH        :
__PROPERTY_COUNT : 1
__DERIVATION     : {}
__SERVER         :
__NAMESPACE      :
__PATH           :
ReturnValue      : 0
PSComputerName   :
```

---

# Безопасность Windows

## Идентификатор безопасности (SID)

Узнать SID всех пользователей в системе с помощью WMI:
``` 
wmic useraccount get sid,name
```
```
Get-WmiObject win32_useraccount | Select name,sid
```

Каждый из участников безопасности в системе имеет уникальный идентификатор безопасности (SID). Система автоматически генерирует идентификаторы безопасности. Это означает, что даже если, например, в системе есть два одинаковых пользователя, Windows может различить их и их права на основе их идентификаторов безопасности. SID — это строковые значения разной длины, которые хранятся в базе данных безопасности. Эти идентификаторы безопасности добавляются к маркеру доступа пользователя для идентификации всех действий, которые пользователь имеет право выполнять.

SID состоит из Identifier Authority и Relative ID (RID). В доменной среде Active Directory (AD) идентификатор безопасности также включает идентификатор безопасности домена.

SID разбивается на этот шаблон:
```powershell-session
(SID)-(revision level)-(identifier-authority)-(subauthority1)-(subauthority2)-(etc)
```

Пример:
```powershell-session
PS C:\htb> whoami /user

USER INFORMATION
----------------

User Name           SID
=================== =============================================
ws01\bob S-1-5-21-674899381-4069889467-2080702030-1002
```

Давайте разберем SID по частям:

|**Число**|**Значение**|**Описание**|
|---|---|---|
|S|Ид безопасности|Идентифицирует строку как идентификатор безопасности.|
|1|Уровень редакции|На сегодняшний день это никогда не менялось и всегда было.`1`|
|5|Центр управления идентификаторами|48-разрядная строка, определяющая центр (компьютер или сеть), создавший идентификатор безопасности.|
|21|Подполномочия1|Это переменный номер, который идентифицирует отношение или группу пользователя, описанную SID с органом, который его создал. Он сообщает нам, в каком порядке этот орган создал учетную запись пользователя.|
|674899381-4069889467-2080702030|Подполномочия2|Сообщает нам, на каком компьютере (или домене) было создано число|
|1002|Подполномочия3|RID, который отличает одну учетную запись от другой. Сообщает, является ли этот пользователь обычным пользователем, гостем, администратором или членом какой-либо другой группы|

## Windows Defender

Проверить, какие настройки безопасности defender включены:
```powershell-session
PS C:\htb> Get-MpComputerStatus | findstr "True"
AMServiceEnabled                : True
AntispywareEnabled              : True
AntivirusEnabled                : True
BehaviorMonitorEnabled          : True
IoavProtectionEnabled           : True
IsTamperProtected               : True
NISEnabled                      : True
OnAccessProtectionEnabled       : True
RealTimeProtectionEnabled       : True
```