# Инструменты 
### [**Altair**](https://chrome.google.com/webstore/detail/altair-graphql-client/flnheeellpciglgpaodhkhmapeljopja)

Это расширение для браузеров, которое само умеет отправлять запросы интроспекции от имени нашего браузера. Причём самое интересное, после получения интроспекции расширение само разбирает её на Query, Mutation и Subscription в разделе Docs.
![[Pasted image 20240614194130.png]]
В Altair есть GraphiQL(не путать с GraphQL), это механизм, который с помощью полученной схемы может помочь с отправкой запрос(дополнить поле, и пр.):
![[Pasted image 20240614194212.png]]
Альтаир всё отправляет через ваш браузер, значит все запросы можно увидеть в бурпе и там их отредактировать, если это необходимо.
![[Pasted image 20240614194324.png]]

---
### **GraphQL voyager**

Однако альтаир не всегда удобен, так как он не показывает как некоторые элементы связаны друг с другом. Как мы помним, иногда некоторые объекты могут быть вложены в другие объекты. И таким образом, бывают ситуации, когда к одному и тому же объекту можно получить доступ, используя разные запросы. И чтобы было понятно, как все объекты связаны, нужно их связь как-то визуализировать, для этого прекрасно подойдёт инструмент [graphQL voyager](https://graphql-kit.com/graphql-voyager/).

Чтобы его использовать нам нужно скопировать полученную схему из интроспекции и вставить в специальное поле. Также можно использовать SDL:
![[Pasted image 20240614194420.png]]
![[Pasted image 20240614194429.png]]
После этого мы получаем визуализированную связь объектов. Тут мы можем тыкать на разные объекты и видеть, какие объекты на них ссылаются. Как например тут мы видим, что на объект PasteObject ссылается около 3ёх объектов:
![[Pasted image 20240614194509.png]]

---
### **BurpSuite(inql, graphql raider)**

По большей части вы будете использовать скорее всего не альтаир, чтобы отправлять запросы, а именно бёрп, так как в нём и интрудер есть и другие инструменты. Давайте же взглянем на то, как graphql выглядет в бурпе!
![[Pasted image 20240614194621.png]]
Чтобы нормально работать с GraphQL через бурп, стоит использовать следующие расширения: InQL, GraphQL Raider.

---
#### **GraphQL Raider**

Описание с BAPP Store

**Описание**

GraphQL Raider - это расширение Burp Suite для тестирования конечных точек, реализующих GraphQL.

**Особенности**

1. **Отображение и редактор**
    
    Запрос gql и переменные извлекаются из нечитаемого тела json и отображаются на отдельных вкладках.
    
    При перехвате или получении вы можете манипулировать запросом gql и переменными внутри вкладки gql, и сообщение будет отправлено корректно.
2. **Точки установки сканера**
    
    В качестве точки вставки для сканера извлекаются не только переменные. Кроме того, значения внутри запроса также извлекаются в качестве точки вставки для сканера.
    
    Обнаруженные точки вставки отображаются для получения информации и повышения прозрачности на вкладке qgl сообщения
    
    Точки вставки используются активным сканером для вставки полезных данных для обнаружения уязвимостей. Пользовательские точки вставки gql помогают активному сканеру размещать полезные данные в правильном месте внутри запроса gql.
    
Если подытожить, то с помощью данного расширения можно более удобно видеть GraphQL-запросы, редактировать их, и также данное расширение умеет работать со сканером бурпа. Так как для бурпа GraphQL-запрос это просто Json, из которого он не может извлекать переменные для фаззинга, и вот с этой проблемой ему может помочь данное расширение.
![[Pasted image 20240614194931.png]]
![[Pasted image 20240614194936.png]]

---
#### **InQL**

Описание с BAPP Store

Инструмент тестирования безопасности, облегчающий проведение аудита безопасности технологии GraphQL.

Это расширение выдаст запрос самоанализа целевой конечной точке GraphQL, чтобы получить информацию о метаданных для:

1. Запросы, мутации, подписки
2. Его поля и аргументы
3. Объекты и пользовательские типы объектов
4. Найдите циклы GraphQL (честно говоря хз что это:) )

Используя расширение intl для Burp Suite, вы можете:

1. Поиск известных URL-адресов GraphQL; инструмент будет захватывать и сопоставлять известные значения для обнаружения конечных точек GraphQL на целевом веб-сайте
2. Поиск открытых консолей разработки GraphQL (Graphql, GraphQL Playground и другие распространенные консоли)
3. Используйте пользовательскую вкладку GraphQL, отображаемую в каждом HTTP-запросе /ответе, содержащем GraphQL
4. Используйте генерацию шаблонов, отправляя эти запросы в инструмент повторителя Burp (“Отправить в repeater”).
5. Воспользуйтесь поддержкой генерации шаблонов и редактора, отправив эти запросы во встроенный GraphiQL (“Отправить в GraphiQL”).
6. Настройте инструмент с помощью вкладки пользовательских настроек

Если попроще, это расширение предоставляет следующие возможности:

1. Удобный просмотр GraphQL запросов как в GraphQL Raider ![[Pasted image 20240614195220.png]]
2. Раздел, который сохраняет все GraphQL запросы![[Pasted image 20240614195248.png]]
3. Раздел, который как альтаир, запрашивает схему через интроспекцию, которую потом можно будет просмотреть и отправить в другие инструменты, причём обратите, что отправить можно в разных формах![[Pasted image 20240614195315.png]]![[Pasted image 20240614195318.png]]
4. Раздел для атаки![[Pasted image 20240614195333.png]]
5. И другие функции в контектном меню, особенное внимание на то, что GraphQL-запрос можно отправить в Repeater как обычный GraphQL-pfпрос в бурпе, так и с методом GET и с методом POST, имеющим другие Content-Type!![[Pasted image 20240614195358.png]]

---
### **Clairvoyancex**

Если интроспекция недоступна по какой-то причине(допустим, разработчик отключил её), то можно, конечно, собирать все запросы через InQL Timer, но это будет неудобно + есть огромный шанс того, что вы могли пропустить интересные методы.

Лучше будет пробрутать все методы GraphQL API с помощью Clairvoyance, а если точнее с помощью его форка [Clairvoyancex](https://github.com/y0k4i-1337/clairvoyancex). 

Данный инструмент работает примерно так:

1. Вы указываете инструменту на жирный словарик с огромным кол-вом английских слов, или на другой словарь, который вы посчитаете нужным
2. Инструмент начинает отправлять огромное кол-во GraphQL-запросов, подставляя и перебирая слова из словаря в полях/объектах. И если запрос прошёл без ошибок, то он это запоминает. Также данный инструмент может использовать подсказки от самого приложения. Если поле указано неверно, или его нет, то приложение может само подсказать, какое поле сущетвует. По итогу у вас будет файлик со схемой(если вы укажите специальный ключ на вывод), которую можно уже пихать и в InQL и в Voyager. Также если объекты ссылаются друг на друга, то Clairvoyancex после определённой вложенности перестанет мучать определённый объект и пойдёт дальше.

Пример команды для запуска с GraphQL:
``` 
poetry run python -m clairvoyancex -vv -o ../output.json -w ../google10000Words -H «Тут сами заголовки, можно -H  2 раза» https://somedomain.com/...
```
Пример подсказывающей ошибки от приложения:
![[Pasted image 20240614195744.png]]

---
### [**graphw00f**](https://github.com/dolevf/graphw00f)

Описание с гитхаба:

**graphw00f (вдохновленный wafw00f)** — это инструмент снятия отпечатков пальцев GraphQL для конечных точек GQL, он отправляет сочетание безвредных и искаженных запросов для определения механизма GraphQL, работающего за кулисами. graphw00f будет использовать проект GraphQL Threat Matrix, чтобы получить представление о том, какие средства защиты безопасности предоставляет каждая технология из коробки, и включены ли они по умолчанию.

Специально созданные запросы заставляют разные реализации сервера GraphQL однозначно реагировать на запросы, мутации и подписки, что упрощает определение отпечатков серверного механизма и различение различных реализаций GraphQL. (КВЕ: КВЕ-200)

Данный инструмент помогает найди эндпоинт, где находится графкл(помним, что все запросы GraphQL мы отправляем на один и тот же эндпоинт, так что найдя нужный эндпоинт мы найдём по сути место, куда отправлять все запросы). А также помогает определить библиотеку/движок GraphQL, это важно, так как у них всех могут быть свои уникальные уязвимости, присущие конкретному движку.

Запуск инструмента, если вы знаете эндпоинт GraphQL, так он будет только определять движок:

`python3 main.py -f -t <https://demo.hypergraphql.org:8484/graphql`>

Запуск инструмента, если нужно найти эндпоинт и определить движок:

`python3 main.py -f -d -t http://localhost:5000`


---
# **Как найти GraphQL endpoints**

Иногда разработчики могут прятать GraphQL эндпоинты, чтобы их найти можно перебрать каталоги, используя [ЭТОТ](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/graphql.txt) вордлист + посмотреть следующие директории:

- /graphql
- /api
- /api/graphql
- /graphql/api
- /graphql/graphql

Также можно подставить `/v1` вначале роутов.

Службы GraphQL часто отвечают на любой запрос, не относящихся к GraphQL, с “query not present” или аналогичной ошибкой. С помощью данных ошибок можно определить наличие GraphQL.

---
# Общая теория

## [[API#**GraphQL**|Введение]]

## Система типов 
Давайте ещё раз посмотрим на картинку с SDL, и пройдёмся по ней:
![[Pasted image 20240614201757.png]]
### **Скалярные типы**

Это конечные типы данных, в них не могут быть вложены другие типы данных: Int, Float, String, Boolean и ID.

На картинке это поля name, id, description.

### Тип Object
![[Pasted image 20240614201827.png]]
Типы Object определяются с помощью ключевого слова type и по соглашению начинаются с заглавной буквы. Они определяют имя типа и поля, присутствующие в этом типе. В объекты могут быть вложены другие объекты, т.е. он имеет поля. В объекте могут как быть как другие объекты, так и скалярные типы.

На картинке у нас есть объект Todo, Query и Mutation. Последние 2 объекты являются объектами в самом GraphqQL, но самый обязательный из них это Query, без него не может работать GraphQL-приложение!

Давайте поговорим про встроенные типы GraphQL’а!
### **Тип Query**

В GraphQL тип `Query` представляет из-за себя аналогом GET-запроса. Этот тип определяет, какие запросы клиент может выполнить, чтобы получить данные из GraphQL-схемы. Тип `Query` содержит поля, которые соответствуют различным запросам, которые клиент может сделать.

Пример определения типа `Query` в GraphQL Schema Definition Language (SDL):

```graphql
type Query {
  getUser(id: ID!): User
  getPosts: [Post]
}

```

В этом примере:

- `getUser(id: ID!): User` - это поле `getUser`, которое принимает аргумент `id` типа `ID` и возвращает объект типа `User`.
- `getPosts: [Post]` - это поле `getPosts`, которое возвращает массив объектов типа `Post`.

Тип `Query` позволяет клиентам запрашивать данные, но не включает операции изменения данных (например, создание, обновление или удаление), так как операции изменения обычно обрабатываются через тип `Mutation`.

На картинке мы можем с помощью Query получить одну тудушку по его ID, либо сразу все тудушки.

Пример Query запроса:![[Pasted image 20240614201909.png]]
Пример ответа сервера в JSON:![[Pasted image 20240614201918.png]]
Как вы видите, в ответе нам пришли только те поля, которые мы запросили. Это одна из ключевых особенностей GraphQL, как я описывал ранее.
### Тип Mutation
В GraphQL тип `Mutation` представляет из себя аналогом POST и создан для операций изменения данных (например, создание, обновление или удаление) в GraphQL-схеме. Этот тип определяет, какие мутации (изменения) клиент может выполнить на сервере для изменения состояния данных.

Пример определения типа `Mutation` в GraphQL Schema Definition Language (SDL):

```graphql
type Mutation {
  createUser(input: CreateUserInput!): User
  updateUser(id: ID!, input: UpdateUserInput!): User
  deleteUser(id: ID!): Boolean
}
```

В этом примере:

- `createUser(input: CreateUserInput!): User` - это мутация `createUser`, которая принимает аргумент `input` типа `CreateUserInput` и возвращает объект типа `User`.
- `updateUser(id: ID!, input: UpdateUserInput!): User` - это мутация `updateUser`, которая принимает аргументы `id` типа `ID` и `input` типа `UpdateUserInput`, а затем возвращает объект типа `User`.
- `deleteUser(id: ID!): Boolean` - это мутация `deleteUser`, которая принимает аргумент `id` типа `ID` и возвращает логическое значение `Boolean`.

Тип `Mutation` позволяет клиентам выполнить операции изменения данных, а именно создавать, обновлять или удалять записи. Операции изменения выполняются на сервере и могут изменять состояние данных в соответствии с логикой приложения.

Пример запроса(с параметрами) и ответа:![[Pasted image 20240614202005.png]]
Раз я затронул переменные, то быстренько по ним пройдёмся.

Аргументы для запросов в большинстве приложений должны быть динамическими. Передавать динамические аргументы непосредственно в строку запроса было бы не лучшим решением.

К счастью, GraphQL позволяет передавать переменные в запрос операций.
```graphql
query PersonName($id: Int) {
  person(id: $id) {
    name
  }
}
```

Затем можно передать переменные через объект, чтобы сделать запрос:

```graphql
{
  "id": 1000
}
```

Определения переменных начинаются с префикса $ , затем ставится имя переменной, и потом идёт тип переменной.

В приведённом нами примере имя переменной — $id, а тип переменной — Int.

Все объявленные переменные должны быть скалярного, перечисляемого или другого типа входного объекта.

Чтобы передать в поле сложный объект, необходимо знать тип входных данных, соответствующий ему на сервере.

Для переменных можно задавать стандартные значения:

```graphql
query PersonName($id: Int = 1) {
  person(id: $id) {
    name
  }
}

```

Здесь мы добавили = 1 после $id: Int, установив для переменной $id стандартное значение, равное 1.
### **Тип Subscription**

В GraphQL, тип `Subscription` предоставляет механизм для подписки на потоки данных по веб-сокетам. В отличие от типов `Query` и `Mutation`, которые обрабатывают статические запросы на чтение и изменение данных соответственно, тип `Subscription` позволяет клиентам следить за изменениями данных.

Пример определения типа `Subscription` в GraphQL Schema Definition Language (SDL):

```graphql
type Subscription {
  newMessage(channelId: ID!): Message
}
```

В этом примере:

- `newMessage(channelId: ID!): Message` - это подписка `newMessage`, которая принимает аргумент `channelId` типа `ID` и возвращает объект типа `Message`. Клиенты могут подписаться на события новых сообщений для определенного канала.

Используя тип `Subscription`, клиенты могут подписываться на определенные события, такие как обновления в реальном времени, и автоматически получать данные при их возникновении по веб-сокетам.
![[Pasted image 20240614202113.png]]

---
## **Интроспекция**

### **Что это такое**

Также стоит упомянуть про такую вещь как интроспекция.

**Introspection** - это встроенная функция GraphQL, которая позволяет запрашивать у сервера информацию о её схеме.

Интроспекция поможет вам понять, как вы можете взаимодействовать с GraphQL API: какие запросы можно делать, какие поля есть у объектов и тд.

Тут встаёт 1 вопрос - а в чём разница между интроспекцией и SDL? Они ведь оба нужны для того, чтобы помогать разработчикам разбираться в схеме GraphQL.

Ответ тут прост: SDL - это файлик, а интроспекция это функция, которую можно вызвать на клиенте. Вы просто отправляете 1 запрос и сразу получаете всю схему приложения, что очень удобно, так как в REST API и в др. API приходится ходить по всему приложению, собирая все эндпоинты, все методы, все параметры и т.д. И в GraphQL пентестеру теперь не надо всем этим заниматься, досточно отправить HTTP-запрос и всё приложение у вас перед глазами.

Пример запроса интроспекции и ответа на него:![[Pasted image 20240614202241.png]]
Обратите внимение, что запросы GraphQL отправляются в Json, и соответственно имеют `Content-Type: application/json` в запросе.

Это важно для раздела CSRF!

Также запросы могут иметь параметр `operationName` , в котором описывается что это за операция. Помимо неё есть необязательное название query,mutation,subscription запроса:![[Pasted image 20240614202303.png]]
Вообще он нужен, чтобы разработчики не запутались в запросах, и понимали, что они делают:)

Данный запрос(который называется IntrospectionQuery) возвращает все запросы, объекты и пр. Выглядит он примерно так:
```graphql
    query IntrospectionQuery {
      __schema {

        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          description

          locations
          args {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      description

      fields(includeDeprecated: true) {
        name
        description
        args {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        description
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      description
      type { ...TypeRef }
      defaultValue


    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }

```
Если же нужно просто получить все виды запросов, то нужно отправить следующий запрос:
```graphql
    query {
        __schema {
            types {
                name
                fields {
                    name
                }
            }
        }
    }
```

Также для проверки наличия GraphQL можно отправить следующий запрос:
```graphql
query{
    __typename
}

```

И если где-нибудь в ответе будет следующая строка, то значит вы нашли эндпоинт GraphQL:

```json
{
    "data": {
        "__typename": "query"
    }
}

```
Запрос работает, потому что каждая конечная точка GraphQL имеет зарезервированное поле под названием __typename, которое возвращает тип запрашиваемого объекта в виде строки.

Обычно у запроса интроспекции вложенность до 4-8 полей, так как иногда объекты ссылаются друг на друга, и чтобы это не превратилось в бесконечную рекурсию делают определённое кол-во вложенностей.

Стоит сказать о том, что в некоторых движках GraphQL интроспекция может быть отключена, и надо будет либо собирать все методы как в REST API, либо брутать схему, о том как это делать, я скажу позже.

### **Как анализировать полученную схему из интроспекции/SDL**

После получения схемы встаёт вопрос о том, как её анализировать. И тут есть 2 пути:

- Быть гигачадом, анализируя кучу текста.
- Использовать различные тулзы, которые облегчают данный процесс анализа.
	[[#Инструменты]]

---
## **Движки GraphQL**

GraphQL обычно реализуют через различные движки. Самыми популярными движками являются Apollo и Hasura.

Иногда эти движки могут иметь свои уникальные уязвимости:)

### **Apollo**

Этот движок можно охарактеризовать как “чистая реализация GraphQL”. В нём нет каких-то фишек, это простая реализация GraphQL.

### **Hasura**

Этот движок уже поинтереснее, так как помимо обычного GraphQL они решили ввести некоторые свои особенности, которые в определённых версиях движка были уязвимы, давайте же ознакомимся с ними:)

---
#### **Узвимости Hasura**

##### **X-Hasura-Role**

В Хасуре решили внедрить готовые механизмы ролей и прав доступа, чтобы разработчикам не нужно было это реализовывать самим каждый раз. Однако до версии 2.0 эти механизмы были подвержены различным уязвимостям.

В Hasura роль пользователя и все другие доступные роли находятся в JWT токене.

**JWT (JSON Web Token)** - это структурированный формат токена, который используется для обмена информацией между двумя сторонами. Он часто используется в аутентификации и авторизации веб-приложений и служб. JWT представляет собой компактный и самодостаточный способ передачи информации в виде JSON-объекта, который может быть безопасно передан между клиентом и сервером или между различными службами.

JWT состоит из трех частей:

1. **Заголовок (Header)**: Содержит метаданные о типе токена и используемом алгоритме шифрования.
2. **Полезная нагрузка (Payload)**: Содержит информацию, которую нужно передать в токене, например, идентификатор пользователя или другие пользовательские данные.
3. **Подпись (Signature)**: Используется для проверки подлинности токена. Подпись создается на основе заголовка и полезной нагрузки с использованием секретного ключа на сервере, и она проверяется для обеспечения целостности и подлинности токена на стороне получателя.

JWT-токены широко применяются для аутентификации и авторизации в веб-приложениях и API. Они компактны, легко передаются в HTTP-заголовках или внутри URL-запросов, и могут содержать информацию о правах доступа пользователя или другие пользовательские данные. JWT также могут иметь ограниченное время жизни, что обеспечивает безопасность и уменьшает риски использования украденных токенов.

Раскодированная payload часть JWT-токена:
```
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022,
  "<https://hasura.io/jwt/claims>": {
    "x-hasura-default-role": "user",
    "x-hasura-allowed-roles": ["user", "admin"],
    "x-hasura-user-id": "123",
    "x-hasura-org-id": "456",
    "x-hasura-custom": "custom-value"
  }
}

```

Обычно данный jwt token отправлялся с заголовком X-Hasura-Role, имеющим значение роли пользователя.

Однако в версии Hasura ниже 2ой есть уязвимость, при которой если отправить запрос с заголовком X-Hasura-Role и без JWT-токена, то можно прописать себе любую роль в приложении, тем самым повысив свои привелегии до администратора:)

##### **X-Hasura-Admin-Secret**

Также есть заголовок X-Hasura-Admin-Secret, если в качестве его значения будет валидный пароль администратора, то можно выполнять любые действия администратора. Таким образом, можно безопасно брутать пароль админа на любой странице приложения и без блокировок:)

##### **Метаданные**

Также иногда существует возможность достучаться до метаданных приложения через эндпоинт `/v1/metadata`. Если получится получить доступ к этой странице, то можно будет получить все данные о приложении и др.

##### **Bulk SQL-queries**

Для версии 1.3.3 возможно прозксплуатировать bulk выполнение mutations с помощью кастомного запроса на /v1/query для выполнения сырых SQL запросов:)

Сейчас такую версию будет тяжело уже встретить, но если встретится, то можно будет проверить!