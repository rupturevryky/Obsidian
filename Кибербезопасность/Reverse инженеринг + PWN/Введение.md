# План

---

1. **Введение**
1.1. Что такое реверс инжиниринг? 
1.2. Значение реверс-инжиниринга в CTF и информационной безопасности 
1.3. Разделение реверс-инжиниринга: программный и аппаратный

2. **Инструменты для реверса и отличие файло**в 
2.1. Список инструментов для реверс-инжиниринга
2.2. В чём отличие реверса разных файлов друг от друга

3. **С помощью чего создают таски по реверс-инжинирингу** 
3.1. Языки и технологии для создания тасков 
3.2. Реверс на примере Python

4. **Заключение**

---

# 1.0 Введение

---
![[Pasted image 20240613151121.png]]
## 1.1 Что такое реверс-инжиниринг?

---

**Реверс-инжиниринг** (от слова Reverse Engineering) или же просто **реверс** - **это процесс анализа какого-либо предмета или объекта с целью понимания и изучения его алгоритма работы, внутреннего строения и функционала**. В контексте **CTF** (**C**apture **T**he **F**lag) и **и**нформационной **б**езопасности (далее **ИБ**) реверс-инжиниринг используется для изучения работы всего приложения или сервиса, исследования и анализа уязвимостей в нём, обнаружения скрытого функционала и механизмов.

Так же говорят, что реверс-инжиниринг - обратный **процесс** разработки объектов. К примеру, возьмём объект “Программное Обеспечение” (ПО). Это значит, что при обычной разработке ПО мы переводим понятный **нам** код в инструкции, **которые понятны только компьютеру**. А при обратном процессе разработки (реверсе) мы из инструкций, понятных только компьютеру, получаем **код или описание алгоритма работы программы, которые понятны нам, людям**. В этом и заключается обратный процесс разработки.

## 1.2 Реверс-инжиниринг в CTF и информационной безопасности

---

В **CTF** реверс-инжиниринг - это отдельная категория тасков^[Таск (от англ. Task) - это задание в CTF], в которых участникам предлагается **проанализировать** **исходный код** **или уже готовые исполняемые файлы программ**, чтобы найти флаги и получить очки за них^[Главная цель тасков - найти флаги для получения очков]. Задачи из данной категории помогают участникам развивать аналитические навыки, глубже понимать принципы работы программ и систем.

![[Pasted image 20240613151203.png]]

В **ИБ** реверс-инжиниринг используется для: 1. Исследования вредоносных программ 2. Обнаружения скрытых уязвимостей 3. Разработки защитных мер 4. Отправки данных в SOC^[**SOC** (**S**ecurity **O**perations **C**enter) - это центр управления безопасностью, который предназначен для мониторинга, обнаружения и реагирования на кибератаки и другие инциденты безопасности в компьютерных системах и сетях.]

Например, путем анализа вредоносного кода специалисты могут понять алгоритм работы вредоносной программы, её цели и задачи. После получения этой информации данные будут использоваться для создания правил обнаружения.

![[Pasted image 20240613151236.png]]

Основные инструменты, используемые при реверс-инжиниринге - это **дизассемблеры**, **декомпиляторы**, **отладчики**, **разного рода анализаторы**, **специализированное ПО для эмуляции или виртуализации** и другие инструменты, которые помогают анализировать и понимать исполняемый код или аппаратуру.

На [Codeby Games](https://codeby.games/) тоже есть категория “Реверс-инжиниринг”. А данный урок из курса “Введение в CTF” поможет вам приступить к решению заданий из этой темы.

## 1.3 Разделение реверс-инжиниринга: программный и аппаратный

---

Реверс может быть разделен на две основные категории: 1. **Программный** 2. **Аппаратный**

## 1.3 Разделение реверс-инжиниринга: программный и аппаратный

---

Реверс может быть разделен на две основные категории: 1. **Программный** 2. **Аппаратный**

### 1.3.1 Программный реверс-инжиниринг

**Программный реверс-инжиниринг** (_Software Reverse Engineering_) - это процесс изучения кода приложения с целью понимания его алгоритма работы и функционирования. В ходе программного реверс-инжиниринга анализируют уже готовые исполняемые (бинарные) файлы. Это позволяет понять, как работает **п**рограммное **о**беспечение (**ПО**), восстановить его исходный код или найти уязвимости.

![[Pasted image 20240613151003.png]]
### 1.3.2 Аппаратный реверс-инжиниринг

**Аппаратный реверс-инжиниринг** (_Hardware Reverse Engineering_) - это процесс изучения физического оборудования с целью понимания его функционала. В ходе аппаратного реверс-инжиниринга специалисты взаимодействуют с устройствами и их содержимым, изучая их компоненты: печатные платы, радиоэлектронную начинку и другие. Информация, полученная после анализа, даёт нам понимание, как работает устройство, сделать выводы о его слабых местах или создать аналогичное устройство.

![[Pasted image 20240613151256.png]]

Каждый из описанных выше видов реверс-инжиниринга применяется в своей области, но в данном уроке мы немного пройдёмся по программному реверс-инжинирингу.

> [!warning] Важное напоминание Нужно помнить и знать, что реверс-инжиниринг может нарушать авторские права и лицензионные соглашения, поэтому **его применение должно быть законным и этичным**. Лучшей практикой будет решение CTF Codeby Games! :)
# 2.0 Инструменты для реверса и особенности файлов

---

## 2.1 Инструменты для реверс-инжиниринга

---

Для облегчения своей работы, специалисты реверс-инженеры используют разнообразный специализированный софт, разработанный и большими корпорациями, и группами энтузиастов. Подобные утилиты помогают обнаруживать уязвимости, анализировать код и восстанавливать структуру приложений.

Подобные инструменты можно разделить на 2 большие категории и подкатегории:

### 2.1.1 Категории и подкатегории

1. **Инструменты для статического анализа**.
2. **Инструменты для динамического анализа**.

**Статический анализ** - это процесс анализа приложения без его выполнения. Во время статического анализа проверяется исходный код на наличие потенциальных ошибок, стандартных проблем или неправильного использования языка программирования. Этот анализ может включать в себя проверку синтаксиса, типизацию, неиспользуемые переменные, потенциальные уязвимости и другие проблемы, которые могут быть обнаружены без фактического выполнения кода.

**Динамический анализ**, с другой стороны, основывается на фактическом выполнении приложения или системы. Суть динамического анализа состоит в запуске изучаемого файла и отслеживания его действий во время работы. Это позволяет обнаружить более сложные проблемы, такие как ошибки времени выполнения, утечки памяти, производительность и другие аспекты, которые могут быть обнаружены только во время выполнения кода.

#### Оба подхода имеют свои преимущества и недостатки

Статический анализ поможет изучить приложение, если оно потенциально опасно и его запуск связан со значительными рисками. Статический анализ проводить чаще сложнее, чем динамический из-за того, что приложение нельзя запустить.

В ходе динамического анализа приложение может нанести вред системе или подвергнуть опасности ваши данные.

### 2.1.2 Категории и подкатегории инструментов

![[Pasted image 20240613151313.png]]

1. Инструменты для статического анализа
    1. **Дизассемблеры**
    2. **Декомпиляторы**
    3. **Анализаторы исполняемых файлов**
    4. **ПО для редактирования файлов**
    5. **ПО для работы с методами антиотладки**
2. Инструменты для динамического анализа
    1. **Отладчики**
    2. **Инструменты для анализа событий в операционной системе**
    3. **ПО для виртуализации, контейнеризации или эмуляции**
    4. **Инструменты для анализа трафика**

#### Инструменты для статического анализа

1. **Дизассемблеры** (от англ. disassembler): Эти инструменты пытаются преобразовать машинный код в понятный человеку текст программы. Чаще всего это язык ассемблера. Они позволяют анализировать исполняемые файлы без фактического выполнения.
2. **Декомпиляторы** (от англ. decompiler): в свою очередь они преобразуют исполняемые файлы или байт-код обратно в **исходный код на высокоуровневом языке программирования, минуя ассемблер**. Они полезны при анализе больших программ и если нужно определить основные функции ПО. Декомпиляторы по точности восстановленного кода уступают дизассемблерам.
3. **Анализаторы исполняемых файлов**: Эти инструменты могут использоваться для анализа компонентов исполняемых файлов. Например: анализ заголовков исполняемых файлов, даты создания, хешей, строк в ПО и многом другом.
4. **ПО для редактирования файлов**: Подобные утилиты пытаются представить содержимое файла в текстовом виде, преобразуя байты в читабельный текст. Ярким примером таких инструментов служат HEX-редакторы
5. **ПО для работы с методами антиотладки**: Многие разработчики слышали о реверс-инжиниринге и зачастую программный продукт специально за
### Инструменты для динамического анализа

1. **Отладчики** (_Debugger_): **Отладчики запускают анализируемый исполняемый файл и пытаются отследить его работу**. Они помогают исследовать состояние программы во время выполнения, анализировать переменные, стек вызовов и другие важные моменты.
2. **Инструменты для анализа событий в операционной системе**: Эти инструменты позволяют анализировать и получать информацию о событиях, происходящих в операционной системе во время выполнения программы. Например, они могут отслеживать системные вызовы или изменения в файловой системе.
3. **ПО для виртуализации, контейнеризации или эмуляции**: Виртуализация позволяет создавать изолированные среды под нашим полным контролем, где можно запускать программы, которые вы боитесь запустить на основной машине. Это позволяет изучать и анализировать поведение программы без риска влияния на основную операционную систему.
4. **Инструменты для анализа трафика**: Эти инструменты отслеживают сетевое взаимодействие программы, пытаются перехватить сетевой трафик для последующего проведения его анализа. Они могут помочь в идентификации и анализе сетевых протоколов, обнаружении уязвимостей или анализе безопасности сети.
### 2.1.3 Список полезных инструментов для реверс-инжиниринга
[[Кибербезопасность/Инструментарий#Реверс-инжиниринг]]
## 2.2 В чём отличие реверса разных файлов друг от друга

---

Разнообразие инструментов и решений вызвано тем, что стек современных технологий настолько разнообразен, что приходится под каждую архитектур и платформу создавать свой инструмент.

Обычно файлы выделяют в 2 категории: 1. **Исполняемые файлы** 2. **Файлы данных**

### **2.2.1 Исполняемые файлы**

![[Pasted image 20240613151340.png]]

**Реверс-инжиниринг исполняемых файлов включает в себя анализ кода, выявление функций, структур и алгоритмов, а также понимание взаимодействия программы с операционной системой и другими компонентами**. Отличия в реверсе исполняемых файлов могут быть связаны с различиями в **формате файла**, **используемых инструкциях** и **архитектуре процессора**.

#### **Наиболее используемые форматы файлов**

1. **EXE** - под Windows.
2. **ELF** - под Linux.
3. **APK** - под Android
4. **IPA** - под Iphone.
5. **Mach-O** - под MacOS.

Архитектура определяет структуру и организацию процессора, памяти и других компонентов компьютерной системы. Различные архитектуры имеют разные наборы инструкций и способы обработки данных. В результате исполняемые файлы, предназначенные для разных архитектур, могут иметь различный машинный код и специфические инструкции.

#### **Наиболее используемые архитектуры**

1. **x86**/**x64** - персональные компьютеры и сервера
2. **ARM** - мобильные телефоны
3. **AVR**/**MIPS** - встраиваемые системы

### **2.2.2 Файлы данных**

![[Pasted image 20240613151634.png]]

Реверс-инжиниринг бинарных файлов может включать изучение структуры и формата файла, анализ кода и алгоритмов, идентификацию и извлечение данных. Отличия в реверсе бинарных файлов могут быть связаны с различиями в **формате файлов**, используемых компиляторах или средах разработки. Под многие форматы файлов используется специальное ПО, которое предназначено конкретно под определённый формат.

# 3.0 Популярные технологии и языки для разработки тасков по реверс-инжинирингу

---

Большинство тасков на реверс **в CTF** подразделяются на следующие категории:

1. **CrackMe**
2. **Работа с сетью**
3. **Работа с ядром**

**Крякми** (от англ. CrackMe) - это вид программ, что используются для тренировки навыков по реверс-инжинирингу. Большинство крякми устроены так: 1. Мы вводим что-то в программу или совершаем какие-то действия. 2. Программа некоторым образом обрабатывает наш ввод (шифрует, дешифрует, кодирует и так далее). 3. Программа проверяет, являются ли наши действия ожидаемыми или проверяется правильность ввода данных. Например, сравнивает зашифрованный ввод с правильным зашифрованным вводом. 4. Результатом успешно пройденной проверки является флаг. Получив его, мы можем считать, что правильно выполнили задание.

Разрабатывая подобные программы, создатели всячески усложняют реверс-инженерам анализ. Например, добавляют методы шифрования или скрытия кода, проверяют, запущена ли анализируемая программа в отладчике и так далее.

**В тасках по работе с сетью** чаще всего нужно будет изучать то, как код взаимодействует с удалённым сервером или ожидает подключений от клиентов. Для прохождения заданий и получения флага нужен будет анализатор трафика как, например, Wireshark.

**В тасках по работе с ядром** чаще всего будет давать само ядро или образ для QEMU^[ПО с открытым исходным кодом, которое предоставляет возможность эмуляции различных аппаратных платформ]. Нужно изучать, как ядро работает и получить флаг из него.

## 3.1 Языки и технологии для создания тасков

### 3.1.1 Язык Си

![[Pasted image 20240613151717.png]]

**С** - это низкоуровневый язык программирования, который известен своей эффективностью и скоростью выполнения. Он широко используется для разработки операционных систем, встроенных систем, драйверов и других программ, где требуется максимальная производительность и контроль над аппаратными ресурсами. **Отличительная особенность**: максимальная близость к ассемблеру и более простое понимание по сравнению с другими компилируемыми языками. Код на языке переводится в машинные инструкции. **Чем ревёрсить**: дизассемблер или декомпилятор (для создания “скелета функции”).

### 3.1.2 Язык C++

![[Pasted image 20240613151730.png]]

**C++** - это расширение языка C, которое добавляет объектно-ориентированное программирование и другие возможности. C++ широко применяется в разработке больших проектов, игр, графических приложений, операционных систем и других приложений, требующих высокой производительности и мощных функций. **Отличительная особенность**: максимальная близость к ассемблеру, более сложное понимание кода по сравнению с другими языками и наличие ООП. Код на языке переводится в машинные инструкции. **Чем ревёрсить**: дизассемблер или декомпилятор (для создания “скелета функции”).

### 3.1.3 Язык Ассемблера

![[Pasted image 20240613151742.png]]

**Assembler** - это низкоуровневый язык программирования, который предоставляет прямой доступ к аппаратным ресурсам компьютера. Он используется для написания программ, работающих на самом низком уровне, таких как драйверы устройств, операционные системы и встраиваемые системы. **Отличительная особенность**: максимально прост с точки зрения команд, но код на нём в целом обычно достаточно непросто понять. Код на языке переводится в машинные инструкции. **Чем ревёрсить**: дизассемблер.

### 3.1.4 Язык .NET

![[Pasted image 20240613151804.png]]

**.NET**/**C#**: .NET - это платформа разработки, разработанная компанией Microsoft. Она включает в себя языки программирования, такие как C# и VB.NET, и предоставляет инструменты для разработки веб-приложений, настольных приложений, игр и других программ. .NET также предлагает мощные библиотеки и интегрированную среду разработки для упрощения процесса разработки. **Отличительная особенность**: проще всего восстановить готовую программу к исходному коду по сравнению с другими языками, но только если код не обфусцирован. Код на языки переводится в IL-код^[IL-код (**IL** - **I**ntermediate **L**anguage - “промежуточный язык”) промежуточный вариант кода между исходным кодом программы и машинными инструкциями]. **Чем ревёрсить**: DnSpy или .Net Reflector.

### 3.1.5 Язык Python

![[Pasted image 20240613151816.png]]

**Python** - это высокоуровневый язык программирования, который известен своей простотой и читаемостью. Он широко используется для различных целей, включая веб-разработку, анализ данных, искусственный интеллект и автоматизацию задач. Python имеет богатую экосистему библиотек, понятный синтаксис и простоту изучения. Всё это делает его популярным среди разработчиков. **Отличительная особенность**: часто код поставляется или передаётся в виде текста, довольно просто восстановить готовый PYC-файл^[Файл с байт-кодом программы] или исполняемый файл к исходному коду по сравнению с другими языками, но только если код не был обфусцирован^[**Обфускация** - это процесс изменения исходного кода программы с целью затруднения его понимания и анализа.]. **Чем ревёрсить**: если файл PYC - `uncompyle6`, если исполняемый файл на основе Pyinstaller - `pyinstxtractor` и `uncompyle6`.

### 3.1.6 Язык Java

![[Pasted image 20240613151830.png]]

**Java** - это широко используемый язык программирования, разработанный компанией Sun Microsystems (ныне принадлежит Oracle). Он известен своей платформенной независимостью и широким применением в различных областях. **Отличительная особенность**: довольно просто восстановить готовый JAR-файл или к исходному коду по сравнению с другими языками, но только если код не был обфусцирован. Код на языки переводится в байт-код^[Промежуточный вариант кода между исходным кодом и машинными инструкциями] **Чем ревёрсить**: BytecodeViewer, JD-GUI, jadx

### 3.1.7 Язык Rust

![[Pasted image 20240613151844.png]]

**Rust** - это относительно новый системный язык программирования, который изначально разрабатывался Mozilla. Он известен своими возможностями по обеспечению безопасности и эффективности. Rust предоставляет механизмы для предотвращения ошибок времени выполнения, таких как сбой программы или утечки памяти. Он широко используется для разработки высокопроизводительных и надежных систем.  
**Отличительная особенность**: бывает сложнее изучать, чем C++. Определённая сложность связана с указателями в коде. Код компилируется в машинные инструкции. **Чем ревёрсить**: дизассемблер и декомпилятор.

### 3.1.8 Язык Go

![[Pasted image 20240613151924.png]]

Go - это язык программирования, разработанный компанией Google. Он предназначен для создания эффективных и надежных программных систем. Go обладает простым и читаемым синтаксисом, а также встроенной поддержкой параллелизма. Он широко используется для разработки сетевых приложений, микросервисов и облачных технологий.  
**Отличительная особенность**: код сложнее C, но проще C++. Не будет никаких “фокусов” с указателями в коде. Из-за особенностей языка иногда отладка может проходить прерывисто. Код компилируется в машинные инструкции. **Чем ревёрсить**: дизассемблер и декомпилятор.

### 3.1.9 Язык Kotlin

![[Pasted image 20240613151934.png]]

**Kotlin** - это язык программирования, который работает на платформе Java. Он предоставляет мощные возможности объектно-ориентированного программирования и функционального программирования. Kotlin является официальным языком разработки для разработки приложений под платформу Android. **Отличительная особенность**: программы под Android, более лёгкое восстановление к исходному коду по сравнению с другими языками, если код не обфусцирован. Использует байт-код. **Чем ревёрсить**: jadx, apktool

## 3.2 Язык Python: введение и небольшая практика в виде 1-2 тасков

---

### 3.2.1 Введение

**Python** - это высокоуровневый, интерпретируемый язык программирования, который изначально был разработан Гвидо ван Россумом и выпущен в 1991 году. Он предназначен для удобного и читаемого программирования, обладает простым и понятным синтаксисом, что делает его отличным выбором для начинающих разработчиков, а также для быстрого прототипирования и разработки.

Так как язык является интерпретируемым, то не происходит привычного процесса компиляции. Вместо этого всё происходит так:

```
graph LR
  A["Написание кода на Python"] --> B["Перевод в байт-код"]
  B --> C["Выполнение байт-кода в виртуальной машине Python"]

  style A fill:#272727, stroke:#FFFFFF;
  style B fill:#272727, stroke:#FFFFFF;
  style C fill:#272727, stroke:#FFFFFF;
```

#### Hello world на Python

```
print("Hello world!")
```

### 3.2.2 Реверс на примере Python

#### Особенности реверс-инжиниринга в Python

1. **Доступность исходного кода**: В большинстве случаев Python-программы распространяются в виде исходного кода, что облегчает анализ.
2. **Легко читаемый байт-код**: Python-интерпретатор компилирует исходный код в промежуточный байт-код (расширение .pyc), который остается достаточно читаемым, что может упростить реверс-инжиниринг.

**Файл .pyc** - это некий скомпилированный выходной файл, который содержит в себе байт-код. Сам байт-код в целом похож на ассемблерный код и он же используется для выполнения кода как раз самим интерпретатором.

Исполняемый файл (EXE, ELF) компилируется специальными библиотеками самого Python (**Pyinstaller**, **Auto Py To Exe**) или отдельными утилитами. Предпосылками компиляции питоновского кода могут быть разными, например, пользователям не хочется устанавливать зависимости.

> [!warning] Важная информация Исполняемый файл, написанный на языке python, будет содержать в себе и сам интерпретатор, и необходимые модули. **Это значит, что передавая такой EXE-файл, вы отправляете код и программу, которая его запускает просто в запакованном виде**. Это упрощает восстановление кода.

Возникают две ситуации при реверсе: 1. **Реверс инженеру дают исходный код**; 2. **Реверс инженер получает исполняемый файл**, в процессе анализа выясняется, что исходным языком программирования являлся Python.

С первой ситуацией попроще так, как можно просто открыть исходный код в любом текстовом редакторе и понять логику работы программы. А вот во втором случае надо будет из исполняемого файла получить исходный файл .py. Это происходит в два этапа: 1. **Из исполняемого файла получается файл .pyc**; 2. **Из файла .pyc получается исходный файл .py**.

Типовые инструменты для реверса Python: 1. [PyInstaller Extractor](https://github.com/extremecoders-re/pyinstxtractor) (`.exe` -> `.pyc`); 2. [pycdc](https://github.com/zrax/pycdc), [uncompyle6](https://github.com/rocky/python-uncompyle6), [decompyle3](https://github.com/rocky/python-decompile3) (`.pyc` -> `.py`).
### 3.2.3 Примеры заданий

---

Файлы заданий будут прикреплены к уроку. Сейчас мы их разберём.

#### Вариант 1: исходный код .py и .enc

В данном задании используются файлы: `Python_task1.py` и `flag.enc`. **Цель**: получить флаг из `flag.enc`.

Код из `Python_task1.py`:

```
FLAG = "CODEBY{!REDACTED!}"
XOR_KEY = "f00487cfafa4519d4cfd"

with open("flag.enc", 'w') as f:
    for i, value in enumerate(FLAG):
        tmp = ord(value) ^ ord(XOR_KEY[i % len(XOR_KEY)])
        f.write(hex(tmp + 228))
        f.write('\n')
```

##### Разбираем алгоритм работы программы

1. Сначала каждый символ строки флага ксорится^[применяется операция XOR] последовательно с символом ключа **f00487cfafa4519d4cfd**;
2. Дальше к полученному байту из пункта 1 прибавляется 228;
3. И в конце в файл записывается 16-ричное значение числа из пункта 2 с учётом переноса строки.

##### Операция XOR

Операция XOR (ИСКЛЮЧАЮЩЕЕ ИЛИ) выполняет операцию “ИСКЛЮЧАЮЩЕЕ ИЛИ” между битами двух операндов. В Python операция XOR обозначается через `^` и выполняется только между 2 числами. Например, `131^15=140`.

**Важный момент**: операция XOR **обратима**! Это значит, что если мы возьмём пример `131^15=140`, то можем получить исходные данные (`131`), если знаем зашифрованный вариант - `140` и ключ (`15`). Получим: `140^15=131`. И это пригодится нам для решения.

Не будем пока что смотреть способ работы на уровне битов, так как нам хватит уровня языка Python для решения таска.

Для получения флага нужно написать дешифратор (обратный алгоритм).

##### Обратный алгоритм

1. Считываем построчно файл и HEX переводим в `int` (не забываем убирать перенос строки);
2. Отнимаем от числа 228 (**вычитание противоположная (обратная) операция сложения**);
3. Последовательно ксорим с ключом и сохраняем в строковую переменную (`xor` - **противоположная (обратная) операция от** `xor`).

Принцип решения схож с решением уравнений.

\[ \begin{align} x &+ 100 = 131 \\ x &= 131 - 100 \\ x &= 31 \end{align} \]

Как видно, для получения `x` нужно просто выполнить обратную операцию для сложения - **вычитание**. Так же и с решением таска.

##### Запомните

1. Для **сложения** обратная операция - **вычитание**.
2. Для **вычитания** обратная операция - **сложение**.
3. Для **xor** обратная операция - **xor**.

#### Решение

Файл `flag.enc` должен быть в одной директории с файлом `Python_task1.py`.

```
XOR_KEY = "f00487cfafa4519d4cfd"
flag = ""
count = 0

with open('flag.enc', 'r') as f:
    for line in f:
        data = int(line[:-1], 16)
        data -= 228
        flag += chr(data ^ ord(XOR_KEY[count % len(XOR_KEY)]))
        count += 1

print(flag)
```

Запускаем.

![[Pasted image 20240613151955.png]]

Получаем флаг: `CODEBY{7852983a9a52e5f29a6c408941b9651da44f14f2}`

#### Вариант 2: скомпилированный скрипт Python

В данном задании используются файлы: `Python_task2.exe`. **Цель**: получить флаг из `Python_task2.exe`.

Скачиваем Pyinstaller Extractor и запускаем его следующей командой:

```
python .\pyinstxtractor.py .\Python_task2.exe
```

Вывод:

![[Pasted image 20240613152056.png]]

Может быть, программа предупредит, что нужно запускать скрипт с помощью Python 3.8 и ниже.

Если запускать скрипт через Python версии больше 3.8, то получим такое сообщение об ошибке.

```
[!] Warning: This script is running in a different Python version than the one used to build the executable.
[!] Please run this script in Python 3.8 to prevent extraction errors during unmarshalling
[!] Skipping pyz extraction
```

Для решения задания нужен Python именно [версии 3.8](https://www.python.org/downloads/release/python-380/).

После запуска скрипта в директории появится каталог, в котором будут распакованные файлы. Среди файлов нужен будет **Python_task2.pyc**. Он нам и нужен.

Используем `decompyle3`, чтобы перевести байт-код из PYC-файла в декомпилированный вариант.

Установка:

```
pip3 install decompyle3
```

Запуск:

```
decompyle3 .\Python_task2.exe_extracted\Python_task2.pyc
```

Вывод:

![[Pasted image 20240613152111.png]]

Вывод в виде текста:

```
import base64, sys
FLAG = 'p6ugoaa9n9fc1dWF0ICCgN3c3YDQ09yA1oDX1tHcgNWHhdOFhoCH3dPT0tKGhtOZ'
SECRET = '1Y/VnNWL1IrVptWK1Y3Vi9SJ1ZfVntWm1YnVkdWL1ZjVitSY'

def check(inp):
    tmp = ''
    for i in inp:
        tmp += chr(ord(i) ^ 1337)
    else:
        if tmp == base64.b64decode(SECRET).decode():
            return True
        return False


count = 1
while True:
    while True:
        inp = str(input('Enter phrase: '))
        if check(inp):
            print('Succesful!')
            for i in base64.b64decode(FLAG):
                print((chr(i ^ 228)), end='')
            else:
                sys.exit()

    if count == 3:
        print("You're blocked!")
        sys.exit()
    else:
        print('Wrong! Try again!')
        count += 1
```

Из кода видно, что есть несколько путей получения флага: 1. **Узнать запрашиваемую фразу**; 2. **Самостоятельно вычислить флаг**.

##### Cпособ №1

Чтобы получить запрашиваемую фразу надо: 1. Взять константу `SECRET`; 2. Декодировать из кодировки base64; 3. Последовательно ксорить каждый байт строки пункта 2 с числом 1337.

```
import base64

sec = "1Y/VnNWL1IrVptWK1Y3Vi9SJ1ZfVntWm1YnVkdWL1ZjVitSY"
for i in base64.b64decode(sec).decode():
	print(chr(ord(i) ^ 1337), end='')
# Вывод будет: ver3_str0ng_phras!
```

Дальше просто запустить exe и ввести фразу.

![[Pasted image 20240613152141.png]]

##### Способ №2

Тут все проще: надо взять кусок кода, который печатает флаг и немного изменить.

```
import base64

FLAG="p6ugoaa9n9fc1dWF0ICCgN3c3YDQ09yA1oDX1tHcgNWHhdOFhoCH3dPT0tKGhtOZ"
for i in base64.b64decode(FLAG):
        print(chr(i ^ 228), end='')

# Вывод будет: CODEBY{3811a4dfd989d478d2d3258d1ca7abdc97766bb7}
```

Флаг: `CODEBY{3811a4dfd989d478d2d3258d1ca7abdc97766bb7}`

# 4.0 Заключение

> [!warning] Важное напоминание Нужно помнить и знать, что реверс-инжиниринг может нарушать авторские права и лицензионные соглашения, поэтому **его применение должно быть законным и этичным**. Лучшей практикой будет решение CTF Codeby Games! :)

Реверс-инжиниринг - это не просто анализ программ на одном или двух языках программирования. Это гораздо более глубокий процесс, который включает в себя различные аспекты и особенности анализа.

Для того чтобы набраться опыта в области реверс-инжиниринга, важно постоянно изучать новые технологии и совершенствовать навыки анализа старых. Существует множество способов развития в этой области, но один из наиболее эффективных - решение задач на CTF-площадках.

Кроме того, рекомендуется изучать то, что вам действительно интересно. Не только углубляйтесь в теорию, но и просматривайте райтапы (описания решений) на различные задачи в CTF. Это позволит вам изучить чужой опыт и улучшить навыки в реверс-инжиниринге.

Важно понимать, что реверс-инжиниринг - это постоянно развивающаяся область, и активное изучение новых технологий и выполнение практических заданий поможет сам стать опытнее и увереннее в сфере реверс-инжиниринг.

Будьте настойчивы, терпеливы и постоянно стремитесь к самосовершенствованию в этой увлекательной области!

Больше про реверс-инжиниринг вы можете узнать, например, из [статей с форума Codeby](https://codeby.net/forums/reverse-engineering.189/) или из курсов [Академии Кодебай](https://codeby.school/training)