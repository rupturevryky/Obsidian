***

## HOST DISCOVERY

Хотя Nmap известен именно как [сканер портов](https://spy-soft.net/kportscan-3-0/), это также отличный инструмент для обнаружения машин в сети. Его можно натравить на любое количество хостов и буквально за несколько секунд получить результат пинга тысяч хостов. Вот только пингует хосты он совсем не так, как всем известная утилита ping. По умолчанию перед началом сканирования портов Nmap посылает несколько пакетов, чтобы удостовериться в доступности хоста:

- ICMP Echo request — аналог того, как работает ping;
- SYN-пакет на порт 443;
- ACK-пакет на порт 80;
- ICMP timestamp request.

Так много способов проверки необходимы для обхода брандмауэров и ситуаций, когда, например, в ОС или сетевом оборудовании включен запрет отвечать на запросы ICMP Echo (сегодня это частая практика).

Проверку доступности легко отключить, используя опцию `-Pn`, о чем сам Nmap сообщит, если не сможет удостовериться в доступности порта:
```
sudo nmap -PN 192.168.0.1
```
Обычно в этом мало смысла, а вот обратная операция, то есть отключение сканера портов, очень даже полезна для проверки доступности множества хостов:
```
sudo nmap -sn 192.168.0.1-255
```
или 
```
sudo nmap -sn 192.168.0.*
```
или
``` 
sudo nmap -sn 192.168.0.0/24
```
также можно записать необходимые адреса в файл и попросить просканировать их:
``` 
sudo nmap -sn -iL /путь/до/файла
```
Если опустить флаг `-sn`, **Nmap** будет не просто проверять доступность хостов, но еще и сканировать порты.

Самих техник пингования также довольно много. **Nmap** поддерживает определение доступности хоста с помощью посылки **SYN**-пакета на указанный порт:
```
sudo nmap -sn -PS80 192.168.0.1
```
ACK-пакета:
```
sudo nmap -sn -PA80 192.168.0.1
```
UDP-пакета:
```
sudo nmap -sn -PU53 192.168.0.1
```
ICMP Echo request:
```
sudo nmap -sn -PE 192.168.0.1
```
ICMP timestamp:
```
sudo nmap -sn -PP 192.168.0.1
```
**Все их можно комбинировать:**
```
sudo nmap -sn -PE -PS443 -PA80 -PP 192.168.0.1
```

здесь указываются те функции, которые возможны для обнаружения хостов в сети.
![[HOST_DISCOVERY.png]]
![[Сканирование сети - основа#Типы сканирований и протоколы]]

---

### Nmap: скрытое сканирование хостов

Увеличение задержки между пробами портов — не единственный способ скрыть, что машина сканируется. Еще один интересный метод — одновременно запустить несколько потоков сканирования, подменяя обратный **IP**-адрес во всех случаях, кроме одного.

Смысл здесь в том, чтобы запутать **IDS** и администратора машины. В логах **IDS** окажется сразу несколько попыток сканирования с разных адресов, среди которых будет только один настоящий.

Использовать такой метод довольно просто:
```
sudo nmap -D адрес1,адрес2,адрес3 192.168.0.1
```
Вы можете указать сколько угодно фиктивных адресов или позволить Nmap сгeнерировать рандомные адреса за вас (в данном случае десять адреcов):
```
sudo nmap -D RND:10 192.168.0.1
```
Однако тут необходимо иметь в виду, что случайные адреса часто будут указывать на нeсуществующие или отключенные машины. **IDS** и хороший админ смогут отсеять их, чтобы вычислить реальный адрес.

Более сложный способ — организовать так называемое **Idle**-сканирование. Это очень интересная техника, которая базируется на трех простых фактах:

- При выполнении **SYN**-сканирования удаленная сторона посылает пакет **SYN**/**ACK** в случае, если порт открыт, и пакет **RST**, если нет.
- Машина, получившая не запрошенный пакет **SYN**/**ACK**, должна отвечать пакетом **RST**, а при получении не запрошенного **RST** — игнорировать его.
- Каждый **IP**-пакет, отправленный машиной, имеет **IPID**, а многие ОС при отправке пакета просто увеличивают **IPID**.

Сама техника заключается в том, чтобы найти неактивную сетевую машину, которая просто ничего не делает (**Idle**), но при этом находится в рабочем состоянии и способна отвечать на сетевые запросы. Более того, машина должна работать на древней ОС, которая увеличивает **IPID** пакетов вместо рандомизации, как современные ОС.

Сделать это можно с помощью все тех же флагов `-O` `-v` **Nmap** (строка **IP ID Sequence Generation** в выводе) либо с помощью **Metasploit Framework** (это удобнее и быстрее):
```
> use auxiliary/scanner/ip/ipidseq
> set RHOSTS 192.168.0.1-192.168.0.255
> run
```
Далее вы запускаете [сканирование портов](https://spy-soft.net/skanirovanie-portov/):
```
sudo nmap -sI IP-Idle-машины 192.168.0.1
```
На каждую пробу порта **Nmap** сначала будет посылать запрос **Idle**-машине, записывать **IPID** пакета, затем посылать **SYN**-пакет жертве, подменяя обратный адрес на **IP Idle**-машины, затем снова посылать запрос **Idle**-машине и сверять **IPID** с ранее сохраненным. Если **IPID** увеличился со времени прошлой проверки, значит, машина посылала пакеты, а, как мы знаем из второго пункта выше, это означает, что она ответила пакeтом **RST**. Это, в свою очередь, говорит, что проверяемый порт жертвы открыт. Если **IPID** не увеличился, значит, порт закрыт.

В современном мире, где уже не осталось **Windows 95**, это действительно сложно реализуемая техника, но она позволяет полностью отвести от себя подозрения о сканировании. **IDS** обвинит в сканировании **Idle**-машину.

---

## SCAN TECHNIQUES
![[SCAN_TECHNIQUES.png]]
>#### **TCP Scan с использованием системного вызова connect (-sT)**
> [[#TCP-сканирование]].
> [[#Full Connect Scan]].
> [[#Stealth Scan]].
Например, стандартным типом является закрытие с соединением:
>- `sT` – это то самое сканирование, при котором соединение будет полностью открыто и закрыто валидным способом, как в ОС и задумывалось.

>#### **UDP Scan (-sU)**
Сканирование с помощь протокола **UDP**.
**Но имейте ввиду UDP протокол может достаточно быстро убить соединения - в нем нет контроля соединения.**

>#### **FIN Scan (-sF)**
**FIN Scan** – это, по сути, тоже Self сканирование, которое использует концепцию полуоткрытых портов. Оно не создает соединение как таковое, оно просто отправляет те запросы, которые содержат флаг **FIN**.
>- **Напоминалка про FIN**:
    >**FIN** - флаг, будучи установлен, указывает на завершение соединения

>#### **XMAS Scan (-sX)**
>[[#Xmas Scan]].
**XMAS Scan** – оно переключает каждый запрос новым флагом или, в зависимости от того, что у него сейчас генерируется, включается и флаг.
Другими словами суть в том, чтобы отправлять пакеты сразу с несколькими флагами.
>- устанавливаются **FIN**, **PSH** и **URG** флаги.

---

### Cканирование портов

**Сканирование** — это набор процедур, позволяющих идентифицировать узлы, порты и сервисы целевой системы. Сканирование сети позволяет злоумышленнику собрать профиль атакуемой машины.

Согласно руководству по этичному хаккингу (**Ethical Hacking and Countermeasures EC-Council**) различаются следующие типы сканирования:

- сетевое сканирование — определение находящихся в сети узлов;
- сканирование портов — выявление открытых портов и функционирующих сервисов;
- сканирование безопасности системы — выявление известных уязвимостей системы.

На первый взгляд в сканировании никакого вреда нет, тем не менее с таким подходом трудно согласиться, ведь сканирование предваряет атаку, позволяя злоумышленнику выяснить, какие сервисы работают в целевой системе, а значит, подготовить и провести целенаправленную атаку против выявленных сервисов и их уязвимостей. Следовательно, бороться с разведкой злоумышленников необходимо.

При этом будет нелишним отметить, что само по себе сканирование не всегда злонамеренное действие, все зависит от его целей. Службы информационной безопасности или сотрудники ИТ вполне могут прибегнуть к сканированию для выяснения уязвимостей инфраструктуры или видимости сервисов из внешней сети.

В сущности, нередко все как раз и начинается с сетевого сканирования, именно оно позволяет выявить слабые узлы их **IP**-адреса, открытые порты, определить операционную систему, а значит, становятся понятны теоретически возможные уязвимости, что уже не так мало для организатора атаки.

---

### Методы сканирования портов

Выявляем структуру сети. Самый простой способ сканирования — **ICMP scanning**. Принцип работы основан на протоколе **ICMP**, и такой тип сканирования позволяет выяснить «живые» узлы в сети и построить схему сети с перечнем ее узлов. Суть метода заключается в отправке **ICMP**-запросов узлам сети, если компьютер или иное устройство, работающее со стеком протоколов **TCP/IP**, активно, то будет отправлен ответ. Это так называемый **ping sweep** или **ICMP sweep**. Существует огромное количество средств, позволяющих выполнить подобное сканирование.

Следующий этап разведки — выявление открытых портов. По сути своей, это дает возможность определить, какие сервисы работают на удаленном узле, список которых мы уже получили в результате предыдущего сканирования. Кроме того, из анализа полученных пакетов можно также выявить операционную систему и ряд других важных параметров (наличие фильтра пакетов, например).

---

#### TCP-сканирование

Здесь мы говорим о **TCP-сканировании**. Его принцип основан на особенностях работы **TCP**. В сущности, очень похожий механизм взаимодействия принят в авиации при переговорах пилотов с диспетчером, включающий запрос, ответ с указанием, подтверждение полученной инструкции. Такой способ взаимодействия если и не исключает полностью вероятность непонимания, то по крайней мере существенно снижает такую вероятность. Используется схема **three-way-handshake** или «**трехэтапного**» согласования, встречается также термин «**трехэтапное квитирование**», которое позволяет синхронизировать передающий и получающий узлы и установить сессию, что, в сущности, идентично примеру с радиопереговорами.

Используя этот легальный алгоритм, злоумышленник может выяснить, какие порты открыты на сервере, то есть понять, какие сервисы используются в системе, какая операционная система. Для этого существует несколько эффективных методик.

---

#### Full Connect Scan

Самый эффективный и несложный способ сканирования — **Full Connect Scan** (**Full Open Scan**). Происходит попытка выполнить трехэтапное согласование (**three-way-handshake**) с интересующими исследователя узлами. Если искомый порт открыт, то мы получаем от него сообщение **SYN+ACK**, после этого посылаем узлу **RST** (сброс сессии), если закрыт, то нам приходит **RST** от проверяемого узла. Надо отметить, что такой способ сканирования легко идентифицируется, стало быть, противостоять ему несложно.

---

#### Stealth Scan

Другой способ сканирования сети называется **Stealth Scan** (**Half-open Scan**). В этом случае атакующий старается обойти защиту брандмауэра и замаскироваться под обычный сетевой трафик с тем, чтобы избежать фиксации события сканирования в логах системы. Здесь речь не идет о согласовании, исследователь просто отправляет **SYN**-пакет на интересующий порт требуемого сервера. Если в ответ приходит **SYN+ACK**, то порт открыт, если **RST**, то порт закрыт.

Такой способ сканирования более изощренный, однако современные системы предотвращения вторжений должны уметь ему противостоять.

---

#### Xmas Scan

Не менее известные методы сканирования — **Xmas Scan** и **Null Scan**, однако мы не будем их рассматривать ввиду того, что защита от них реализована в рамках современных операционных систем **Microsoft**, поэтому они не будут представлять для нас большого интереса. Особенность этих типов сканирования — стелс режим работы, то есть без установки сессии. Впрочем, посмотреть детали можно в курсе **Ethical Hacking** или в книге «**Network Security Test Lab**». Эти типы сканирования эффективны только для операционных систем, где **TCP**-стек работает на основе **RFC 793**. Все современные операционные системы от **Windows Vista** и старше не подвержены этому риску.

---

#### Idle Scan

Пожалуй, наиболее интересным способом сканирования является **Idle Scan**. Основная идея заключается в том, что злоумышленник может просканировать жертву, не показывая ей своего **IP**-адреса, то есть с точки зрения сканируемого узла злоумышленник с ней как бы и не общается. Используется «подставной» узел, который и может быть определен системами противодействия вторжениям в качестве источника атаки. Это весьма разумная методика, так называемый спуфинг, когда адрес отправителя подменяется на адрес другого устройства. Надо сказать, что «подставным» узлом или «зомби» может стать компьютер, который обладает определенными уязвимостями. Операционные системы, как правило, должны быть обновлены, однако это не всегда так, и атакующий всегда может найти «помощников», кроме того, в качестве «зомби» может быть использован сетевой принтер или другое сетевое устройство, которое работает с базовой функциональностью стека **TCP/IP**.

Это сканирование использует поле **Identification** в **IP**-заголовке **(IPID**). Значение **IPID** увеличивается на единицу в каждом следующем пакете, который отправляет узел. В сущности, это и есть уязвимость, поскольку появляется возможность предсказать, какое количество пакетов было передано между двумя пакетами, которые были получены. Современные операционные системы используют случайное значение для поля **IPID**, однако, как уже было упомянуто выше, всегда можно найти решение. Для современных **Unix** и **Windows** систем от **Windows Vista** и старше эта проблема уже потеряла свою актуальность.

Рассмотрим рисунки. На первом шаге (1) атакующий обращается к подставному устройству со стандартным **SYN**-пакетом. Устройство отвечает пакетом **SYN ACK** (2) или **SYN RST**, что более вероятно, однако из заголовка пакета атакующему становится виден **IPID**. Его-то и надо запомнить (3). Далее атакующий обращается к интересующему его серверу (4), при этом подменяет свой **IP**-адрес на адрес подставного узла, то есть маскируется, используя спуфинг (подмену адресов). В ответ на этот запрос сервер, если порт открыт, посылает **SYN/ACK** на подставной адрес (5). Мы ведь выполнили подмену. Не зная, что делать с этим пакетом, подставной компьютер в ответ пошлет **RST** (сброс сессии), при этом увеличит значение своего **IPID**. В нашем случае он станет равным 30132 (6). Если порт закрыт, то сервер пошлет сброс сессии (**RST**) — смотрите рисунок 5 (5).
![[Pasted image 20240630092157.png]]![[Pasted image 20240630092204.png]]
**IPID** подставного узла остался неизменным, в нашем случае **30131**, поскольку «зомби» никому больше ничего не отправлял. Теперь останется еще раз обратиться к «зомби», как мы это уже делали выше, выявить его **IPID**, сравнить его с имеющимся у нас значением. Если **IPID** увеличился на 2, то порт открыт.

Еще один важный момент, который хотелось бы отметить, — операционные системы имеют свою специфику при работе со стеком **TCP/IP**. Используя эти особенности при анализе пакетов, полученных при сканировании, вполне возможно выяснить, с какой ОС мы имеем дело, на этих принципах построены методики сканирования **Banner Grabbing**. Задача — выявить информацию о вычислительной системе и ее уязвимостях, что позволит атакующему использовать эти знания для своих последующих деструктивных действий. Любой современный сканер предоставит атакующему эту информацию.

`[box type=»note» align=»» class=»» width=»»]`Операционные системы, как правило, должны быть обновлены, однако это не всегда так, и атакующий может найти «помощников», кроме того, в качестве «зомби» может быть использован сетевой принтер или другое сетевое устройство, которое работает с базовой функциональностью стека **TCP/IP**.

Нетрудно заметить, что все рассмотренные способы сканирования базируются на штатном поведении узлов, а значит, любой компьютер или иное сетевое устройство является потенциально уязвимым.

Злоумышленник обладает возможностью сбора и анализа полученной информации о структуре сети, сервисах, уязвимостях систем. Тем самым предоставляется потенциальная возможность подготовить целевую атаку против определенных узлов и сервисов.

--- 

## Скрипты в nmap (-sC)

существует несколько способов запуска скриптов:

1. Cпособо который запускает **дефолтные скрипты** - в nmap есть такое понятие как дефолтные скрипты - это отдельная категория скриптов которые запускаются одной командой и их не надо вводить каждый лично и отдельно запускать.
    
2. Второй способ - запуск **конкретного скрипта**, скрипты которые устанавливаются вместе с nmap по умолчанию лежат в папке: `usr/share/nmap/scripts`
    
    ![[Список скриптов nmap.png]]
    
    Тут можно посмотреть перечь скриптов, пополнить их кастомными из опенсурса, открыть их на редактирование в случае необходимости (некоторые скрипты отрабатывают в ошибкой и их приходится допиливать, большая часть скриптов которые тут есть, пишется комьюнити nmap, очень мало скриптов написано разработчиками).
    
    Более подробно про скрипты можете почитать **[тут](https://networkguru.ru/nmap-scripting-engine-rukovodstvo/)** и **[тут](https://xakep.ru/2016/02/25/pimp-my-nmap/)**

---

### Сканер уязвимостей из Nmap с помощью Vulscan

Проект **vulscan** — это NSE-скрипт, который превратит ваш **Nmap** в сканер уязвимостей. В комплекте со скриптом идет несколько баз уязвимостей.

Установка проста — просто клонируйте репу в `/scripts` (для **Nmap** из macOS, например, это будет `/usr/local/Cellar/nmap/7.60/share/nmap/scripts`) и запускайте, передав в аргументе NSE-скрипт:
```
nmap -sV --script=vulscan/vulscan.nse target.com
```
Разработчик: scip AG. Скачать Vulscan вы сможете со страницы на [GitHub](https://github.com/scipag/vulscan "GitHub")

Пользуясь случаем, не могу не респектануть дружественному [Vulners](https://spy-soft.net/skaner-uyazvimostej-linux/), решающему схожую задачу: у парней есть плагин для Burp, а также расширение для Chrome, которое во время серфинга анализирует заголовки серверов, сверяет по своей базе и, если видит уязвимый софт, репортит вам об этом. Удобно!

---

## Обход фаервола и IDS в Nmap

Начнем с того, что даже без дополнительных опций **Nmap** уже способен хоть и не обойти, но обнаружить брандмауэр. Происходит так потому, что при **SYN**-сканиpовании состояние открыт/закрыт определяется путем анализа ответа машины: **SYN**/**ACK** — открыт, **FIN** — закрыт.

Однако брандмауэры, чтобы минимизировать процессорные ресурсы, зачастую просто дропают пакеты, адресуемые фильтруемым портам (даже при настройке **iptables** в **Linux** стандартная практика — это дропнуть пакет с помощью **-j DROP**). **Nmap** отслеживает, при пробе каких портов не было получено ответа, и помечает эти порты **filtered**.

Еще одна техника обнаружения брандмауэра заключается в том, чтобы заставить **Nmap** генерировать «невероятные пакеты», такие как пакеты без единого флага (**-sN**), **FIN**-пакеты (**-sF**) и **Xmas**-пакеты, содержащие флаги **FIN**, **PSH** и **URG** (**-sX**). **RFC** описывает все эти ситуации, поэтому любое расхождение с **RFC Nmap** интерпретирует как наличие брандмауэра.

Многие брандмауэры можно обойти и точно определить, фильтруется порт или нет. Для этого можно использовать **ACK**-сканирование:
```
sudo nmap -sA 192.168.0.1
```
Теория здесь следующая: брандмауэр должен отбивать все новые **TCP**-подключения к порту, но также обязан не препятствовать прохождению пакетов в рамках уже установленных соединений. Простой способ сделать это — отбивать все **SYN**-пакеты (используется для установки соединения), но не мешать **ACK**-пакетам (используется для отправки пакетов в рамках уже открытого соединения).

Но есть одна тонкость. Дело в том, что есть так называемые **stateful**-брандмауэры. Они умеют отслеживать состояние соединения и проверяют такие поля пакетов, как **IP**-адрес и номер последовательности **TCP**, чтобы отслеживать, какие пакеты действительно пришли в рамках открытого ранее соединения, а какие были отправлены **Nmap** в рамках **ACK**-сканирования (**iptables** в **Linux** может работать в обоих режимах, но по умолчанию он не **stateful**, это более производительный вариант).

Выяснить, какой тип брандмауэра используется, можно, выполнив **SYN**-сканирование и сразу за ним — **ACK**-сканирование:
```
sudo nmap -sS 192.168.0.1
sudo nmap -sA 192.168.0.1
```
Если во втором случае порты, отмеченные во время **SYN**-сканирования как **filtered**, стали **unfiltered**, значит, перед тобой не **stateful**-брандмауэр.

Кроме того, можно попробовать обойти фаервол с помощью изменения номера исходящего порта:
```
sudo nmap --source-port 53 192.168.0.1
```
Это эксплуатация старой как мир ошибки настройки брандмауэра, которая заключается в том, что админ открывает доступ всему входящему трафику (включая протокол **TCP**) с порта **53**, чтобы позволить приложениям беспрепятственно выполнять **DNS**-запросы. Сегодня такое встречается редко, но, как показывает практика, некомпетентность со временем не исчезает.

Кроме всего прочего, в **Nmap** есть **средства для скрытия факта сканирования** от глаз фаерволов и **IDS**:
```
sudo nmap -f 192.168.0.1
```
В этом случае Nmap будет разбивать пакеты на крохотные фрагменты размером 8 байт. Делает он это в надежде на то, что брандмауэр или **IDS** не сможет собрать пакет из фрагментов и проанализировать его заголовок (по причине плохой реализации или в угоду производительности) и просто пропустит пакет или отбросит.
```
sudo nmap --mtu 16 192.168.0.1
```
Та же история, только с возможностью контролировать размер пакета (в данном случае 16). Можно использовать против брандмауэров и **IDS**, которые умеют ловить факты сканирования с помощью **Nmap**, анализируя размер фрагмента.
```
sudo nmap --data-length 25 192.168.0.1
```
Добавляет в конец пакета указанное количество случайных байтов. Цель та же, что и в предыдущем случае: обмануть **IDS**, которая может быть способна обнаружить [сканирование портов](https://spy-soft.net/skanirovanie-portov/), анализируя размер пакета (**Nmap** всегда посылает пакеты длиной 40 байт при использовании протокола **TCP**).

---

## Полезные команды / примеры использования

---

**`––data-length <число>`** - добавить произвольные данные к посылаемым пакетам.
<details style="padding:10px">
    <summary style="cursor: pointer">Подробней</summary>
    
        В обычных условиях nmap посылает минимальные пакеты, содержащие только заголовок. Так, TCP пакеты составляют 40 байтов, а запросы на ICMP эхо-ответ — всего 28. Эта опция указывает nmap добавлять заданное число произвольных байтов к большинству посылаемых пакетов. Эта опция не влияет на пакеты, используемые для определения ОС (-O)
</details>

***
**Сканирование нескольких IP-адресов можно выполнить так:**

`nmap 192.168.0.1 192.168.0.2 192.168.0.3`

или так:

`nmap 192.168.0.1-20`

---

**Для сканирования всей подсети можно использовать такую команду:**

`nmap 192.168.0.*`

или так:

`nmap 192.168.0.0/24`

---

**При сканировании сетей можно пропускать некоторые IP-адреса:**

`nmap 192.168.0.0/24 --exclude 192.168.0.5,192.168.0.7,192.168.0.254`

---

**Список хостов для сканирование можно взять из файла (допустим, /tmp/testip.txt):**

`nmap -iL /tmp/testip.txt`

---

**Также из файла можно взять список исключений (допустим, /tmp/excludeip.txt):**

`nmap -iL /tmp/testip.txt --excludefile /tmp/excludeip.txt`

***

Определить ОС, установленную на хосте можно с помощью опции `-O`:

```
nmap -O 192.168.0.12
...
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.11 - 3.14
Network Distance: 1 hop
...
```
***
Узнать версии запущенных сервисов на хосте можно используя опцию `-sV`:
```
nmap -sV 192.168.0.13

Starting Nmap 6.47 ( http://nmap.org ) at 2016-10-13 09:58 EEST
Nmap scan report for mars (192.168.0.13)
Host is up (0.0000070s latency).
Not shown: 985 closed ports
PORT     STATE SERVICE         VERSION
22/tcp   open  ssh             OpenSSH 6.7p1 Debian 5+deb8u2 (protocol 2.0)
80/tcp   open  http            Apache httpd 2.4.10 ((Debian))
139/tcp  open  netbios-ssn     Samba smbd 3.X (workgroup: MARS)
445/tcp  open  netbios-ssn     Samba smbd 3.X (workgroup: MARS)
3306/tcp open  mysql           MySQL 5.5.49-0+deb8u1-log
...
```
***
**Осуществить быстрое сканирование:**

`nmap -F 192.168.0.1`

---

**Показать открытые порты на сканируемом узле:**

`nmap --open 192.168.0.1`

---

**Отобразить отправленные/полученные пакеты:**

`nmap --packet-trace 192.168.0.1`

---
Вывести сетевые интерфейсы и маршруты хоста, с которого выполняется сканирование (весьма полезно для отладки):
```
nmap --iflist

Starting Nmap 6.47 ( http://nmap.org ) at 2016-10-13 10:04 EEST
************************INTERFACES************************
DEV      (SHORT)    IP/MASK                     TYPE     UP   MTU   MAC
eth0.101 (eth0.101) 192.168.2.13/24             ethernet up   1500  00:0C:29:8A:AC:3E
eth0.101 (eth0.101) fe80::20c:29ff:fe8a:ac3e/64 ethernet up   1500  00:0C:29:8A:AC:3E
eth0     (eth0)     192.168.0.13/23             ethernet up   1500  00:0C:29:8A:AC:3E
eth0     (eth0)     fe80::20c:29ff:fe8a:ac3e/64 ethernet up   1500  00:0C:29:8A:AC:3E
eth1     (eth1)     (none)/0                    ethernet down 1500  00:0C:29:8A:AC:48
lo       (lo)       127.0.0.1/8                 loopback up   65536
lo       (lo)       ::1/128                     loopback up   65536

**************************ROUTES**************************
DST/MASK                     DEV      METRIC GATEWAY
192.168.2.0/24               eth0.101 0
192.168.0.0/23               eth0     0
0.0.0.0/0                    eth0     0      192.168.0.15
::1/128                      lo       0
fe80::20c:29ff:fe8a:ac3e/128 lo       0
fe80::20c:29ff:fe8a:ac3e/128 lo       0
ff02::1/128                  eth0     0
::1/128                      lo       256
fe80::/64                    eth0     256
fe80::/64                    eth0.101 256
ff00::/8                     eth0     256
ff00::/8                     eth0.101 256
```
---
**Выполнить сканирование определенно порта можно несколькими способами, например так:**

```
nmap -p 80 192.168.0.1

Starting Nmap 6.47 ( <http://nmap.org> ) at 2016-10-13 10:07 EEST
Nmap scan report for astra (192.168.0.1)
Host is up (0.00028s latency).
PORT   STATE SERVICE
80/tcp open  http
MAC Address: E8:40:F2:3B:CB:98 (Pegatron)

Nmap done: 1 IP address (1 host up) scanned in 0.63 seconds
```

или так:
`nmap -p T:80 192.168.0.1`

---
**Можно также указывать для сканирование несколько портов через запятую:**

`nmap -p 80,443 192.168.0.1`

или задавать диапазон портов:

`nmap -p 80-200 192.168.0.1`

---
**Топ 5 портов можно увидеть так:**

```
nmap --top-ports 5 192.168.0.1

Starting Nmap 6.47 ( <http://nmap.org> ) at 2016-10-13 10:18 EEST
Nmap scan report for astra (192.168.0.1)
Host is up (0.00022s latency).
PORT    STATE  SERVICE
21/tcp  closed ftp
22/tcp  open   ssh
23/tcp  closed telnet
80/tcp  open   http
443/tcp open   https
MAC Address: E8:40:F2:3B:CB:98 (Pegatron)

Nmap done: 1 IP address (1 host up) scanned in 1.63 seconds
```

---

**Выполнить сканирование узла используя TCP ACK (PA) и TCP Syn (PS):**

`nmap -PS 192.168.0.1`

`nmap -p 80,443 -PS 192.168.0.1`

`nmap -PA 192.168.0.1`

`nmap -PA 80,200-400 192.168.0.1`

---

**Сканировать хост с использованием IP ping:**

`nmap -PO 192.168.0.1`

---

**Сканировать хост с использованием UDP ping:**

`nmap -PU 192.168.0.1`