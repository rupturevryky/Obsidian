## **API**

**API (Application Programming Interface)** - это набор программных инструкций и структур данных, которые определяют взаимодействие между различными программами или компонентами программного обеспечения. Оно определяет способы и правила, с помощью которых одно приложение может взаимодействовать с другим для обмена данными и выполнения определенных функций.

API позволяет разработчикам создавать приложения, которые могут использовать функциональность и данные других приложений, сервисов или операционных систем. Он служит связующим звеном между различными компонентами программного обеспечения, позволяя им взаимодействовать и обмениваться информацией.

Существуют разные типы API. Например, веб-API (или HTTP API) обычно используется для взаимодействия веб-сервисов через сеть Интернет или для взаимодействия клиента и сервера.

---
# **WEB API**

**Web API (или HTTP API)** - это тип API, который предоставляет программный интерфейс для взаимодействия с веб-серверами с помощью протокола HTTP. Он позволяет клиентским приложениям отправлять запросы на сервер и получать ответы, обычно в формате JSON или XML, содержащие данные или результаты операций.

Грубо говоря, без Web API ваш браузер не смог бы обащаться с сервером!

Существует большое количество видов API, но самые популярные среди них следующие: REST API, SOAP API, RPC API и GraphQL API. Давайте ознакомимся с первыми тремя, чтобы лучше понять разницу между ними и GraphQL.

---
## **REST API**

**REST** – это **Representational State Transfer**, т. е. передача репрезентативного состояния. REST определяет набор функций, таких как GET, PUT, DELETE и т. д., которые клиенты могут использовать для доступа к **данным** сервера. Клиенты и серверы обмениваются данными по протоколу HTTP.

Для лучшего понимания, что это, давайте посмотрим на swagger REST API приложения:

**Swagger (также известный как OpenAPI)** - это набор инструментов для проектирования, создания, документирования и потребления веб-сервисов и API. Он предоставляет стандартизированный и удобочитаемый способ описания RESTful API и других типов веб-сервисов.

По сути это своеобразная инструкция от веб-приложения, в которой можно посмотреть какие эндпоинты у приложения есть, какие параметры они принимают и какие HTTP методы нужно использовать.

Пример swagger’а: ![[Pasted image 20240614200341.png]]
Обращения к конкретному эндпоинту(как называется эндпоинт, какие параметры принимает, какой тип данных принимает, и что возвращает):![[Pasted image 20240614200357.png]]
В сваггере мы видим, что существует группа энпоинтов, начинающийхся с `/user/`. В REST API нужно думать о приложении с точки зрения ресурсов, к которым мы обращаемся. Например, с помощью метода GET по маршруту `/user/ArroizX` можно получить всю информацию о пользователе ArroizX. То есть, мы обращаемся к объекту user, дальше к конкретному его ресурсу ArroizX и получаем информацию. Используя тот же маршрут, но другие HTTP методы мы можем удалить данного пользователя (DELETE), обновить данные пользователя (PUT) и тд.

То есть, в REST API мы обращаемся к каким-либо сущностям/объектам, дальше используем какой-нибудь идентификатор(тот же ник пользователя) и с помощью http методов выполняем те или иные функции.

Естественно, у REST API есть и другие особенности, я их разбирать не буду, если хотите о них узнать, то гугл вам в помощь!

---
## **SOAP API**

**SOAP** — это **протокол**, по которому веб-сервисы взаимодействуют друг с другом или с клиентами. Название происходит от сокращения **Simple Object Access Protocol** («простой протокол доступа к объектам»).

**SOAP API** — это веб-сервис, использующий протокол SOAP для обмена сообщениями между серверами и клиентами. При этом сообщения должны быть написаны на языке XML в соответствии со строгими стандартами, иначе сервер вернет ошибку.

SOAP может использоваться с протоколами SMTP, FTP, HTTP, HTTPS. Чаще всего — с HTTP как с наиболее универсальным: его поддерживают все браузеры и серверы. Корректное SOAP-сообщение состоит из нескольких структурных элементов: Envelope, Header, Body и Fault.

1. **Envelope («конверт»)**. Это корневой элемент. Определяет XML-документ как сообщение SOAP с помощью пространства имен `xmlns_soap="<http://www.w3.org/2003/05/soap-envelope/>"`. Если в определении будет указан другой адрес, сервер вернет ошибку.
2. **Header («заголовок»)**. Включает в себя атрибуты сообщения, связанные с конкретным приложением (аутентификация, проведение платежей и так далее). В заголовке могут использоваться три атрибута, которые указывают, как принимающая сторона должна обрабатывать сообщение, — mustUnderstand, actor и encodingStyle. Значение mustUnderstand — 1 или 0 — говорит принимающему приложению о том, следует ли распознавать заголовок в обязательном или опциональном порядке. Атрибут actor задает конкретную конечную точку для сообщения. Атрибут encodingStyle устанавливает специфическую кодировку для элемента. По умолчанию SOAP-сообщение не имеет определенной кодировки.
3. **Body («тело»)**. Сообщение, которое передает веб-приложение. Может содержать запрос к серверу или ответ от него. Пример сообщения, которое запрашивает стоимость ноутбука в онлайн-магазине:

```
<?xml version="1.0"?>
<soap:Envelope xmlns_soap="<http://www.w3.org/2003/05/soap-envelope/>" soap_encodingStyle="<http://www.w3.org/2003/05/soap-encoding>">
    <soap:Body>
        <m:GetPrice xmlns_m="<https://online-shop.ru/prices>">
            <m:Item>Dell Vostro 3515-5371</m:Item>
        </m:GetPrice>
    </soap:Body>
</soap:Envelope>

```
4. **Fault («ошибка»)**. Опциональный элемент. Передает уведомление об ошибках, если они возникли в ходе обработки сообщения. Может содержать вложенные элементы, которые проясняют причину возникновения ошибки.

Главное помните, что SOAP — протокол, а REST — архитектурный стиль, набор правил по написанию кода.

Пример SOAP API запроса и ответа сервера:![[Pasted image 20240614200520.png]]
Хоть Soap и выглядит, как что-то древнее, но он до сих пор используется, например, в веб-приложениях Microsoft(microsoft exchange) и на некоторых серверах банковских приложений.

---
## **RPC API**

**Удаленный вызов процедур (RPC)** — это одна из простейших парадигм API, в которой клиент вызывает исполнение блока кода на сервере. В то время как REST рассматривает всё как ресурсы, RPC рассматривает действия. Клиенты обычно передают имя метода и аргументы серверу и получают обратно JSON или XML.

RPC и REST – два **архитектурных стиля** проектирования API. RPC API позволяют разработчикам вызывать удаленные функции на внешних серверах, как если бы они были локальными для своего программного обеспечения. Например, вы можете добавить функцию чата в свое приложение, удаленно вызывая функции обмена сообщениями в другом приложении чата. Напротив, REST API позволяют выполнять определенные операции с данными на удаленном сервере. Например, приложение может добавлять или изменять данные сотрудников на удаленном сервере с помощью REST API.

При удаленном вызове процедур (RPC) клиент использует команду POST по протоколу HTTP для вызова определенной функции по ее имени. Для работы RPC разработчикам на стороне клиента необходимо заранее знать имя и параметры функции.

Также RPC обычно используется для вызова удаленных функций на сервере, требующих результата действия. Этот сервис можно использовать, когда требуются сложные вычисления или вы хотите запустить удаленную процедуру на сервере, скрыв процесс от клиента.

Хотя REST веб-API сегодня считаются нормой, вызов удаленных процедур (RPC) никуда не исчез. REST API чаще всего используется в приложениях, поскольку разработчикам проще понять и внедрить его. Однако RPC все еще существует и используется, когда больше подходит для конкретного случая.(Например он используется на озоне:) )

Как выглядят одни и те же запросы в RPC API и REST API:
![[Pasted image 20240614200619.png]]

---
## **GraphQL**

**GraphQL** — язык запросов для API, призванный обеспечить более эффективную, мощную и гибкую альтернативу REST. В его основе лежит декларативная выборка данных, то есть клиент может точно указать, какие именно данные ему нужны от API. Вместо нескольких конечных точек API (REST) GraphQL представляет единую конечную точку, которая предоставляет клиенту запрашиваемые данные.

Начнём немного с истории:

**GraphQL** был разработан как внутренний проект компании Facebook в 2012 году, а позднее в 2015 году был выпущен публично.

И сразу же встаёт вопрос: а зачем он был разработан?

И правда, учитывая все продукты компании Meta(запрещённая в РФ организация, я хз надо ли писать, но лучше напишу =) ), то в них нужно обращаться к конкретным ресурсам: люди их данные, группы, посты, лайки и тд. Для этого всего идеально подходит REST API. И кажется уже, что GraphQL уже на этапе создания не нужен, но тут есть одно жирное **НО**.

Как мы помним, в REST API мы обращаемся к определённым ресурсам. Допустим `GET /user/ArroizX HTTP/1.1` возвращает нам такие поля как: `username`, `name`, `age`, `interests`, `image`, `description`, `job`, `study`, и пр. Иногда бывают ситуации, когда нам не нужно столько полей(краткое превью пользователя), и из-за этого нам нужно будет делать отдельный эндпоинт. Или, например, нам нужно получить информацию о нескольких пользователях. В этом случае нам придётся либо делать несколько HTTP-запросов, что неудобно, либо делать отдельный эндпоинт `users`, и там передавать такие параметры как `from` - `to`. В таком случае это уже какой-то полу Rest API.

Также стоит упомянуть, что у Meta(… , запрещённая в РФ организация), веб-приложения - одностраничники (SPA, single page application), т.е. веб-приложение или веб-сайт, использующий единственный HTML-документ как оболочку для всех веб-страниц и организующий взаимодействие с пользователем через динамически подгружаемые HTML, CSS, JavaScript, обычно посредством AJAX. Соответственно, нужно не нагружать запросами и так бедные сервера, которые постоянно гоняют большое количество трафика.

Мы получаем следующие достоинства GraphQL:

1. Так как все запросы в SPA приложениях делает JS, то желательно, чтобы была одна конкретная конечная точка, куда их отправлять, что как раз есть в GraphQL. То есть не нужно захламлять код разными эндпоинтами по типу `/user`, `/group` и т.д. Достаточно теперь 1 раз указать в какой-нибудь переменной ссылку на эндпоинт и её использовать везде, где нужно отправлять запросы.
2. С GraphQL можно делать **точные** запросы. Если я хочу получить только имя пользователя и ссылку на его фото, то я получу только их, а не ещё кучу других данных вместе с ними. Таким образом значительно уменьшается количество трафика. Однако в GraphQL нельзя запросить сразу все поля, не зная их названия.
3. Также стоит упомянуть следующее: иногда данные могут валяться в разных местах(БД Mysql, другой HTTP сервер и др. источники). И если REST API никак не говорит о том, как получать к ним доступ, это оставлено на выбор разработчику, то в GraphQL есть такая вещь как резолверы. Когда клиент отправляет GraphQL-запрос, который запрашивает определенные поля объекта, сервер должен определить, откуда и как получить данные для каждого из этих полей. Именно для этой цели используются резолверы. Резолверы - это функции, которые связывают поля с фактическими данными. Они определены для каждого типа объекта и для каждого поля в этом типе. Когда GraphQL-запрос обрабатывается, сервер вызывает соответствующие резолверы для каждого запрошенного поля, чтобы получить данные.
### **SDL**

Как многие из вас знают, в России принято делать веб-приложения 2мя командами: back и front. И когда приложения делаются таким образом, эти две команды должны понимать, какие данные они принимают, а какие данные отправляют. Для упрощения этого момента создаётся такая документация как тот же swagger. Такая документация называется “контракт на поставку данных”. В GraphQL есть свой контракт на поставку данных - SDL.

**Schema Definition Language (SDL)** — это специальный язык, разработанный для описания структуры и функциональности схемы GraphQL. SDL предоставляет декларативный подход к определению типов данных, запросов, мутаций и отношений между данными в GraphQL API.
![[Pasted image 20240614200925.png]]
В языке SDL разработчики могут определить различные типы данных, их поля, а также способы, которыми клиенты могут запрашивать и взаимодействовать с этими данными. Описывая типы и поля в SDL, разработчики предоставляют точное представление того, какие данные могут быть доступны через GraphQL-схему.

SDL позволяет легко определить связи между типами данных, что упрощает понимание и взаимодействие с данными. Он также обеспечивает прозрачность и предсказуемость взаимодействия между клиентами и сервером, поскольку определенные типы запросов и их структура явно заданы в SDL.

Помимо этого с помощью SDL можно сгенерировать уже готовый код под некоторые ЯП и фреймворки с готовыми резолверами, чтобы не тратить лишнее время:![[Pasted image 20240614201021.png]]
Как мы видим, в SDL описываются различные типы данных в GraphQL, познакомиться  с ними можно в следующем разделе:
