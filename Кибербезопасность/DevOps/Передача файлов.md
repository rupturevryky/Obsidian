### SSH-сервер

---

#### Конфигурация сервера

Вся конфигурация SSH-сервера хранится в файле **`/etc/ssh/sshd_config`**.
![[Pasted image 20240715121408.png]]
1. В первую очередь следует обратить внимание на следующие параметры: `Port`, `AddressFamily`, `ListenAddress`. 
	- **`Port`** глобально задаёт номер порта, через который будет работать соединение и если оставить его стандартным, т. е. `22`, то велика вероятность, что он будет слишком часто сканироваться роботами.
	- **`AddressFamily`** задаёт семейство используемых IP-адресов — **IPv4** и **IPv6**. Если, к примеру, используются только адреса **IPv4**, то очень рекомендуется установить для параметра `AddressFamily` значение `inet`:
	  ```
	  AddressFamily inet 
		```
		Для адресов семейства IPv6 используется значение inet6.
	- **`ListenAddress`** позволяет задавать порты для отдельных сетевых интерфейсов:
	  ```
	  - ListenAddress 10.24.205.75:2123
	  - ListenAddress 10.24.205.76:2124
		```

2. Поскольку реализация openSSH позволяет работать с протоколами SSH1 и SSH2, то разумно отключить использование SSH1, т. к. эта версия является устаревшей. Работа по SSH1 крайне не рекомендуется: Protocol 2

3. Очень полезным является параметр, позволяющий проводить авторизацию и шифрование трафика с помощью специальных SSH-ключей: 
	```
	PubkeyAuthentication yes
	```
	- Следует заметить, что в таком случае серверу необходимо явно указывать, где хранятся открытые ключи пользователей. Это может быть как один общий файл для хранения ключей всех пользователей (обычно это файл `/etc/.ssh/authorized_keys`), так и отдельные для каждого пользователя ключи. Второй вариант предпочтительнее в силу удобства администрирования и повышения безопасности:
	  ```
	  AuthorizedKeysFile etc/ssh/authorized_keys # Для общего файла AuthorizedKeysFile 
		```
		```
		%h/.ssh/authorized_keys # Файл -> пользователь
		```
		- Во втором варианте благодаря шаблону автоподстановки с маской «%h» будет использоваться домашний каталог пользователя.

4. Важно также отключать парольный доступ:
	  ```
	PasswordAuthentication no
	```
	- Или же, в случае, если всё-таки необходимо использовать доступ по паролю, то обязательно нужно отключать авторизацию по пустому паролю:
	  ```
		PermitEmptyPasswords no
		```
5. Для указания разрешённых или запрещённых пользователей и групп служат директивы `DenyUsers`, `AllowUsers`, `DenyGroups`, и `AllowGroups`. Значениями для них являются списки имён, разделяемых пробелами, например:
   ```
   DenyUsers fred john 
   AllowGroups root clients administrators
	```
	- Следует также отключать root-доступ:
	  ```
	  PermitRootLogin no
		```

6. Иногда, когда следует задавать мультисерверную конфигурацию, очень удобно использовать алиасы (Aliases), что позволяет настроить сразу несколько режимов доступа (с разными хостами, портами и т. д.) и использовать их, указывая при этом конкретный алиас: `$ ssh alias_name`.
   
   Настройки для алиасов хранятся либо глобально в `/etc/ssh/ssh_config`, либо раздельно для пользователей в `~/.ssh/config`.
   ```
   Host your_alias 
   Port your_ssh_port 
   HostName 0.0.0.0 # IP или имя хоста 
   User your_user_name
	```

**Для применения сделанных настроек необходим перезапуск SSH-сервера:**
`$ systemctl restart sshd`
**или:**
`$ service ssh restart`

---
#### SSH-authorized_keys

---

##### Введение 

Пары ключей SSH представляют собой два защищенных шифрованием ключа, которые можно использовать для аутентификации клиента на сервере SSH. Каждая пара ключей состоит из открытого ключа и закрытого ключа.

Закрытый ключ хранится клиентом и должен быть абсолютно защищен. Любое нарушение безопасности закрытого ключа позволит злоумышленникам входить на серверы с соответствующим открытым ключом без дополнительной аутентификации. В качестве дополнительной меры предосторожности ключ можно зашифровать на диске с помощью парольной фразы.

Соответствующий открытый ключ можно свободно передавать, не опасаясь негативных последствий. Открытый ключ можно использовать для шифрования сообщений, которые может расшифровать только закрытый ключ. Это свойство применяется как способ аутентификации с использованием пары ключей.

Открытый ключ выгружается на удаленный сервер, на который вы хотите заходить, используя SSH. Этот ключ добавляется в специальный файл `~/.ssh/authorized_keys` в учетной записи пользователя, которую вы используете для входа.

Когда клиент пытается пройти аутентификацию с использованием ключей SSH, сервер может протестировать клиент на наличие у него закрытого ключа. Если клиент может доказать, что у него есть закрытый ключ, сервер выполняет запрошенную команду или открывает сеанс соединения.

---

##### Создание ключей SSH

Первый шаг для настройки аутентификации ключей SSH на сервере заключается в том, чтобы сгенерировать пару ключей SSH на локальном компьютере.

Для этого мы можем использовать специальную утилиту ssh-keygen, которая входит в стандартный набор инструментов OpenSSH. По умолчанию она создает пару 2048-битных ключей RSA, что подходит для большинства сценариев использования.

Сгенерируйте на локальном компьютере пару ключей SSH, введя следующую команду:
```
ssh-keygen
```
Утилита предложит вам выбрать место размещения генерируемых ключей. По умолчанию ключи хранятся в каталоге `~/.ssh` внутри домашнего каталога вашего пользователя. Закрытый ключ будет иметь имя `id_rsa`, а соответствующий открытый ключ будет иметь имя `id_rsa.pub`.

Если ранее вы сгенерировали пару ключей SSH, вы можете увидеть следующий диалог:
```
Overwrite (y/n)?
```
Если вы решите перезаписать ключ на диске, вы больше не сможете выполнять аутентификацию с помощью предыдущего ключа. Будьте осторожны при выборе варианта yes, поскольку этот процесс уничтожает ключи, и его нельзя отменить.

Далее вам будет предложено ввести парольную фразу для ключа. Это опциональная парольная фраза, которую можно использовать для шифрования файла закрытого ключа на диске. ![[Pasted image 20240715125533.png]]
Возможно вам будет интересно, в чем заключаются преимущества ключа SSH, если вам все равно нужна парольная фраза. Вот некоторые его преимущества:
- Закрытый ключ SSH (защищенная паролем часть) никогда не доступен через сеть. Парольная фраза используется только для расшифровки ключа на локальном компьютере. Это означает, что парольную фразу нельзя взломать через сеть методом прямого подбора.
- Закрытый ключ хранится в каталоге с ограниченным доступом. Клиент SSH не принимает закрытые ключи, хранящиеся в каталогах, доступ к которым не ограничен. У самого ключа могут быть ограниченные разрешения (чтение и запись доступны только владельцу). Это означает, что другие пользователи системы не смогут создать уязвимость.
- Для попытки взлома защищенного парольной фразой закрытого ключа SSH злоумышленнику уже необходим доступ к системе. Это означает, что у него уже должен быть доступ к учетной записи пользователя или учетной записи root. Если вы окажетесь в такой ситуации, парольная фраза может помешать злоумышленнику сразу же попасть на ваши другие серверы. Это может дать вам достаточно времени, чтобы создать и внедрить новую пару ключей SSH и запретить доступ с взломанным ключом.

##### Как скопировать открытый ключ на ваш сервер

**Копирование открытого ключа с использованием `SSH-Copy-ID`**
   
Инструмент **`ssh-copy-id`** входит в пакеты **OpenSSH** во многих дистрибутивах, так что, возможно, он уже установлен на вашей локальной системе. Чтобы этот метод сработал, вы должны уже настроить защищенный паролем доступ к серверу через **SSH**.

Для использования той утилиты вам нужно только указать удаленный хост, к которому вы хотите подключиться, и учетную запись пользователя, к которой у вас есть доступ через **SSH** с использованием пароля. Это учетная запись, куда будет скопирован ваш открытый ключ **SSH**.

Синтаксис выглядит следующим образом:
```
ssh-copy-id username@remote_host
```
![[Pasted image 20240715130400.png]]
Это означает, что ваш локальный компьютер не распознает удаленный хост. Это произойдет при первом подключении к новому хосту. Введите «yes» и нажмите ENTER, чтобы продолжить.

Затем утилита проведет сканирование локальной учетной записи для поиска ранее созданного ключа `id_rsa.pub`. Когда ключ будет найден, вам будет предложено ввести пароль учетной записи удаленного пользователя:![[Pasted image 20240715130452.png]]
Введите пароль (для безопасности вводимый текст не будет отображаться) и нажмите ENTER. Утилита подключится к учетной записи на удаленном хосте, используя указанный вами пароль. Затем содержимое ключа `~/.ssh/id_rsa.pub` будет скопировано в основной каталог `~/.ssh` удаленной учетной записи в файл с именем `authorized_keys`.

Вы получите следующий результат:![[Pasted image 20240715130558.png]]

**Альтернативный способ:**
``` 
cat ~/.ssh/id_rsa.pub | ssh username@remote_host "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
```

---
### SFTP

**FTP (File Transfer Protocol)**, или протокол передачи файлов, был популярным методом незашифрованной передачи файлов между двумя удаленными системами.

**SFTP (Secure FTP)**, протокол передачи файлов по **SSH**, или безопасный протокол передачи файлов, — это отдельный протокол, поддерживающий **SSH**, который работает схожим образом, но использует защищенное подключение. Его преимуществом является возможность использования защищенного подключения для передачи файлов и просмотра файловой системы как на локальной, так и на удаленной системе.

Практически во всех случаях использование **SFTP** будет более предпочтительным по сравнению с **FTP** из-за имеющихся у первого функций безопасности и возможности использования подключения **SSH**. **FTP** — это небезопасный протокол, который следует использовать в ограниченных случаях или в сетях, которым вы доверяете.

По умолчанию **SFTP** использует протокол **SSH** для аутентификации и установки защищенного подключения. По этой причине протокол использует те же методы аутентификации, что и **SSH**.

Так как **SFTP** работает поверх **SSH**, первым делом необходимо установить **OpenSSH** со стороны сервера (хранилища):
```bash
$ sudo apt install openssh-server
```
Также необходимо установить **ssh** на стороне клиента (устройства, с которого планируется доступ к хранилищу):
```bash
$ sudo apt install ssh
```
Для безопасного использования **SFTP**, лучше всего создать группы и пользователей, которые будут использовать только эту службу:
```bash
$ sudo useradd -g sftpgroup sftpuser
$ sudo passwd sftpuser
```
Cоздадим каталоги и изменим их доступ:
```bash
$ sudo mkdir -p /data/sftpuser/upload 
$ chown -R root.sftpgroup /data/sftp 
$ chown -R sftpuser.sftpgroup /data/sftp/upload
```
>Важно: убедитесь, что владелец` /data/sftpuser` - `root`, это обязательно для изменения корневого каталога в **SFTP**.

Далее нужно настроить сервер так, чтобы когда пользователь, из группы **sftpgroup**, входил в систему, он попадал в **sftp** вместо обычной оболочки, в которую попадает через **ssh**. Для этого нужно добавьте фрагмент кода в файл `/etc/ssh/sshd_config`. 
```
$ vi /etc/ssh/sshd_config
```
Добавляем следующее:
```
Match Group sftpgroup
ChrootDirectory /data/%u
ForceCommand internal-sftp
```
**ChrootDirectory** позволяет создать необходимый каталог в качестве корневого узла (/ каталог) в дереве каталогов. Вошедший в систему пользователь не сможет увидеть ничего выше этого каталога и это не даст ему получить доступ к файлам других пользователей. `%u` - это код для заполнения текущим именем пользователя во время входа в систему.

Другие команды:
``` 
Match group sftp # все user не смогут выполнять команды с помощью ssh

X11Forwarding no # чтобы не давать доступ к рабочему окружению

AllowTCPForwarding no # чтобы пользователь не смог использовать как proxy-сервер

ForceCommand internal-sftp # использовать только sftp, встроенный в ssh
```
проверяем конфигурацию командой `sshd -t`.

Чтобы выполнить внесенные в `sshd_config` изменения, перезапустите службу:
```
$ sudo systemctl restart sshd
```
Доступ по **sftp** осуществляется аналогично с **ssh** →` sftp username@host` (чтобы узнать ip-адрес хоста выполните команду ip a) :
```
$ sftp sftpuser@192.168.183.128
```

После успешеного подключения:
- загрузка файлов с удаленного хоста: 
  `sftp> get FileName`
- По умолчанию команда get загружает удаленный файл и сохраняет файл с тем же именем в локальной файловой системе. Мы можем указать имя, с которым сохранится файл, добавив его в вышеуказанную команду: 
  `sftp> get FileName NewName`
- Команда `get` также имеет несколько флагов. Например, мы можем скопировать каталог и все его содержимое с помощью рекурсивной опции: 
  `sgtp> get -r DirectoryName`
- Передача файлов в удаленную систему осуществляется таким же удобным образом с помощью команды с именем «`put`»:
  `sftp> put FileName`
- Директории передаются аналогичным с получением образом:
  `sgtp> put -r DirectoryName`
- Команда `!` перемещает нас в локальную оболочку, где можно запустить любую команду в локальной системе. Выполнив её, мы можем проверить использование диска также с помощью `df -h`. Чтобы вернуться в сеанс **SFTP**, введите `exit` . 

---

### WinSCP

Для передачи файлов с клиента под управлением **Windows** существует **FTP**-клиент **WinSCP**. Это свободный графический клиент протоколов **SFTP** и **SCP**, предназначенный для **Windows**. Благодаря графическому интерфейсу воспользоваться им не составит труда даже начинающему пользователю. Первым делом нужно скачать установщик с официального сайта ([winscp.net](http://winscp.net/)) и, следуя его указаниям, выполнить установку программы. При открытии пользователя встречает окно подключения к серверу:![[Pasted image 20240716081618.png]]
Для подключения к нашем **sftp**-серверу введите **ip**-адрес в поле имя хоста, укажите порт **22** (если не меняли), имя пользователя и пароль.

При успешном подключении увидим следующую картину:![[Pasted image 20240716081733.png]]
Для получения файла с сервера нажмите на соответствующий пункт и укажите путь, куда вы хотите сохранить файл:
![[Pasted image 20240716081748.png]]
Для загрузки файла на сервер достаточно перетащить его из папки на клиенте в нужный каталог, открытый в WinSCP:![[Pasted image 20240716081807.png]]
![[Pasted image 20240716081825.png]]

---

### Samba

#### Введение 
**Samba** – это программное обеспечение для реализации файлового сервера. Данный сервис дает возможность обращаться к сетевым дискам и принтерам по протоколу **SMB**/**CIFS**. Имеет клиентскую и серверную части. **Samba** – свободно распространяемое ПО. Начиная с версии 4 в **Samba** была реализована возможность выступать в роли контроллера домена и аналога сервиса **Active Directory**.

Устанавливая Samba и базовые сетевые службы (**DNS**, **NTP**, **Kerberos**) на один из **Linux**-дистрибутивов вы получаете следующую функциональность:
1. Контроллер домена **Active Directory**:
	- Служба Аутентификации на базе **Kerberos v5**
	- **LDAP**-совместимая служба каталогов c возможностью репликации по **DRS**
	- Сервер управления групповыми политиками
	- **DNS**-сервер на базе **BIND**
2. Файловый сервер
3. Сервер печати

_Прежде чем приступить к установке, убедитесь, что вы вошли в систему как пользователь с правами суперпользователя, а также обновите пакеты (apt update и apt upgrade)_.

---

#### Установка и настаройка
Для установки выполните:
```
apt install samba 
```
Проверим корректность установки:
```
systemctl status smbd
```

```
#на всякий случай делаем бекап файла конфигураций Samba 
cp /etc/samba/smb.conf /etc/samba/smb.conf.bak
```
Создадим директорию, в которую будем организовывать общий доступ, и в ней тестовый текстовый файл:
```
#cоздаем директорию, которая будет иметь общий доступ 
$ mkdir -p /samba/public 

#переходим в созданную директорию и устанавливаем права доступа на папку public 
$ cd samba 
$ chmod -R 0755 public 

#добавляем новую директорию и создаем новых пользователя и группу 
$ mkdir /samba/private 
$ sudo groupadd smbgrp 
$ sudo adduser user1 

#меняем права доступа для директории private и добавляем ранее созданную группу 
$ chgrp smbgrp /samba/private 

#добавляем пароль на диркеторию для user1 
$ sudo smbpasswd -a user1 

#переходим к редактированию конфигурационного файла Samba 
$ vi /etc/samba/smb.conf
```
Откроем файл конфигурации **samba** `/etc/samba/smb.conf` и пропишем там следующие настройки:
![[Pasted image 20240716082210.png]]
```
[global]
workgroup = WORKGROUP
security = user
map to guest = bad user
wins support = no
dns proxy = no

[public]
path = /samba/public
guest ok = yes
force user = nobody
browsable = yes
writable = yes

[private]
path = /samba/private
valid users = user1
guest ok = no
browsable = yes
writable = yes
```
Значения параметров выше:

- **global** - раздел с общими настройками для Samba сервера
- **workgroup** - рабочая группа Windows, WORKGROUP - значение по умолчанию для всех Windows машин, если вы не меняли самостоятельно
- **security** - режим безопасности, значение user означает аутентификацию по логину и паролю
- **map to guest** - задает способ обработки запросов, **bad user** - запросы с неправильным паролем будут отклонены, если такое имя пользователя существует
- **wins support** - включить или выключить поддержку WINS
- **dns proxy** - возможность запросов к DNS
- **public** - название общего каталога, которое будут видеть пользователи сети, может быть произвольным и не совпадать с именем директории
- **path** - полный путь до общего каталога
- **browsable** - отображение каталога в сетевом окружении
- **writable** - использование каталога на запись, инверсия read only
- **guest ok** - авторизация без пароля
- **force user** - пользователь по умолчанию
- **valid users** - список пользователей, у которых есть доступ к каталогу, через @ указывается unix-группа пользователей

Проверить настройки в `smb.conf` можно с помощью команды:
- `testparm -s`

`- comment` — комментарий для удобства. 
`- path` — путь на сервере, где будут храниться данные. 
`- public` — для общего доступа. Установите в yes, если хотите, чтобы все могли работать с ресурсом. 
`- writable` — разрешает запись на сетевой ресурс. 
`- read only` — только для чтения. Установите no, если у пользователей должна быть возможность создавать папки и файлы. 
`- guest ok` — разрешает доступ к папке гостевой учетной записи. 
`- create mask`, `directory mask`, `force create mode`, `force directory mode` — при создании новой папки или файла назначаются полные права.
![[Pasted image 20240716221048.png]]

В случае, если **samba**-сервер не работает, одной из причин может быть ошибка в конфигурационном файле. Чтобы не искать её вручную, была создана утилита **testparm**. После анализа заданного конфигурационного файла **testparm** выводит все значения файла `smb.conf`, включая значения по умолчанию. Это помогает убедиться, что используются ожидаемые значения параметров конфигурации. Стоит отметить, что значения по умолчанию меняются от версии к версии, так что необходимо использовать версию **Samba**, соответствующую версии **testparm**.

Использование:
```
$ testparm /etc/samba/smb.conf
```
или 
``` 
testparm -s # из директории с samba
```
Теперь перезапустим **samba** командой `systemctl restart smbd` и убедимся в том, что все работает, зайдя в нашу папку со сторонней **windows** машины. Для этого в проводнике вместо пути пропишите **ip**-адрес файлового сервера (узнать его можно с помощью команды ip a):![[Pasted image 20240716082454.png]]

---

#### Безопасность в Samba

```
#проверка установки iptables
$ iptables -L

#прописываем правило фаервола для разрешения (ACCEPT)
	- входящий пакетов 
	- по протоколу tcp
	- на порт 445
	- для адресов 10.0.0.0/24 (у вас ip может отличаться, можно посмотреть с помощью ip a)
$ iptables -A INPUT -p tcp -m tcp --dport 445 -s 10.0.0.0/24 -j ACCEPT

#аналогично для остальных портов (это те порты по которым работает Samba)
$ iptables -A INPUT -p tcp -m tcp --dport 139 -s 10.0.0.0/24 -j ACCEPT
$ iptables -A INPUT -p udp -m udp --dport 137 -s 10.0.0.0/24 -j ACCEPT
$ iptables -A INPUT -p udp -m udp --dport 138 -s 10.0.0.0/24 -j ACCEPT
```
Если нет `iptables`:
```
apt-get install iptables-persistent
```
Теперь в файле `rules.v4` прописаны правила, которые мы указывали ранее:
![[Pasted image 20240716222611.png]]
Для добавления и сохранения новых настроек необходимо применить команду:
```bash
$ service netfilter-persistent save
```


---

### Filezilla

Протокол **FTP** в наши дни очень часто используется многими веб-мастерами и разработчиками для загрузки файлов на сервера, управления файлами сайтов и решения других подобных задач. Такой популярности этот протокол набрал потому, что он прост в использовании и не требует особых знаний устройства и команд операционных систем **Linux**.

Для демонстрации развернем на виртуальной машине **FTP**-сервер. Будем использовать **FTP**-сервер **VSFTPD** (**Very Secure FTP Daemon**), который обеспечивает самую надёжную защиту от уязвимостей.

**Установка vsftpd**:
`$ sudo apt install vsftpd`

Заранее создадим файл со списком пользователей `vsftpd`:
`$ sudo nano /etc/vsftpd.userlist`

И добавим пользователя `ftpu`:
`$ sudo useradd ftpu`
`$ sudo passwd ***`

Добавьте его имя в файл `**/etc/vsftpd.userlist`,** чтобы ****предоставить FTP-доступ пользователю:
`$ echo "ftpu" | sudo tee -a /etc/vsftpd.userlist`

Сами **настройки vsftpd** хранятся в конфигурационном файле **`/etc/vsftpd.conf`**
Прежде чем вносить в него изменения создадим резервную копию:
`$ sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.orig`

Теперь откроем файл:
`$ sudo nano /etc/vsftpd.conf`

Добавьте такие настройки. Вам нужно будет найти и изменить значения указанных строк, или, если таковые отсутствуют, добавить новые.
```
listen=YES  #Указываем, что нужно ожидать входящих соединений
```
```
listen_ipv6=NO
```
```
connect_from_port_20=YES #Использовать порт 20 для передачи данных вместо случайного
```
```
anonymous_enable=NO #отключаем анонимный вход
```
```
local_enable=YES #Разрешаем использовать имена локальных пользователей для входа
```
```
write_enable=YES #Для авторизованных пользователей разрешаем команды, позволяющие изменять файловую систему
```

```
chroot_local_user=YES
allow_writeable_chroot=YES
#При входе пользователей на FTP-сервер, они могут работать
#только в корневом каталоге FTP.
#Если вы хотите, чтобы пользователи были ограничены только своей домашней папкой,
#то необходимо раскомментировать эти строчки:
```
```
secure_chroot_dir=/var/run/vsftpd/empty
```
```
pam_service_name=vsftpd #Использовать PAM-библиотеки
```
```
userlist_enable=YES #разрешим аутентификацию только пользователей, перечисленных в файле userlist:
```
```
userlist_file=/etc/vsftpd.userlist #Указываем файл с виртуальными пользователями
```
```
userlist_deny=NO #По умолчанию пользователям из userlist запрещён вход в систему, данная настройка делает наоборот
```
Затем необходимо **включить** сервис **vsftpd**, поскольку он не будет запущен по умолчанию, а также добавить службу в автозагрузку:
`$ sudo systemctl start vsftpd`
`$ sudo systemctl enable vsftpd`

Проверим статус сервиса:![[Pasted image 20240716083100.png]]

Один из самых популярных **FTP** клиентов, который используется множеством пользователей различных платформ, включая **Windows**, **MacOS** и даже **Linux**. Эта программа позволяет очень просто подключаться к удаленному серверу, выполнять там нужные действия, например, редактировать файлы, загружать их или скачивать, а также удобно просматривать файловую систему. В этой статье мы рассмотрим как пользоваться **FileZilla** для решения своих задач.

Для установки программы используйте такую команду:
`$ sudo apt install filezilla`

Откроем программу через графический интерфейс:
![[Pasted image 20240716083207.png]]
Для подключения к удаленному серверу введите **ip**-адрес сервера в поле **Host**, имя созданного пользователя в поле **Username** и пароль пользователя в поле **Password**. Нажмите **quickconnect**.

После подключения у Вас в одной части экрана будут видны локальные файлы, а в другой части будут файлы и директории на удаленном сервере. Вы можете _копировать_ их в любую сторону простым перетаскиванием из одной части рабочей области в другую, точно так же, как и в обычном проводнике **Windows**. Вы также можете _удалять_ файлы, _перемещать (переименовывать)_, _редактировать_ их и _изменять права доступа_ (chmod) к файлам и директориям на сервере.