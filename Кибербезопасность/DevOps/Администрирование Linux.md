# Пользователи

---

## Создание пользователей

```bash  
useradd [опции] пользователь
```
- `-b` - базовый каталог для размещения домашней директории пользователя, по умолчанию **`/home`**.
- `-d` - Домашний каталог, в котором буду размешаться файлы пользователя.
- `-c` - комментарий к учётной записи.
- `-e` - дата, когда учётная запись будет заблокирована.
- `-f` - заблокировать учётную запись сразу после создания.
- `-g` - основная группа пользователя.

---

## Удаление пользователей
```bash
userdel [опции] пользователь
```
- `-f` - Принудительное удаление учётной записи и домашнего каталога пользователя, даже если он ещё находится в системе.
- `-r` - Удалить пользователя вместе с домашним каталогом и почтовым ящиком.
\
---

## Смена пароля
```bash
passed [опции] пользователь
```
- `-d` - удалить пароль пользователя (после этого он не сможет войти).
- `-e` - сделать пароль устаревшим.
- `i` - количество дней после того, как пароль устарел, по истечению которых пользователь не сможет войти в аккаунт, если не сменил пароль. 
- `l` - запретить пользователю входить в системы.
- `-n` - минимальное количество дней между сменами пароля.
- `-m` - максимальное количество дней, пока пароль можно использовать.

---

# Права доступа

![[Pasted image 20240714131049.png]]
Первый символ указывает на тип файла:  
- `d` - директория, 
- `-` обычный файл 
- `l` - символическая ссылка 
- `c` - устройство символьного ввода/вывода
- `b` - устройство блочного ввода/вывода
- `p` - FIFO - связь между процессами
- `s` - сокет

---

## Изменение прав доступа

**Изменить владельца:** назначить **`user`** владельцем **`file`** 
```bash
chown [опции] user file
```

**Изменить группу на `group` для `file`:** 
```bash
chgrp [опции] group file
```

**Изменить права доступа `rwx`:**
```bash
chmod [права] file
```
![[Pasted image 20240714132121.png]]
`$ chmod +x file` — Сделать файл исполняемым для всех
`$ chmod ug+w file` — Разрешить изменение файла для владельца и группы
`$ chmod o-w file` — Запретить запись остальным пользователям
`$ chmod ugo+rwx file` — Разрешить чтение, запись и исполнение для всех

---

# Группы

- Посмотреть группу - `$ sudo groups [имя пользователя]`
- Изменить группу на **`group1`** для файла **`file1`** - `$ chgrp [опции] group1 file1`
- Добавить пользователя в группу - `$ usrmod -a -G [имя группы] [имя пользователя]`
  
  Для того, чтобы пользователь мог выполнять команды от имени суперпользователя, его нужно добавить в группу “`sudo`”:
  ```bash
  $ usermod -aG sudo имя_пользователя
  ```
  - `-a` - add
  - `-G` - если у пользователя уже были группы, они отключатся от него

	Либо можно изменить файл `/etc/sudoers`
	![[Pasted image 20240714134115.png]]
	- `root ALL = (ALL:ALL) ALL` Данная строчка указывает на то, что пользователь root имеет неограниченные привилегии в системе
	- `%sudo ALL = (ALL:ALL) ALL` Пользователи в группе sudo имеют права на запуск любой программы
	  ![[Pasted image 20240714134318.png]]

---

# Конфигурирование файлов

---

## Файлы пользователей

`/etc/passwd` — текстовый файл, содержащий список учетных записей пользователей. В него можно добавить своего пользователя с отличным от **root** именем, но с тем же **UID**:  

![[etc-passwd.png]]

>— **Первое** поле отвечает за имя пользователя
— **Второе** поле содержит «x». На устаревших Linux-системах второе поле содержало зашифрованных пароль для аутентификации, но фактически, сейчас все Linux-системы хранят эту информацию в файле `/etc/shadow`. 
— **Третье** поле отвечает за числовой пользовательский идентификатор, связанный с конкретным пользователем 
— **Четвертое** поле ассоциирует этого пользователя с конкретной группой; скоро мы увидим, где определена группа 1000. 
— **Пятое** поле содержит текстовое описание аккаунта, в нашем случае это имя пользователя. 
— **Шестое** поле определяет домашний каталог пользователя 
— **Седьмое** устанавливает стартовую оболочку пользователя, которая будет автоматически запускаться когда пользователь входит в систему.

`/etc/shadow` - файл зашифрованных паролей, в котором хранится информация о паролях для учетных записей пользователей. В дополнение к этому файл `/etc/shadow` хранит дополнительную информацию о сроке действия пароля.
![[Pasted image 20240714135806.png]]
![[Pasted image 20240714135738.png]]

---

### Конфигурационные файлы для пользовательских и системных переменных

Переменные делятся на классы:
- Системные переменные.
- Пользовательские переменные.
- Локальные переменные.

Два из трех классов переменных Linux хранятся в отдельных файлах, где собраны общие конфигурации и дополнительные параметры. Каждый такой объект загружается только при подходящих условиях и используется для разных целей. Отдельно бы хотелось выделить такие элементы:
- `/etc/profile` — один из системных файлов. Доступен для всех пользователей и всей системы даже при удаленном входе. Единственное ограничение для него — параметры не принимаются при открытии стандартного «Терминала», то есть в этом расположении никакие значения из этой конфигурации работать не будут.
- `/etc/environment` — более широкий аналог предыдущей конфигурации. Он функционирует на системном уровне, имеет те же опции, что и предыдущий файл, но теперь без каких-либо ограничений даже при удаленном подключении.
- `/etc/bash.bashrc` — файл только для локального использования, при удаленной сессии или соединении через интернет функционировать он не будет. Выполняется для каждого юзера отдельно при создании новой терминальной сессии.
- `~/.bashrc`— относится к конкретному юзеру, хранится в его домашней директории и выполняется каждый раз при новом запуске терминала.
- `~/.bash_profile` — то же, что `.bashrc`, только для удаленного взаимодействия, например, при использовании SSH.

**Добавление и удаление пользовательских переменных:**
1. Пользовательскую конфигурацию можно редактировать через `sudo vi .bashrc.`.
   ![[Pasted image 20240715164053.png]]
2. Обновление конфигурации произойдет после повторного старта файла, а делается это через `source .bashrc.`
3. Что касается удаления параметров, то происходит оно тоже через конфигурационный файл. Достаточно полностью удалить строку или закомментировать ее, добавив в начале знак #.

**Осталось только затронуть третий класс переменных — системные.** 
Редактироваться для этого будет файл `/etc/profile`, который остается активным даже при удаленном подключении, например, через SSH. 
1. Открытие конфигурационного элемента осуществляется примерно так же, как и в предыдущем варианте: `sudo vi /etc/profile`.
   ![[Pasted image 20240715164313.png]]
Изменения в файле сохранятся даже после перезагрузки сессии, а каждый юзер и приложение смогут без каких-либо проблем получать доступ к новым данным.

---

## Конфигурирование сети

- Узнать сетевые интерфейсы:
  ```bash
  dmesg | grep eth 
	```
- Информация о сетевом контролере:
  ```bash
  lspci | grep Ethernet
	```

**Утилита ip** - мощный инструмент для настройки сетевых интерфейсов, использующийся для включения или выключения интерфейсов, назначения или удаления адресов маршрутов, управления кэшем ARP и много другого.

- вывести статистику использования трафика сетевыми интерфесами:
  ``` bash
  ip -s -h a
	```
	- `-h` - human-readable.
	- `-s` - статистика.
- вывести маршруты
  ``` bash
  ip route
	```
	- или `ip r`.
- включение/остановка сетевого интерфейса:
  ``` bash
  sudo ip link set [interface] down
	```
	``` 
  sudo ip link set [interface] up
	```
- сменить MAC адрес для сетевого интерфейса:
  ``` bash
  sudo ip link set [interface] address [new MAC]
	```
- добавить новый сетевой интерфейс:
  ```bash
  sudo ip addr add [IP] dev [interface name]
	```
- мониторинг событий сетевых интерфесов
  ``` bash
  ip monitor
	```
	- Это команда покажет удаление и добавление маршрутов, изменения IP-адресов, включение и выключение сетевых устройств и другие события. Это напоминает автоматически обновляемый `ip -s -h a`.


---

### Конфигурационные файлы сети

![[Pasted image 20240714154406.png]]
![[Pasted image 20240714155031.png]]
![[Pasted image 20240714155107.png]]
![[Pasted image 20240714155202.png]]

#### Изменение интерфесов (например на статические)

Внизу файла `/etc/network/interfaces` нужно прописать следующие правила:
``` 
auto eth0
iface eth0 inet static
address [IP]
netmask [mask]
gateway [gateway IP]
broadcast [broadcast]
```
При дальнейших изменениях стоит сверять файлы `/etc/network/interfaces` и `/etc/resolv.conf`.
В `/etc/resolv.conf` прописывается DNS адрес:
```
dns-nameserver [DNS IP, например: 8.8.8.8]
dns-nameserver [DNS IP, если нужен ещё 1]
```

**Перезапуск сервиса сети на Debian:**
```bash
sudo systemctl restart network.service
```
или
``` bash
sudo service networking restart
```

---
## Информация о системе

1. `/etc/release` - информация о дистрибутиве и какая версия его
	![[Pasted image 20240715131515.png]]
2. `uname -a` - информация о ядре
	![[Pasted image 20240715131627.png]]
3. `whoami` - имя пользователя
4. `uptime` - когда и сколько система работала и соответственно, если она работала без перерыва 3 года, то злоумышлинник может воспользоваться старыми уязвимостями для получения доступа или внедрения кода.
5. `ip neigh` - показывает с какими компьютерами происходит обмен данными
	![[Pasted image 20240715131837.png]]
6. `sudo ss -tlnp` - показывает какие сервисы и с какими портами запущены
	![[Pasted image 20240715131942.png]]
7. `sudo -l` - позволяет нам понять, что есть в этой машине и что пользователь может

---

## Управление пакетами

**dpkg** — это программное обеспечение, являющееся основой системы управления пакетами в **Debian** и ряде других операционных систем, основанных на **Debian**, например **Ubuntu**. **dpkg** используется для установки, удаления, и получения информации о `.deb` пакетах.
- для просмотра пакетов в системе:
	```
	dpkg -l
	```
- для просмотра установленных утилит необходимо набрать следующую команду:
	```
	  dpkg -L coreutils
	```
	- она покажет все штатные утилиты![[Pasted image 20240715133936.png]]

**debsums** служит, в первую очередь, для нахождения изменённых администратором файлов установленных в системе пакетов или повреждённых файлов из-за некачественного носителя и в какой-то мере используется в качестве инструмента обеспечения безопасности.
- `debsums -a` - Проверяет все файлы (включая конфигурационные, которые обычно располагаются слева)
- `debsums -e` - Проверяет только конфигурационные файлы пакетов
- `debsums -с` - Выводит список измененных файлов
- `debsums -I` - Отображает файлы, в которых отсутствует информация о **md5sum**
- `debsums -s` - Выводит только ошибки; при их отсутствии не производит никаких действий
- `debsums -ac coreutils` - запуск проверки
- `debsums -cs coreutils` - запуск проверки
  ![[Pasted image 20240715134454.png]]
  можно также проверить утилитой 
  ```
  dpkg --verify coreutils
	```

Если кто-то смог проникнуть в систему и что-то cделал в ней, нам поможет команда ё Например, если нам надо рассмотреть какой либо инцидент: 
```
sudo find / -printf "%T@;%Tc;%p\\n"
```
```
-prinf - то где мы будем искать
%T@ - время ввиде числа
%Tc - время человека читаемое
%p\\n - путь до файла
```
![[Pasted image 20240715134824.png]]
Далее если надо сделать по одному конкретному пользователю необходимо следующие:
``` 
sudo find /home/kali/ -printf "%T@;%Tc;%p\\n" > timeline.csv
```
```
sort -rn timeline.csv | less
```
![[Pasted image 20240715134959.png]]
Мы можем видеть, что менялось и в какое время, что позволит увидеть все изменения.

---

# Мониторинг OS Linux
![[Pasted image 20240714141746.png]]

---

## htop - информация о процессах в реальном времени. выводит данные о потреблении системных ресурсов, останавливает и управляет процессами
![[Pasted image 20240714222203.png]]
**В самом верху показана нагрузка на каждое ядро центрального процессора (цифры от 1 до 12).**
```
Mem — это общее количество оперативной памяти и используемая память.
Task — обобщённая статистика по процессам
Swp — уровень занятости файла подкачки (если он есть)
Load average — средняя загрузка центрального процессора
Uptime — время работы операционной системы с момента последней загрузки
```
**Теперь перейдём к области с информацией о запущенных процессах.**
Значение столбцов htop:
- PID - Идентификатор процесса.
- USER - Имя пользователя владельца процесса или ID если имя не может быть определено.
- PRI - Приоритет — внутренний приоритет ядра для процесса, обычно это просто значение nice плюс двадцать. Отличается для процессов имеющих приоритет выполнения real-time.
- NI - NICE значение процесса от `19` (низкий приоритет) до `-20` (высокий приоритет). Более высокое значение означает, что процесс «приятный» для других и позволяет им иметь более высокий приоритет выполнения.
- VIRT - Размер виртуальной памяти процесса (M_SIZE).
- RES - Размер резидентного набора (text + data + stack) процесса (т.е. размер используемой физической памяти процесса, M_RESIDENT).
- SHR - Размер общих страниц процесса (M_SHARE).
- S - STATE, состояние процесса, может быть:
  ```
	S для спящих (в простое)
	R для запущенных
	D для сна диска (бесперебойный)
	Z для зомби (ожидает родитель считает его статус выхода)
	T для отслеживания или приостановки (т. е. от SIGTSTP)
	W для подкачки
	```
- CPU% - Процент процессорного времени, которое процесс использует в данный момент.
- MEM% - Процент памяти, используемой процессом в данный момент (в зависимости от размера резидентной памяти процесса, см. M_RESIDENT выше).
- TIME+ - Время, измеренное в часах, указывает на то, сколько процесс провёл в пользовательском и системном времени.
- Command - Полная командная строка процесса (то есть имя программы и аргументы).

**Как ускорить или замедлить частоту обновления htop:**
- `-d [number]` - скорость обновления экрана в децисекундах (nubmer  = 10 = 1 сек)

**Как вывести процессы в виде дерева:**
- `-t` - вывод процессов в виде дерева

---
## w - работающие в системе в ближайшее время пользователи
![[Pasted image 20240714222135.png]]

- `-u` - игнорировать имена пользователей при определении времени текущего процесса и времени CPU.
- `-s` - сокращённый формат вывода. Не выводи колонки JCPU и PCPU.
- `-f` - включить или выключить поле `from`, соответствующее имени удалённого хоста (remote hostname). В зависимости от дистрибутива Linux (версии утилиты w), поле from может выводиться или не выводиться по умолчанию.
- `-i` - выводить в поле `from` IP-адрес вместо имени хоста, если это возможно.
- `-o` - выводить информацию в старом формате. Время, которое меньше 1 минуты, не выводится.
  ![[Pasted image 20240714222103.png]]
  

В таблице для каждого пользователя выводятся следующие поля:
```
USER — имя пользователя.
TTY — название терминала.
FROM — название удаленного компьютера или IP-адрес.
LOGIN — время входа в систему.
IDLE — время бездействия.
JCPU — время, использованное всеми процессами, подключенными к tty. Оно не включает завершенные фоновые задания, но включает фоновые задания, работающие в данный момент.
PCPU — время, использованное текущим процессом, который указан в поле WHAT.
WHAT — текущий процесс (командная строка текущего процесса).
```

---

## df - сведения о файловой системе

- `-a` `--all` - отобразить все файловые системы, в том числе виртуальные, псевдо и недоступные.
- `-h` - human-readable - выводит размер в степени 1024.
- `-i` – выводить информацию об inode;
- `-H` - выводит размер в степени 1000 (гигабайтах).
- `-l` - перечислить файловые системы.
- `-T` - выводит тип файловой системы.
  - `-t` `--type [TYPE]` - перечислить файловые системы конкретного типа.
  - `--exclude-type [TYPE]` - исключить файловые системы конкретного типа.
  - `-x` – выводить информацию обо всех, кроме указанных файловых систем;
- `–output` – использовать специальный формат вывода, если не задано, выводит все поля. Доступны такие варианты: ‘source’, ‘fstype’, ‘itotal’, ‘iused’, ‘iavail’, ‘ipcent’, ‘size’, ‘used’, ‘avail’, ‘pcent’, ‘file’ и ‘target’;
- `-P` – использовать формат вывода POSIX;
- `-–total` – выводить всю информацию про использованное и доступное место;



---

## du - сведения о дисковом пространстве

- `-a` - выводит весь объём всех файлов, а не только каталоги.
- `-b` - выводит действительные размеры в байтах.
- `-c` - выводит общую сумму указанных каталогов: total.
- `-s` - выводит только общий размер указанного каталога, а не подкаталогов.
- `--max-depth` - глубина погружения в каталоги.
- `-h` - human-readable.
- `--apparent-size` - выводит фактический объем данных в файле.

---

## free - сколько свободной оперативной памяти доступно и достаточно ли свободной памяти для установки и запуска новых приложений

- `-b` - отображает вывод в байтах.
- `-k` - в килобайтах.
- `-m` - в мегабайтах.
- `-g` - в гигабайтах.
- `-h` - human-readable.
- `-w` - переключение вывода в расширенный режим, который обеспечивает вывод более 80 символов в строке и разделяет столбец "buff/cache".
- `-t` - отображает строку total.
- `-s` `--seconds` - постоянно отображать информацию о памяти на экране.
  - `-c` - количество выводов на экран до прекращения. Пример: `free -s 5 -c 10`.

Что означает каждый столбец:
- **total** — это число представляет общий объем памяти, который может быть использован приложениями.
- **used** — Используемая память. Он рассчитывается как: used = total - free - buffers - cache
- **free** — Свободная / неиспользуемая память.
- **shared** — этот столбец можно игнорировать, поскольку он не имеет значения. Это здесь только для обратной совместимости.
- **buff / cache** — объединенная память, используемая буферами ядра, а также страничным кешем и блоками. Эта память может быть освобождена в любое время, если это необходимо приложениям.

---

## iostat - используется для мониторинга системной статистики ввода-вывода для устройств и разделов

- `-c` - отобразить только информацию об использовании процессора.
- `-d` - отобразить только информацию об использовании устройства.
- `-h` - human-readable.
- `-k` - вывести статистику в килобайтах.
- `-m` - вывести статистику в мегабайтах.
- `-o JSON` - выводить статистику в формате JSON;
- `-p` - вывести статистику по устройству и всем его разделам.
- `-x` - вывести расширенную статистику.
- `-y` - отображать статистику с момента запуска утилиты, а не системы.
- `-z` - спрятать информацию о дисках, у которых нет активности.

> Чтобы утилита автоматически обновляла данные каждую секунду просто добавьте интервал. Например: `sudo iostat -p /dev/nvme0n1 1`

В первой части отчёта находится информация о загруженности процессора. Тут есть такие колонки:
- **%user** - процент использования процессора программами, запущенными на уровне пользователя;
- **%nice** - процент использования процессора программами запущенными тоже в пространстве пользователя, но только с изменённым приоритетом;
- **%system** - процент использования процессора ядром;
- **%iowait** - процент времени затраченного на ожидание завершения операций ввода/вывода;
>  Если значение параметра %iowait слишком большое, то это может означать, что у вас проблема с производительностью диска и слишком много времени тратится на ожидание завершения ввода/вывода
- **%steal** - процент простоя виртуального процессора, пока гипервизор отдаёт мощность другому виртуальному процессору;
- **%idle** - процент времени пока процессор не занят ничем.

Для устройств ввода/вывода тоже отображается ряд колонок с информацией. Разберемся что они означают:
- **tps** - означает количество запросов на чтение или запись к устройству в секунду;
- **KB_read/s**, **MB_read/s** - количество килобайт или мегабайт, прочитанных с устройства за секунду;
- **KB_wrtn/s**, **MB_wrtn/s** - количество килобайт или мегабайт записанных на устройство в секунду;
- **KB_dscd/s**, **MB_dscd/s** - скорость освобождения блоков данных на устройстве, килобайт или мегабайт в секунду;
- **KB_read**, **MB_read** - общее количество прочитанных данных с диска с момента загрузки системы;
- **KB_wrtn**, **MB_wrtn** - количество записанных данных с момента загрузки системы;
- **KB_dscd**, **MB_dscd** - количество освобождённых блоков на диске в результате выполнения операции trim в килобайтах или мегабайтах.
  
  > Освобождение блоков с данными с помощью операции trim или discard актуально для SSD дисков. Этой операцией файловая система сообщает какие блоки больше хранить физически не нужно и можно использовать для других целей. Утилита отображает с какой скоростью эти блоки освобождаются, а также сколько блоков или мегабайт данных было освобождено.

---

## mpstat - вывод каждого имеющегося процесса

Утилита **mpstat** нужна для мониторинга производительности **Unix/Linux**.

**mpstat** — отчет о использовании процессоров. Команда **mpstat** пишет в стандартный вывод на экран о каждом имеющемся процессоре, 0-й процессор будет выведен на первое место. Параметр «**interval**» определяет количество времени в секундах между каждым отчетом. Значение 0 (или без параметров) показывает статистику о процессорах и отчетность будет представляться с момента запуска системы (загрузки).

- `-A` - показывает всю информацию, которая может быть отображена с помощью команды `mpstat` о процессоре.
  ![[Pasted image 20240714221210.png]]
- `-P ALL` - вывод всех индивидуальных процессоров или ядер со статистикой.
  ![[Pasted image 20240714221221.png]]
- `-P 0` - для отображения статистики о конкретном CPU или ядре.
  ![[Pasted image 20240714221248.png]]

---

## vmstat - статистическая информация об оперативной памяти, дисках, ядра, переключении контекста и процессорах.

![[Pasted image 20240714221320.png]]
Отчет команды vmstat содержит статистическую информацию о нитях ядра, находящихся в очереди выполнения и ожидающих запуска, а также об оперативной памяти, подкачке, дисках, прерываниях, системных вызовах, переключении контекста и работе процессора.

В информации о процессоре указывается доля времени, в течение которой процессор работал в пользовательском режиме, системном режиме, простаивал и ожидал завершения операции дискового ввода-вывода.

Для получения информации о работе процессора удобнее использовать команду vmstat, а не iostat, так как ее построчный вывод проще анализировать, а в случае, когда к системе подключено много дисков, ее вывод намного менее объемный. Приведенный ниже пример иллюстрирует применение vmstat для обнаружения программ, которые потребляют слишком много ресурсов CPU.

**`vmstat -a`**
(active/inactive memory) - активная/неактивная память
![[Pasted image 20240714221539.png]]

**`vmstat -f`**
(number of forks since boot) - количество задач с момента загрузки
![[Pasted image 20240714221636.png]]

**`vmstat -d`**
(disk statistics) - статистика диска
![[Pasted image 20240714221658.png]]

**`vmstat -D`**
(summarize disk statistics) - (общая статистика диска)
![[Pasted image 20240714221716.png]]

`vmstat [seconds]` - через какое количество секунд выводить информацию

---

# Логирование

Все команды, выполняемые через **`sudo`** логируются в **`/var/log/auth.log`**

---

# SSH-сервер

---

## Конфигурация сервера

Вся конфигурация SSH-сервера хранится в файле **`/etc/ssh/sshd_config`**.
![[Pasted image 20240715121408.png]]
1. В первую очередь следует обратить внимание на следующие параметры: `Port`, `AddressFamily`, `ListenAddress`. 
	- **`Port`** глобально задаёт номер порта, через который будет работать соединение и если оставить его стандартным, т. е. `22`, то велика вероятность, что он будет слишком часто сканироваться роботами.
	- **`AddressFamily`** задаёт семейство используемых IP-адресов — **IPv4** и **IPv6**. Если, к примеру, используются только адреса **IPv4**, то очень рекомендуется установить для параметра `AddressFamily` значение `inet`:
	  ```
	  AddressFamily inet 
		```
		Для адресов семейства IPv6 используется значение inet6.
	- **`ListenAddress`** позволяет задавать порты для отдельных сетевых интерфейсов:
	  ```
	  - ListenAddress 10.24.205.75:2123
	  - ListenAddress 10.24.205.76:2124
		```

2. Поскольку реализация openSSH позволяет работать с протоколами SSH1 и SSH2, то разумно отключить использование SSH1, т. к. эта версия является устаревшей. Работа по SSH1 крайне не рекомендуется: Protocol 2

3. Очень полезным является параметр, позволяющий проводить авторизацию и шифрование трафика с помощью специальных SSH-ключей: 
	```
	PubkeyAuthentication yes
	```
	- Следует заметить, что в таком случае серверу необходимо явно указывать, где хранятся открытые ключи пользователей. Это может быть как один общий файл для хранения ключей всех пользователей (обычно это файл `/etc/.ssh/authorized_keys`), так и отдельные для каждого пользователя ключи. Второй вариант предпочтительнее в силу удобства администрирования и повышения безопасности:
	  ```
	  AuthorizedKeysFile etc/ssh/authorized_keys # Для общего файла AuthorizedKeysFile 
		```
		```
		%h/.ssh/authorized_keys # Файл -> пользователь
		```
		- Во втором варианте благодаря шаблону автоподстановки с маской «%h» будет использоваться домашний каталог пользователя.

4. Важно также отключать парольный доступ:
	  ```
	PasswordAuthentication no
	```
	- Или же, в случае, если всё-таки необходимо использовать доступ по паролю, то обязательно нужно отключать авторизацию по пустому паролю:
	  ```
		PermitEmptyPasswords no
		```
5. Для указания разрешённых или запрещённых пользователей и групп служат директивы `DenyUsers`, `AllowUsers`, `DenyGroups`, и `AllowGroups`. Значениями для них являются списки имён, разделяемых пробелами, например:
   ```
   DenyUsers fred john 
   AllowGroups root clients administrators
	```
	- Следует также отключать root-доступ:
	  ```
	  PermitRootLogin no
		```

6. Иногда, когда следует задавать мультисерверную конфигурацию, очень удобно использовать алиасы (Aliases), что позволяет настроить сразу несколько режимов доступа (с разными хостами, портами и т. д.) и использовать их, указывая при этом конкретный алиас: `$ ssh alias_name`.
   
   Настройки для алиасов хранятся либо глобально в `/etc/ssh/ssh_config`, либо раздельно для пользователей в `~/.ssh/config`.
   ```
   Host your_alias 
   Port your_ssh_port 
   HostName 0.0.0.0 # IP или имя хоста 
   User your_user_name
	```

**Для применения сделанных настроек необходим перезапуск SSH-сервера:**
`$ systemctl restart sshd`
**или:**
`$ service ssh restart`

---
## SSH-authorized_keys

---

### Введение 

Пары ключей SSH представляют собой два защищенных шифрованием ключа, которые можно использовать для аутентификации клиента на сервере SSH. Каждая пара ключей состоит из открытого ключа и закрытого ключа.

Закрытый ключ хранится клиентом и должен быть абсолютно защищен. Любое нарушение безопасности закрытого ключа позволит злоумышленникам входить на серверы с соответствующим открытым ключом без дополнительной аутентификации. В качестве дополнительной меры предосторожности ключ можно зашифровать на диске с помощью парольной фразы.

Соответствующий открытый ключ можно свободно передавать, не опасаясь негативных последствий. Открытый ключ можно использовать для шифрования сообщений, которые может расшифровать только закрытый ключ. Это свойство применяется как способ аутентификации с использованием пары ключей.

Открытый ключ выгружается на удаленный сервер, на который вы хотите заходить, используя SSH. Этот ключ добавляется в специальный файл `~/.ssh/authorized_keys` в учетной записи пользователя, которую вы используете для входа.

Когда клиент пытается пройти аутентификацию с использованием ключей SSH, сервер может протестировать клиент на наличие у него закрытого ключа. Если клиент может доказать, что у него есть закрытый ключ, сервер выполняет запрошенную команду или открывает сеанс соединения.

---

### Создание ключей SSH

Первый шаг для настройки аутентификации ключей SSH на сервере заключается в том, чтобы сгенерировать пару ключей SSH на локальном компьютере.

Для этого мы можем использовать специальную утилиту ssh-keygen, которая входит в стандартный набор инструментов OpenSSH. По умолчанию она создает пару 2048-битных ключей RSA, что подходит для большинства сценариев использования.

Сгенерируйте на локальном компьютере пару ключей SSH, введя следующую команду:
```
ssh-keygen
```
Утилита предложит вам выбрать место размещения генерируемых ключей. По умолчанию ключи хранятся в каталоге `~/.ssh` внутри домашнего каталога вашего пользователя. Закрытый ключ будет иметь имя `id_rsa`, а соответствующий открытый ключ будет иметь имя `id_rsa.pub`.

Если ранее вы сгенерировали пару ключей SSH, вы можете увидеть следующий диалог:
```
Overwrite (y/n)?
```
Если вы решите перезаписать ключ на диске, вы больше не сможете выполнять аутентификацию с помощью предыдущего ключа. Будьте осторожны при выборе варианта yes, поскольку этот процесс уничтожает ключи, и его нельзя отменить.

Далее вам будет предложено ввести парольную фразу для ключа. Это опциональная парольная фраза, которую можно использовать для шифрования файла закрытого ключа на диске. ![[Pasted image 20240715125533.png]]
Возможно вам будет интересно, в чем заключаются преимущества ключа SSH, если вам все равно нужна парольная фраза. Вот некоторые его преимущества:
- Закрытый ключ SSH (защищенная паролем часть) никогда не доступен через сеть. Парольная фраза используется только для расшифровки ключа на локальном компьютере. Это означает, что парольную фразу нельзя взломать через сеть методом прямого подбора.
- Закрытый ключ хранится в каталоге с ограниченным доступом. Клиент SSH не принимает закрытые ключи, хранящиеся в каталогах, доступ к которым не ограничен. У самого ключа могут быть ограниченные разрешения (чтение и запись доступны только владельцу). Это означает, что другие пользователи системы не смогут создать уязвимость.
- Для попытки взлома защищенного парольной фразой закрытого ключа SSH злоумышленнику уже необходим доступ к системе. Это означает, что у него уже должен быть доступ к учетной записи пользователя или учетной записи root. Если вы окажетесь в такой ситуации, парольная фраза может помешать злоумышленнику сразу же попасть на ваши другие серверы. Это может дать вам достаточно времени, чтобы создать и внедрить новую пару ключей SSH и запретить доступ с взломанным ключом.

#### Как скопировать открытый ключ на ваш сервер

**Копирование открытого ключа с использованием `SSH-Copy-ID`**
   
Инструмент **`ssh-copy-id`** входит в пакеты **OpenSSH** во многих дистрибутивах, так что, возможно, он уже установлен на вашей локальной системе. Чтобы этот метод сработал, вы должны уже настроить защищенный паролем доступ к серверу через **SSH**.

Для использования той утилиты вам нужно только указать удаленный хост, к которому вы хотите подключиться, и учетную запись пользователя, к которой у вас есть доступ через **SSH** с использованием пароля. Это учетная запись, куда будет скопирован ваш открытый ключ **SSH**.

Синтаксис выглядит следующим образом:
```
ssh-copy-id username@remote_host
```
![[Pasted image 20240715130400.png]]
Это означает, что ваш локальный компьютер не распознает удаленный хост. Это произойдет при первом подключении к новому хосту. Введите «yes» и нажмите ENTER, чтобы продолжить.

Затем утилита проведет сканирование локальной учетной записи для поиска ранее созданного ключа `id_rsa.pub`. Когда ключ будет найден, вам будет предложено ввести пароль учетной записи удаленного пользователя:![[Pasted image 20240715130452.png]]
Введите пароль (для безопасности вводимый текст не будет отображаться) и нажмите ENTER. Утилита подключится к учетной записи на удаленном хосте, используя указанный вами пароль. Затем содержимое ключа `~/.ssh/id_rsa.pub` будет скопировано в основной каталог `~/.ssh` удаленной учетной записи в файл с именем `authorized_keys`.

Вы получите следующий результат:![[Pasted image 20240715130558.png]]

**Альтернативный способ:**
``` 
cat ~/.ssh/id_rsa.pub | ssh username@remote_host "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
```