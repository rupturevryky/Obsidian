# Пользователи

---

## Создание пользователей

```bash  
useradd [опции] пользователь
```
- `-b` - базовый каталог для размещения домашней директории пользователя, по умолчанию **`/home`**.
- `-d` - Домашний каталог, в котором буду размешаться файлы пользователя.
- `-c` - комментарий к учётной записи.
- `-e` - дата, когда учётная запись будет заблокирована.
- `-f` - заблокировать учётную запись сразу после создания.
- `-g` - основная группа пользователя.

---

## Удаление пользователей
```bash
userdel [опции] пользователь
```
- `-f` - Принудительное удаление учётной записи и домашнего каталога пользователя, даже если он ещё находится в системе.
- `-r` - Удалить пользователя вместе с домашним каталогом и почтовым ящиком.
\
---

## Смена пароля
```bash
passwd [опции] пользователь
```
- `-d` - удалить пароль пользователя (после этого он не сможет войти).
- `-e` - сделать пароль устаревшим.
- `i` - количество дней после того, как пароль устарел, по истечению которых пользователь не сможет войти в аккаунт, если не сменил пароль. 
- `l` - запретить пользователю входить в системы.
- `-n` - минимальное количество дней между сменами пароля.
- `-m` - максимальное количество дней, пока пароль можно использовать.

---

## Права доступа

![[Pasted image 20240714131049.png]]
Первый символ указывает на тип файла:  
- `d` - директория, 
- `-` обычный файл 
- `l` - символическая ссылка 
- `c` - устройство символьного ввода/вывода
- `b` - устройство блочного ввода/вывода
- `p` - FIFO - связь между процессами
- `s` - сокет

---

### Изменение прав доступа

**Изменить владельца:** назначить **`user`** владельцем **`file`** 
```bash
chown [опции] user file
```

**Изменить группу на `group` для `file`:** 
```bash
chgrp [опции] group file
```

**Изменить права доступа `rwx`:**
```bash
chmod [права] file
```
![[Pasted image 20240714132121.png]]
`$ chmod +x file` — Сделать файл исполняемым для всех
`$ chmod ug+w file` — Разрешить изменение файла для владельца и группы
`$ chmod o-w file` — Запретить запись остальным пользователям
`$ chmod ugo+rwx file` — Разрешить чтение, запись и исполнение для всех

---

## Группы

- Посмотреть группу - `$ sudo groups [имя пользователя]`
- Изменить группу на **`group1`** для файла **`file1`** - `$ chgrp [опции] group1 file1`
- Добавить пользователя в группу - `$ usrmod -a -G [имя группы] [имя пользователя]`
  
  Для того, чтобы пользователь мог выполнять команды от имени суперпользователя, его нужно добавить в группу “`sudo`”:
  ```bash
  $ usermod -aG sudo имя_пользователя
  ```
  - `-a` - add
  - `-G` - если у пользователя уже были группы, они не отключатся от него

	Либо можно изменить файл `/etc/sudoers`
	![[Pasted image 20240714134115.png]]
	- `root ALL = (ALL:ALL) ALL` Данная строчка указывает на то, что пользователь root имеет неограниченные привилегии в системе
	- `%sudo ALL = (ALL:ALL) ALL` Пользователи в группе sudo имеют права на запуск любой программы
	  ![[Pasted image 20240714134318.png]]

---

# Конфигурирование файлов

---

## Файлы пользователей

`/etc/passwd` — текстовый файл, содержащий список учетных записей пользователей. В него можно добавить своего пользователя с отличным от **root** именем, но с тем же **UID**:  

![[etc-passwd.png]]

>— **Первое** поле отвечает за имя пользователя
— **Второе** поле содержит «x». На устаревших Linux-системах второе поле содержало зашифрованных пароль для аутентификации, но фактически, сейчас все Linux-системы хранят эту информацию в файле `/etc/shadow`. 
— **Третье** поле отвечает за числовой пользовательский идентификатор, связанный с конкретным пользователем 
— **Четвертое** поле ассоциирует этого пользователя с конкретной группой; скоро мы увидим, где определена группа 1000. 
— **Пятое** поле содержит текстовое описание аккаунта, в нашем случае это имя пользователя. 
— **Шестое** поле определяет домашний каталог пользователя 
— **Седьмое** устанавливает стартовую оболочку пользователя, которая будет автоматически запускаться когда пользователь входит в систему.

`/etc/shadow` - файл зашифрованных паролей, в котором хранится информация о паролях для учетных записей пользователей. В дополнение к этому файл `/etc/shadow` хранит дополнительную информацию о сроке действия пароля.
![[Pasted image 20240714135806.png]]
![[Pasted image 20240714135738.png]]

---

### Конфигурационные файлы для пользовательских и системных переменных

Переменные делятся на классы:
- Системные переменные.
- Пользовательские переменные.
- Локальные переменные.

Два из трех классов переменных Linux хранятся в отдельных файлах, где собраны общие конфигурации и дополнительные параметры. Каждый такой объект загружается только при подходящих условиях и используется для разных целей. Отдельно бы хотелось выделить такие элементы:
- `/etc/profile` — один из системных файлов. Доступен для всех пользователей и всей системы даже при удаленном входе. Единственное ограничение для него — параметры не принимаются при открытии стандартного «Терминала», то есть в этом расположении никакие значения из этой конфигурации работать не будут.
- `/etc/environment` — более широкий аналог предыдущей конфигурации. Он функционирует на системном уровне, имеет те же опции, что и предыдущий файл, но теперь без каких-либо ограничений даже при удаленном подключении.
- `/etc/bash.bashrc` — файл только для локального использования, при удаленной сессии или соединении через интернет функционировать он не будет. Выполняется для каждого юзера отдельно при создании новой терминальной сессии.
- `~/.bashrc`— относится к конкретному юзеру, хранится в его домашней директории и выполняется каждый раз при новом запуске терминала.
- `~/.bash_profile` — то же, что `.bashrc`, только для удаленного взаимодействия, например, при использовании SSH.

**Добавление и удаление пользовательских переменных:**
1. Пользовательскую конфигурацию можно редактировать через `sudo vi .bashrc.`.
   ![[Pasted image 20240715164053.png]]
2. Обновление конфигурации произойдет после повторного старта файла, а делается это через `source .bashrc.`
3. Что касается удаления параметров, то происходит оно тоже через конфигурационный файл. Достаточно полностью удалить строку или закомментировать ее, добавив в начале знак #.

**Осталось только затронуть третий класс переменных — системные.** 
Редактироваться для этого будет файл `/etc/profile`, который остается активным даже при удаленном подключении, например, через SSH. 
1. Открытие конфигурационного элемента осуществляется примерно так же, как и в предыдущем варианте: `sudo vi /etc/profile`.
   ![[Pasted image 20240715164313.png]]
Изменения в файле сохранятся даже после перезагрузки сессии, а каждый юзер и приложение смогут без каких-либо проблем получать доступ к новым данным.

---

## Конфигурирование сети

- Узнать сетевые интерфейсы:
  ```bash
  dmesg | grep eth 
	```
- Информация о сетевом контролере:
  ```bash
  lspci | grep Ethernet
	```

**Утилита ip** - мощный инструмент для настройки сетевых интерфейсов, использующийся для включения или выключения интерфейсов, назначения или удаления адресов маршрутов, управления кэшем ARP и много другого.

- вывести статистику использования трафика сетевыми интерфесами:
  ``` bash
  ip -s -h a
	```
	- `-h` - human-readable.
	- `-s` - статистика.
- вывести маршруты
  ``` bash
  ip route
	```
	- или `ip r`.
- включение/остановка сетевого интерфейса:
  ``` bash
  sudo ip link set [interface] down
	```
	``` 
  sudo ip link set [interface] up
	```
- сменить MAC адрес для сетевого интерфейса:
  ``` bash
  sudo ip link set [interface] address [new MAC]
	```
- добавить новый сетевой интерфейс:
  ```bash
  sudo ip addr add [IP] dev [interface name]
	```
- мониторинг событий сетевых интерфесов
  ``` bash
  ip monitor
	```
	- Это команда покажет удаление и добавление маршрутов, изменения IP-адресов, включение и выключение сетевых устройств и другие события. Это напоминает автоматически обновляемый `ip -s -h a`.


---

### Конфигурационные файлы сети

![[Pasted image 20240714154406.png]]
![[Pasted image 20240714155031.png]]
![[Pasted image 20240714155107.png]]
![[Pasted image 20240714155202.png]]

#### Изменение интерфесов (например на статические)

Внизу файла `/etc/network/interfaces` нужно прописать следующие правила:
``` 
auto eth0
iface eth0 inet static
address [IP]
netmask [mask]
gateway [gateway IP]
broadcast [broadcast]
```
При дальнейших изменениях стоит сверять файлы `/etc/network/interfaces` и `/etc/resolv.conf`.
В `/etc/resolv.conf` прописывается **DNS** адрес:
``` 
nameserver [DNS IP, например: 8.8.8.8]
nameserver [DNS IP, если нужен ещё 1]
```
**Перезапуск сервиса сети на Debian:**
```bash
sudo systemctl restart network.service
```
или
``` bash
sudo service networking restart
```

---
## Информация о системе

1. `/etc/release` - информация о дистрибутиве и какая версия его
	![[Pasted image 20240715131515.png]]
2. `uname -a` - информация о ядре
	![[Pasted image 20240715131627.png]]
3. `whoami` - имя пользователя
4. `uptime` - когда и сколько система работала и соответственно, если она работала без перерыва 3 года, то злоумышлинник может воспользоваться старыми уязвимостями для получения доступа или внедрения кода.
5. `ip neigh` - показывает с какими компьютерами происходит обмен данными
	![[Pasted image 20240715131837.png]]
6. `sudo ss -tlnp` - показывает какие сервисы и с какими портами запущены
	![[Pasted image 20240715131942.png]]
7. `sudo -l` - позволяет нам понять, что есть в этой машине и что пользователь может

---

## Управление пакетами

**dpkg** — это программное обеспечение, являющееся основой системы управления пакетами в **Debian** и ряде других операционных систем, основанных на **Debian**, например **Ubuntu**. **dpkg** используется для установки, удаления, и получения информации о `.deb` пакетах.
- для просмотра пакетов в системе:
	```
	dpkg -l
	```
- для просмотра установленных утилит необходимо набрать следующую команду:
	```
	  dpkg -L coreutils
	```
	- она покажет все штатные утилиты![[Pasted image 20240715133936.png]]

**debsums** служит, в первую очередь, для нахождения изменённых администратором файлов установленных в системе пакетов или повреждённых файлов из-за некачественного носителя и в какой-то мере используется в качестве инструмента обеспечения безопасности.
- `debsums -a` - Проверяет все файлы (включая конфигурационные, которые обычно располагаются слева)
- `debsums -e` - Проверяет только конфигурационные файлы пакетов
- `debsums -с` - Выводит список измененных файлов
- `debsums -I` - Отображает файлы, в которых отсутствует информация о **md5sum**
- `debsums -s` - Выводит только ошибки; при их отсутствии не производит никаких действий
- `debsums -ac coreutils` - запуск проверки
- `debsums -cs coreutils` - запуск проверки
  ![[Pasted image 20240715134454.png]]
  можно также проверить утилитой 
  ```
  dpkg --verify coreutils
	```

Если кто-то смог проникнуть в систему и что-то cделал в ней, нам поможет команда ё Например, если нам надо рассмотреть какой либо инцидент: 
```
sudo find / -printf "%T@;%Tc;%p\\n"
```
```
-prinf - то где мы будем искать
%T@ - время ввиде числа
%Tc - время человека читаемое
%p\\n - путь до файла
```
![[Pasted image 20240715134824.png]]
Далее если надо сделать по одному конкретному пользователю необходимо следующие:
``` 
sudo find /home/kali/ -printf "%T@;%Tc;%p\\n" > timeline.csv
```
```
sort -rn timeline.csv | less
```
![[Pasted image 20240715134959.png]]
Мы можем видеть, что менялось и в какое время, что позволит увидеть все изменения.

---

# Мониторинг OS Linux
![[Pasted image 20240714141746.png]]

---

## htop - информация о процессах в реальном времени. выводит данные о потреблении системных ресурсов, останавливает и управляет процессами
![[Pasted image 20240714222203.png]]
**В самом верху показана нагрузка на каждое ядро центрального процессора (цифры от 1 до 12).**
```
Mem — это общее количество оперативной памяти и используемая память.
Task — обобщённая статистика по процессам
Swp — уровень занятости файла подкачки (если он есть)
Load average — средняя загрузка центрального процессора
Uptime — время работы операционной системы с момента последней загрузки
```
**Теперь перейдём к области с информацией о запущенных процессах.**
Значение столбцов htop:
- PID - Идентификатор процесса.
- USER - Имя пользователя владельца процесса или ID если имя не может быть определено.
- PRI - Приоритет — внутренний приоритет ядра для процесса, обычно это просто значение nice плюс двадцать. Отличается для процессов имеющих приоритет выполнения real-time.
- NI - NICE значение процесса от `19` (низкий приоритет) до `-20` (высокий приоритет). Более высокое значение означает, что процесс «приятный» для других и позволяет им иметь более высокий приоритет выполнения.
- VIRT - Размер виртуальной памяти процесса (M_SIZE).
- RES - Размер резидентного набора (text + data + stack) процесса (т.е. размер используемой физической памяти процесса, M_RESIDENT).
- SHR - Размер общих страниц процесса (M_SHARE).
- S - STATE, состояние процесса, может быть:
  ```
	S для спящих (в простое)
	R для запущенных
	D для сна диска (бесперебойный)
	Z для зомби (ожидает родитель считает его статус выхода)
	T для отслеживания или приостановки (т. е. от SIGTSTP)
	W для подкачки
	```
- CPU% - Процент процессорного времени, которое процесс использует в данный момент.
- MEM% - Процент памяти, используемой процессом в данный момент (в зависимости от размера резидентной памяти процесса, см. M_RESIDENT выше).
- TIME+ - Время, измеренное в часах, указывает на то, сколько процесс провёл в пользовательском и системном времени.
- Command - Полная командная строка процесса (то есть имя программы и аргументы).

**Как ускорить или замедлить частоту обновления htop:**
- `-d [number]` - скорость обновления экрана в децисекундах (nubmer  = 10 = 1 сек)

**Как вывести процессы в виде дерева:**
- `-t` - вывод процессов в виде дерева

---
## w - работающие в системе в ближайшее время пользователи
![[Pasted image 20240714222135.png]]

- `-u` - игнорировать имена пользователей при определении времени текущего процесса и времени CPU.
- `-s` - сокращённый формат вывода. Не выводи колонки JCPU и PCPU.
- `-f` - включить или выключить поле `from`, соответствующее имени удалённого хоста (remote hostname). В зависимости от дистрибутива Linux (версии утилиты w), поле from может выводиться или не выводиться по умолчанию.
- `-i` - выводить в поле `from` IP-адрес вместо имени хоста, если это возможно.
- `-o` - выводить информацию в старом формате. Время, которое меньше 1 минуты, не выводится.
  ![[Pasted image 20240714222103.png]]
  

В таблице для каждого пользователя выводятся следующие поля:
```
USER — имя пользователя.
TTY — название терминала.
FROM — название удаленного компьютера или IP-адрес.
LOGIN — время входа в систему.
IDLE — время бездействия.
JCPU — время, использованное всеми процессами, подключенными к tty. Оно не включает завершенные фоновые задания, но включает фоновые задания, работающие в данный момент.
PCPU — время, использованное текущим процессом, который указан в поле WHAT.
WHAT — текущий процесс (командная строка текущего процесса).
```

---

## df - сведения о файловой системе

- `-a` `--all` - отобразить все файловые системы, в том числе виртуальные, псевдо и недоступные.
- `-h` - human-readable - выводит размер в степени 1024.
- `-i` – выводить информацию об inode;
- `-H` - выводит размер в степени 1000 (гигабайтах).
- `-l` - перечислить файловые системы.
- `-T` - выводит тип файловой системы.
  - `-t` `--type [TYPE]` - перечислить файловые системы конкретного типа.
  - `--exclude-type [TYPE]` - исключить файловые системы конкретного типа.
  - `-x` – выводить информацию обо всех, кроме указанных файловых систем;
- `–output` – использовать специальный формат вывода, если не задано, выводит все поля. Доступны такие варианты: ‘source’, ‘fstype’, ‘itotal’, ‘iused’, ‘iavail’, ‘ipcent’, ‘size’, ‘used’, ‘avail’, ‘pcent’, ‘file’ и ‘target’;
- `-P` – использовать формат вывода POSIX;
- `-–total` – выводить всю информацию про использованное и доступное место;



---

## du - сведения о дисковом пространстве

- `-a` - выводит весь объём всех файлов, а не только каталоги.
- `-b` - выводит действительные размеры в байтах.
- `-c` - выводит общую сумму указанных каталогов: total.
- `-s` - выводит только общий размер указанного каталога, а не подкаталогов.
- `--max-depth` - глубина погружения в каталоги.
- `-h` - human-readable.
- `--apparent-size` - выводит фактический объем данных в файле.

---

## free - сколько свободной оперативной памяти доступно и достаточно ли свободной памяти для установки и запуска новых приложений

- `-b` - отображает вывод в байтах.
- `-k` - в килобайтах.
- `-m` - в мегабайтах.
- `-g` - в гигабайтах.
- `-h` - human-readable.
- `-w` - переключение вывода в расширенный режим, который обеспечивает вывод более 80 символов в строке и разделяет столбец "buff/cache".
- `-t` - отображает строку total.
- `-s` `--seconds` - постоянно отображать информацию о памяти на экране.
  - `-c` - количество выводов на экран до прекращения. Пример: `free -s 5 -c 10`.

Что означает каждый столбец:
- **total** — это число представляет общий объем памяти, который может быть использован приложениями.
- **used** — Используемая память. Он рассчитывается как: used = total - free - buffers - cache
- **free** — Свободная / неиспользуемая память.
- **shared** — этот столбец можно игнорировать, поскольку он не имеет значения. Это здесь только для обратной совместимости.
- **buff / cache** — объединенная память, используемая буферами ядра, а также страничным кешем и блоками. Эта память может быть освобождена в любое время, если это необходимо приложениям.

---

## iostat - используется для мониторинга системной статистики ввода-вывода для устройств и разделов

- `-c` - отобразить только информацию об использовании процессора.
- `-d` - отобразить только информацию об использовании устройства.
- `-h` - human-readable.
- `-k` - вывести статистику в килобайтах.
- `-m` - вывести статистику в мегабайтах.
- `-o JSON` - выводить статистику в формате JSON;
- `-p` - вывести статистику по устройству и всем его разделам.
- `-x` - вывести расширенную статистику.
- `-y` - отображать статистику с момента запуска утилиты, а не системы.
- `-z` - спрятать информацию о дисках, у которых нет активности.

> Чтобы утилита автоматически обновляла данные каждую секунду просто добавьте интервал. Например: `sudo iostat -p /dev/nvme0n1 1`

В первой части отчёта находится информация о загруженности процессора. Тут есть такие колонки:
- **%user** - процент использования процессора программами, запущенными на уровне пользователя;
- **%nice** - процент использования процессора программами запущенными тоже в пространстве пользователя, но только с изменённым приоритетом;
- **%system** - процент использования процессора ядром;
- **%iowait** - процент времени затраченного на ожидание завершения операций ввода/вывода;
>  Если значение параметра %iowait слишком большое, то это может означать, что у вас проблема с производительностью диска и слишком много времени тратится на ожидание завершения ввода/вывода
- **%steal** - процент простоя виртуального процессора, пока гипервизор отдаёт мощность другому виртуальному процессору;
- **%idle** - процент времени пока процессор не занят ничем.

Для устройств ввода/вывода тоже отображается ряд колонок с информацией. Разберемся что они означают:
- **tps** - означает количество запросов на чтение или запись к устройству в секунду;
- **KB_read/s**, **MB_read/s** - количество килобайт или мегабайт, прочитанных с устройства за секунду;
- **KB_wrtn/s**, **MB_wrtn/s** - количество килобайт или мегабайт записанных на устройство в секунду;
- **KB_dscd/s**, **MB_dscd/s** - скорость освобождения блоков данных на устройстве, килобайт или мегабайт в секунду;
- **KB_read**, **MB_read** - общее количество прочитанных данных с диска с момента загрузки системы;
- **KB_wrtn**, **MB_wrtn** - количество записанных данных с момента загрузки системы;
- **KB_dscd**, **MB_dscd** - количество освобождённых блоков на диске в результате выполнения операции trim в килобайтах или мегабайтах.
  
  > Освобождение блоков с данными с помощью операции trim или discard актуально для SSD дисков. Этой операцией файловая система сообщает какие блоки больше хранить физически не нужно и можно использовать для других целей. Утилита отображает с какой скоростью эти блоки освобождаются, а также сколько блоков или мегабайт данных было освобождено.

---

## mpstat - вывод каждого имеющегося процесса

Утилита **mpstat** нужна для мониторинга производительности **Unix/Linux**.

**mpstat** — отчет о использовании процессоров. Команда **mpstat** пишет в стандартный вывод на экран о каждом имеющемся процессоре, 0-й процессор будет выведен на первое место. Параметр «**interval**» определяет количество времени в секундах между каждым отчетом. Значение 0 (или без параметров) показывает статистику о процессорах и отчетность будет представляться с момента запуска системы (загрузки).

- `-A` - показывает всю информацию, которая может быть отображена с помощью команды `mpstat` о процессоре.
  ![[Pasted image 20240714221210.png]]
- `-P ALL` - вывод всех индивидуальных процессоров или ядер со статистикой.
  ![[Pasted image 20240714221221.png]]
- `-P 0` - для отображения статистики о конкретном CPU или ядре.
  ![[Pasted image 20240714221248.png]]

---

## vmstat - статистическая информация об оперативной памяти, дисках, ядра, переключении контекста и процессорах.

![[Pasted image 20240714221320.png]]
Отчет команды vmstat содержит статистическую информацию о нитях ядра, находящихся в очереди выполнения и ожидающих запуска, а также об оперативной памяти, подкачке, дисках, прерываниях, системных вызовах, переключении контекста и работе процессора.

В информации о процессоре указывается доля времени, в течение которой процессор работал в пользовательском режиме, системном режиме, простаивал и ожидал завершения операции дискового ввода-вывода.

Для получения информации о работе процессора удобнее использовать команду vmstat, а не iostat, так как ее построчный вывод проще анализировать, а в случае, когда к системе подключено много дисков, ее вывод намного менее объемный. Приведенный ниже пример иллюстрирует применение vmstat для обнаружения программ, которые потребляют слишком много ресурсов CPU.

**`vmstat -a`**
(active/inactive memory) - активная/неактивная память
![[Pasted image 20240714221539.png]]

**`vmstat -f`**
(number of forks since boot) - количество задач с момента загрузки
![[Pasted image 20240714221636.png]]

**`vmstat -d`**
(disk statistics) - статистика диска
![[Pasted image 20240714221658.png]]

**`vmstat -D`**
(summarize disk statistics) - (общая статистика диска)
![[Pasted image 20240714221716.png]]

`vmstat [seconds]` - через какое количество секунд выводить информацию

---

# Логирование

Все команды, выполняемые через **`sudo`** логируются в **`/var/log/auth.log`**

---
# Cron - автоматически запуск

**Что это такое Cron?**

**Cron** – это планировщик заданий, который работает на **Unix**/**Linux** хостинге. Он позволяет автоматически выполнять определенные действия на сервере (запуск программ, скриптов и т.д.), с заданным временем или периодичностью.

Фактически, **Cron** - это сервис, как и большинство других сервисов **Linux**, он запускается при старте системы и работает в фоновом режиме. Его основная задача выполнять нужные процессы в нужное время. Существует несколько конфигурационных файлов, из которых он берет информацию о том что и когда нужно выполнять. Сервис открывает файл `/etc/crontab`, в котором указаны все нужные данные. Часто, в современных дистрибутивах там прописан запуск утилиты `run-parts`, которая запускает нужные скрипты из следующих папок:
- **`/etc/cron.minutely`** - каждую минуту;
- **`/etc/cron.hourly`** - каждый час;
- **`/etc/cron.daily`** - каждый день;
- **`/etc/cron.weekly`** - каждую неделю;
- **`/etc/cron.monthly`** - каждый месяц.

В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом. Скрипты должны иметь права на выполнение и их имя не должно содержать точки. Это очень сильно облегчает работу с планировщиком для новых пользователей. Также в файле `crontab` прописан запуск команды **anacron**, которая работает так же как и **cron**, только предназначена для задач, которые нужно выполнять раз в длительный период, например, раз в день, неделю, месяц, год.

Она позволяет выполнять их даже если компьютер работает не всегда и время от времени выключается. Дата выполнения задания последний раз записывается в файл `/var/spool/anacron`, а затем, при следующем запуске **anacron** проверяет был ли запущен нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис **cron** больше рассчитан на выполнение задач в течение дня или с точно расписанным временем и датой.

Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла **cron** и специальная команда. Конечно, вы всегда можете отредактировать файл `/etc/crontab`, но этого делать не рекомендуется. Вместо этого, есть команда **crontab**:
`$ crontab -e`.

Если вы хотите изменить **crontab**-файл другого пользователя, используйте команду `crontab -u username -e`.

Если вы хотите удалить текущий файл **crontab** текущего пользователя, введите следующую команду:
`crontab -r` или `crontab -i`, если нужно требовать подтверждение (yes).

Если вы хотите отобразить содержимое файла `crontab`, в который вы зашли, введите в терминале следующую команду:
`crontab -l`. 
Ещё одна операция этой команды позволяет посмотреть есть ли у вас **crontab**-файлы. Просто введите `crontab -l`.

`crontab` всегда желательно выполнять с опцией `-e`, тогда для редактирования правил будет использован ваш текстовый редактор по умолчанию. Команда открывает вам временный файл, в котором уже представлены все текущие правила **cron** и вы можете добавить новые. При первом запуске вам будет предложено выбрать желаемый текстовый редактор (**nano**, **vim**).
![[Pasted image 20240716084039.png]]
Где
![[Pasted image 20240716084048.png]]
Чтобы стало понятнее, давайте разберем на примере. Создадим инструкцию на выполнение скрипта `/usr/local/bin/script.sh` (cкрипт выводит в терминал сообщение) `каждую среду в 15 часов 30 минут`:

```html
30 15 * * 3 /usr/local/bin/script.sh
```
`ПРИМЕЧАНИЕ названия дней от 0-6 начинаются с воскресенья.`

Символ `*` означает что инструкция выполняется во все возможные значения аргумента. В нашем случае `каждую тридцатую минуту пятнадцатого часа во все дни и все месяцы, которые являются третьим днем недели (то есть средой)`. Можно писать сокращенное название дня недели вместо его порядкового номера, например `sun` - воскресенье.

Для того чтобы указать определенный интервал нужно использовать символ "`-`", например, каждый час, с семи утра до семи вечера:
```html
0 7-19  * * * /usr/local/bin/script.sh
```

Если нужно запустить команду несколько раз, можно использовать разделитель "`,`". Например, запустим скрипт в 5 и 35 минут пятого (16:05 и 16:35), каждый день:

```html
5,35 16  * * * /usr/local/bin/script.sh
```

Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым нужно запускать скрипт, например, `раз в 10 минут`. Для этого используется разделитель косая черта - "`/`":
```html
*/10 * * * * /usr/local/bin/script.sh
```

Кроме того, для некоторых часто используемых наборов были придуманы переменные, вот они:

**@reboot** - при загрузке, только один раз;
**@yearly, @annually** - раз год;
**@monthly** - раз в месяц;
**@weekly** - раз в неделю;
**@daily, @midnight** - каждый день;
**@hourly** - каждый час.

Например, вот так просто будет выглядеть команда запуска скрипта `раз в час`:
```html
@hourly /usr/local/bin/script.sh
```

После завершения работы команды **cron** файл будет обработан и все правила будут добавлены в `/var/spool/cron/crontabs/имя_пользователя` причем добавленные процессы будут запускаться именно от того пользователя, от которого вы их добавляли.

Поэтому тут нужно быть аккуратным, и если вам нужно выполнять скрипты от рута, то и **crontab** нужно выполнить от рута, а не от пользователя. Это часто становится причиной проблем.

Можно посмотреть задачи **cron** для суперпользователя, для этого можно воспользоваться опцией `-l`:
`$ crontab -l`

Вы можете удалить все существующие задачи командой `-r`:
`$ crontab -r`

#### Разница между сron, сrontab и сron Job

Визуальный взгляд на вещи помогает быстрее понять новые темы. Вот разбивка того, как эти три темы обычно взаимодействуют. Затем я опишу каждый более подробно.
- Daemon (Демон) ‘crond’ Произносится «demon» или «day-mon». Это фоновые системные процессы Linux.
- Table (Таблица) ‘crontab’ Вы записываете строки в эту таблицу при вводе команды crontab. Каждая звездочка «\*» представляет отрезок времени и соответствующий столбец в каждой строке.
- Job (Задача) Cron Job Конкретная задача, которая должна быть выполнена, описана в строке в сочетании с назначенным ей идентификатором времени

**Таблица Cron**

**Crontab** означает **Cron Table**. Это системный файл **Linux**, который создает табличную структуру, в которой поля разделяются пробелами. Пользователи могут заполнять таблицу, присваивая значения каждому полю (звездочка).

Если это поможет, вы можете думать о вашем **crontab** как о мини-базе данных.

**Cron Job**

Если вы не знакомы с базами данных, вы можете представить ячейки в пустом файле **Excel**. В любом случае, для этой аналогии каждая звездочка представляет столбец, значение которого определяется его заголовком. Последний столбец будет вызовом команды или сценария. Каждый полный ряд можно рассматривать как отдельную работу. Их часто называют “**cron jobs**”, хотя работа, задание и т. д. являются взаимозаменяемыми терминами.

#### Некоторые особенности cron

_Утилита обладает рядом особенностей, которые необходимо учитывать при работе с ней и составлении описаний регулярных действий:_

- Минимальное время составляет одну минуту.
- Файл crontab должен всегда заканчиваться пустой строкой
- Условия времени запуска «день недели» и «день месяца» обрабатываются через логическую операцию «ИЛИ», все остальные условия — через логическое «И».
- Выводы запускаемых команд выводятся в виде сообщений пользователю, но если в файле `crontab` была определена директива **MAILTO** – сообщение будет отправлено по указанному в этой директиве **e-mail**.

---

# Управление файловой системой

Узнать тип файловой системы:
``` 
file -sL /dev/sda
```
- `/dev` - каталог, содержащий диски

---

## Утилиты для работы с ФС

---

### fdisk - создавать, удалять, изменять, копировать и перемещать разделы на жёстком диске

**fdisk** (сокращение от “**format disk**“, форматировать диск) — это наиболее распространенная утилита командной строки для работы с дисками в **Linux/Unix** системах.

При помощи этой команды можно просматривать, **создавать, удалять, изменять, копировать** и **перемещать** разделы на жёстком диске. Для просмотра всех доступных разделов используется опция `-l` (**listing** — перечисление). Разделы перечисляются по именам, например, **`/dev/sda`**, **`/dev/sdb`** или **`/dev/sdc`**.

![[Pasted image 20240718173237.png]]

Большинство операций **fdisk** по разметке дисков выполняются в интерактивном режиме. Чтобы запустить **fdisk** в интерактивном режиме выполните команду **fdisk** «диск», например: ![[Pasted image 20240718173323.png]]

После этого вы попадете в меню, опции которого можно посмотреть выполнив команду `m`. Вот основные из них: ![[Pasted image 20240718173339.png]]
![[Pasted image 20240718190729.png]]
![[Pasted image 20240718190631.png]]
**Перевод команд:**
- `a` — сделать диск загрузочным
- `b` — редактировать bsd-метку диска
- `c` — установить флаг совместимости с DOS
- `d` — удалить раздел
- `l` — перечислить известные типы разделов
- `m` — вывести это меню
- `n` — создать новый раздел
- `o` — создать новую пустую таблицу разделов DOS
- `p` — вывести таблицу разделов (аналогична fdisk -l)
- `q` — выйти без сохранения
- `s` — создать новую метку диска Sun
- `t` — изменить системный идентификатор раздела
- `u` — изменить единицы отображения/ввода
- `v` — проверить таблицу разделов
- `w` — записать таблицу на диск и выйти
- `x` — дополнительные функции (только для экспертов)

**При создании нового раздела (`n`) нужно выбрать одну из двух опций:**

- extended для логического раздела
- primary для первичного

---

### dd - создать диск

Создать новый диск:
```
sudo dd if=/dev/zero of=/disk.img count=2000 bs=1M
```
![[Pasted image 20240718173621.png]]
- **if** = источник (в примере поток нулей)
- **of** = место назначения
- **count** = число блоков для копирования
- **bs** = размер одного блока

---

### mkfs - создать файловую систему

Затем создадим файловую систему **ext4**. Делается это с помощью команды **mkfs**:
```
sudo mkfs -t ext -L root /disk.img
```
![[Pasted image 20240718173850.png]]
- **`-t ext4`** – указываем какую ФС создаем
- **`-L root`** – создаем метку
- **`/disk.img`** – путь к диску, обычно в виде `/dev/sda`

---

### fsck - проверить исправность файловой системы

``` 
sudo fsck /disk.img
```
![[Pasted image 20240718174219.png]]
_Обратите внимание, диск должен быть не примонтирован._

fsck можно применять со следующими опциями:
![[Pasted image 20240718174333.png]]

---

### 2label - смотреть и изменять метку

Смотреть текущую метку:
``` 
sudo e2label /disk.img
```
Изменить метку:
```
sudo e2label /disk.img root1
```
![[Pasted image 20240718174457.png]]

---

### blkid - посмотреть uuid для разделов

`sudo blkid`

`[устройство] [точка_монтирования] [файловая_система] [опции резерв{0,1}] [проверка{0,1,2}]`

**Теперь подробнее рассмотрим что означает каждый пункт:**

- `Устройство` - это раздел диска, который вам нужно примонтировать. Его можно указать в формате файла устройства Linux в каталоге `/dev/`, например, `/dev/sda1` или с помощью уникального идентификатора **UUID**, тогда формат записи будет таким **UUID**="**XXXX-XXXX-XXXX-XXXX**", также возможна запись с помощью метки, например, **LABEL=home**;
- Файловая система указывает в какой файловой системе нужно монтировать это устройство, например, **ext4**, **ext3**, **ext2**, **btrfs**;
- Точка монтирования - куда нужно примонтировать это устройство, например, `/home`, `/boot`, `/mnt`;
- `Опции` - параметры монтирования файловой системы, рассмотрим подробнее чуть позже;
- `Проверка` - указывает в какой очереди нужно проверять устройство на ошибки, `1` - в первую очередь, `2` - вторую, `0` - не проверять;
- `Резерв` - указывает нужно ли делать резервную копию раздела, может принимать значения только `0` и `1`.

Опции монтирования **fstab**. Для разных файловых систем они могут немного отличаться, но есть стандартные. И поскольку чаще всего используются файловые системы семейства **ext**, то мы будем ориентироваться на них.

**Начнем с общих для всех файловых систем опций:**

- `sync` - записывать на диск все изменения сразу после того, как они были выполнены, не использовать кэширование для записываемых данных. Может понадобится для извлечения флешки без размонтирования, но сильно снижает производительность;
- `async` - использовать кэш при записи данных, увеличивает производительность, используется по умолчанию;
- `atime` - сохранять время последнего доступа к файлу;
- `noatime` - не сохранять время последнего доступа, полезно для ssd и флешек;
- `relatime` - обновлять время доступа только при изменении файла, необходимо для работы многих программ;
- `norelatime` - отключить relatime;
- `strictatime` - обновлять время доступа всегда, отключает действие предыдущих опций;
- `auto` - автоматически монтировать при загрузке, действие по умолчанию;
- `noauto` - не монтировать при загрузке;
- `defaults` - использовать опции монтирования fstab по умолчанию - rw,suid,dev,exec,auto,nouser,async;
- `dev` - интерпретировать блочные устройства;
- `nodev` - не интерпретировать блочные устройства;
- `diratime` - аналогично atime только для каталогов;
- `dirnoatime` - аналогично noatime, для каталогов;
- `exec` - разрешить выполнять программы на этом разделе;
- `noexec` - запретить выполнять программы на этом разделе;
- group - разрешить другим пользователям кроме root монтировать этот раздел, если их группа совпадает с указанной, обычно используется вместе с noauto;
- `nofail` - не сообщать об ошибках;
- `mand` - разрешить блокирование файловой системы, нужно для некоторых антивирусов;
- `nomand` - запретить блокирование файловой системы;
- `suid` - разрешить выполнение программ с флагом suid от имени другого пользователя;
- `nosuid` - игнорировать флаг suid;
- `owner` - разрешить указанному пользователю монтировать устройство;
- `ro` - монтировать только для чтения;
- `rw` - монтировать для чтения и записи;
- `users` - разрешить монтирование любому пользователю;
- `umask` - установить права доступа к файлам и папкам на этом разделе;
- `uid` - задает владельца каталога, по умолчанию root;
- `gid` - задает группу владельца каталога.


---

### tune2fs - настройка характеристик файловой системы

Различные параметры файловой системы, такие как **размер блока данных**, **inode**-ы (структура данных в которой хранится информация о файле или директории в файловой системе) **UUID**, **метку** и многое другое можно настроить. Поможет в этом утилита **tune2fs**. Давайте, к примеру, с её помощью изменим зарезервированное место под данные пользователя **root** на 5% от дискового пространства.
```
sudo tune2fs -m /disk.img
```
![[Pasted image 20240718174906.png]]

- `-l` - посмотреть всю доступную информацию о параметрах файловой системы:
  ![[Pasted image 20240718175018.png]]

**Другие опции команды tune2fs:**
![[Pasted image 20240718175100.png]]

---

### resize2fs - изменение размера файловой системы Linux

В качестве аргументов принимает диск и желаемый размер.
```
sudo resize2fs /disk.img 2400M
``` 
![[Pasted image 20240718175256.png]]![[Pasted image 20240718175329.png]]

---

### e4defrag - дефрагментация

В качестве аргумента укажите диск, который желаете фрагментировать. В нашем случае команда будет выглядеть так:
``` 
sudo e4defrag /disk.img
```
![[Pasted image 20240718175426.png]]

Чтобы проверить нужна ли дефрагментация выполните эту же команду с опцией `-c`.

---

## Монтирование и типы монтирования ФС

Монтированием в **Linux** называется подключение диска, раздела, каталога или файла в корневую файловую систему. Суть монтирования в том, что в файловой системе создаётся новая директория (обычная папка), допустим, это папка `/mnt/disk`. А затем командой `mount` указывается, что теперь диск, к примеру `/dev/sda`, смонтирован в директорию `/mnt/disk`. После этого можно получить доступ к файлам диска `/dev/sda` открыв папку `/mnt/disk` в любом менеджере файлов, то есть` /mnt/disk` (точка монтирования) становится корневой директорией смонтированной ФС.

---

### findmnt -–real - просмотр текущих точек монтирования
```
findmnt --real
```
![[Pasted image 20240718175724.png]]

---

### mount - монтирование

Монтирование осуществляется с помощью утилиты `mount`. Для подключения файловой системы к конкретному местоположению (точке монтирования) команда `mount` используется в следующей форме:
```
mount [опции...] имя_устройства директория
```
_В качестве устройства можно также указать файл образа._

Смонтировать `/dev/sda1` в директорию `/mnt` можно следующим образом (добавив опцию `–v` мы увидим информацию о процессе):
```
sudo mount -v /dev/sda1 /mnt
```
![[Pasted image 20240718180007.png]]

**Основные опции команды mount:**
![[Pasted image 20240718180048.png]]
**Более полный список:**
Далее "раздел" = " корень файловой система/файловая система".
- `-V` - вывести версию утилиты;
- `-h` - вывести справку;
- `-v` - подробный режим;
- `-a`, `--all` - примонтировать все устройства, описанные в **fstab**;
- `-F`, `--fork` - создавать отдельный экземпляр **mount** для каждого отдельного раздела;
- `-f`, `--fake` - не выполнять никаких действий, а только посмотреть что собирается делать утилита;
- `-n`, `--no-mtab` - не записывать данные о монтировании в /etc/mtab;
- `-l`, `--show-labels` - добавить метку диска к точке монтирования;
- `-c` - использовать только абсолютные пути;
- `-r`, `--read-only` - монтировать раздел только для чтения;
- `-w`, `--rw` - монтировать для чтения и записи;
- `-L`, `--label` - монтировать раздел по метке;
- `-U`, `--uuid` - монтировать раздел по UUID;
- `-T`, `--fstab` - использовать альтернативный fstab;
- `-B`, `--bind` - монтировать локальную папку;
- `-R`, `--rbind` - перемонтировать локальную папку.

**Для размонтирования диска** используется команда `umount`, которой можно передать либо точку монтирования, либо устройство. Размонтирование устройства `/dev/hdb1` с точкой монитрования `/mnt` выглядит так:
```
umount /mnt
```
или
```
umount /dev/hdb1
```

---

### hdparm - права записи на устройство

Утилита **hdparm** позволяет установить устройству флаг **read-only**. Когда флаг установлен на `1`, Linux не разрешает операции записи на устройство.
![[Pasted image 20240718180611.png]]

