# Введение в MySQL

---

## Создание БД и таблиц

**Подключиться к БД MySQL:**
```bash
mysql -u root -p{password}
```
- `-h {Remote_Host}`
- `-P {Port}` - По умолчанию используется порт MySQL/MariaDB (3306)

**Управление базой данных:**
```SQL
mysql> CREATE DATABASE users;

mysql> SHOW DATABASES;

+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| users              |
+--------------------+

mysql> USE users;

Database changed
```
- SQL-операторы не чувствительны к регистру, что означает, что «`USE users`» и «`use users`» относятся к одной и той же команде.

**Создание таблицы:**
```SQL
mysql> CREATE TABLE logins (
    ->     id INT,
    ->     username VARCHAR(100),
    ->     password VARCHAR(100),
    ->     date_of_joining DATETIME
    ->     );
Query OK, 0 rows affected (0.03 sec)
```

C помощью `SHOW TABLES` можно получить список таблиц в текущей базе данных. 
**Показ таблиц:**
```SQL
mysql> SHOW TABLES;

+-----------------+
| Tables_in_users |
+-----------------+
| logins          |
+-----------------+
1 row in set (0.00 sec)
```

**Кроме того, ключевое слово [DESCRIBE](https://dev.mysql.com/doc/refman/8.0/en/describe.html) используется для перечисления структуры таблицы с ее полями и типами данных:**
```sql
mysql> DESCRIBE logins;

+-----------------+--------------+
| Field           | Type         |
+-----------------+--------------+
| id              | int          |
| username        | varchar(100) |
| password        | varchar(100) |
| date_of_joining | date         |
+-----------------+--------------+
4 rows in set (0.00 sec)
```

---

## Настройка столбцов

В запросе `CREATE TABLE` есть много [свойств](https://dev.mysql.com/doc/refman/8.0/en/create-table.html), которые можно задать для таблицы и каждого столбца. Например, мы можем настроить автоматическое увеличение столбца с помощью ключевого слова `AUTO_INCREMENT`, которое автоматически увеличивает id на единицу каждый раз, когда новый элемент добавляется в таблицу.
```sql
	  id INT NOT NULL AUTO_INCREMENT,
```
```sql
	username VARCHAR(100) UNIQUE NOT NULL,
```
```sql
	date_of_joining DATETIME DEFAULT NOW(),
```

Наконец, одним из наиболее важных свойств является `PRIMARY KEY`, которое мы можем использовать для уникальной идентификации каждой записи в таблице, ссылаясь на все данные записи в таблице реляционных баз данных. Мы можем сделать столбец `id` для `PRIMARY KEY`. Итоговый запрос `CREATE TABLE` будет выглядеть следующим образом:
```sql
CREATE TABLE logins (
    id INT NOT NULL AUTO_INCREMENT,
    username VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(100) NOT NULL,
    date_of_joining DATETIME DEFAULT NOW(),
    PRIMARY KEY (id)
    );
```

---

# Операторы SQL

---

## Первоочерёдные операторы

---

### INSERT INTO

Инструкция [INSERT](https://dev.mysql.com/doc/refman/8.0/en/insert.html) используется для добавления новых записей в заданную таблицу. Утверждение в соответствии с приведенным ниже синтаксисом:
```sql
INSERT INTO table_name VALUES (column1_value, column2_value, column3_value, ...);
```
Приведенный выше синтаксис требует, чтобы пользователь заполнил значения для всех столбцов, присутствующих в таблице.
```sql
mysql> INSERT INTO logins VALUES(1, 'admin', 'p@ssw0rd', '2020-07-02');

Query OK, 1 row affected (0.00 sec)
```

В приведенном выше примере показано, как добавить новую учетную запись в таблицу учетных записей с соответствующими значениями для каждого столбца. Однако мы можем пропустить заполнение столбцов значениями по умолчанию, такими как `id` и `date_of_joining`. Это можно сделать, указав имена столбцов для выборочной вставки значений в таблицу:
```sql
INSERT INTO table_name(column2, column3, ...) VALUES (column2_value, column3_value, ...);
```


>[!Note]
> Пропуск столбцов с ограничением 'NOT NULL' приведет к ошибке, так как это обязательное значение.

То же самое мы можем сделать для вставки значений в таблицу `logins`:
```sql
mysql> INSERT INTO logins(username, password) VALUES('administrator', 'adm1n_p@ss');

Query OK, 1 row affected (0.00 sec)
```
В приведенном выше примере мы вставили пару имя пользователя и пароль, пропустив столбцы `id` и `date_of_joining`.

>[!Note] 
>В примерах пароли в открытом виде вставляются в таблицу только для демонстрации. Это плохая практика, так как пароли всегда должны быть хэшированы/зашифрованы перед хранением.

Мы также можем вставить сразу несколько записей, разделив их запятой:
```sql
mysql> INSERT INTO logins(username, password) VALUES ('john', 'john123!'), ('tom', 'tom123!');

Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

В приведенном выше запросе вставлены сразу две новые записи.

---

### Оператор SELECT

```sql
SELECT * FROM table_name;
```
```sql
SELECT column1, column2 FROM table_name;
```

---

### Оператор DROP

Мы можем использовать [DROP](https://dev.mysql.com/doc/refman/8.0/en/drop-table.html) для удаления таблиц и баз данных с сервера.

  Операторы SQL

```sql
mysql> DROP TABLE logins;

Query OK, 0 rows affected (0.01 sec)


mysql> SHOW TABLES;

Empty set (0.00 sec)
```
Как мы видим, таблица была удалена полностью.
>[!Warning] 
>Оператор 'DROP' навсегда и полностью удалит таблицу без подтверждения, поэтому его следует использовать с осторожностью.

---

### Оператор ALTER - редактирование

Мы можем использовать [ALTER](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html) для изменения имени любой таблицы и любого из ее полей, а также для удаления или добавления нового столбца в существующую таблицу. В приведенном ниже примере добавляется новый столбец `newColumn` в таблицу `logins` с помощью `ADD`:
```sql
mysql> ALTER TABLE logins ADD newColumn INT;

Query OK, 0 rows affected (0.01 sec)
```

Чтобы переименовать столбец, мы можем использовать `RENAME COLUMN`:
```sql
mysql> ALTER TABLE logins RENAME COLUMN newColumn TO newerColumn;

Query OK, 0 rows affected (0.01 sec)
```

Мы также можем изменить тип данных столбца с помощью `MODIFY`:
```sql
mysql> ALTER TABLE logins MODIFY newerColumn DATE;

Query OK, 0 rows affected (0.01 sec)
```

Наконец, мы можем удалить столбец с помощью `DROP`:
```shell-session
mysql> ALTER TABLE logins DROP newerColumn;

Query OK, 0 rows affected (0.01 sec)
```

Мы можем использовать любое из приведенных выше утверждений с любой существующей таблицей, если у нас достаточно привилегий для этого.

---

### Оператор UPDATE

Хотя инструкция `ALTER` используется для изменения свойств таблицы, [UPDATE](https://dev.mysql.com/doc/refman/8.0/en/update.html) можно использовать для обновления определенных записей в таблице в зависимости от определенных условий. Его общий синтаксис таков:
```sql
UPDATE table_name SET column1=newvalue1, column2=newvalue2, ... WHERE <condition>;
```
Указываем имя таблицы, каждый столбец и его новое значение, а также условим обновления записей. Рассмотрим пример:
```sql
mysql> UPDATE logins SET password = 'change_password' WHERE id > 1;

Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0


mysql> SELECT * FROM logins;

+----+---------------+-----------------+---------------------+
| id | username      | password        | date_of_joining     |
+----+---------------+-----------------+---------------------+
|  1 | admin         | p@ssw0rd        | 2020-07-02 00:00:00 |
|  2 | administrator | change_password | 2020-07-02 11:30:50 |
|  3 | john          | change_password | 2020-07-02 11:47:16 |
|  4 | tom           | change_password | 2020-07-02 11:47:16 |
+----+---------------+-----------------+---------------------+
4 rows in set (0.00 sec)
```
Приведенный выше запрос обновил все пароли во всех записях, где id был значителен больше 1.

>[!Note]
>Мы должны указать предложение 'WHERE' с помощью UPDATE, чтобы указать, какие записи будут обновлены. Далее будет рассмотрен пункт 'WHERE'.

---

## Второстепенные операторы

---

### Оператор ORDER BY - сортировка

Мы можем отсортировать результаты любого запроса с помощью [ORDER BY](https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html) и указания столбца для сортировки:
```sql
mysql> SELECT * FROM logins ORDER BY password;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+
4 rows in set (0.00 sec)
```
По умолчанию сортировка выполняется в порядке возрастания, но мы также можем отсортировать результаты по `ASC` или `DESC`:
```sql
mysql> SELECT * FROM logins ORDER BY password DESC;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
+----+---------------+------------+---------------------+
4 rows in set (0.00 sec)
```
Также есть возможность сортировки по нескольким столбцам, чтобы иметь вторичную сортировку по повторяющимся значениям в одном столбце:
```sql
mysql> SELECT * FROM logins ORDER BY password DESC, id ASC;

+----+---------------+-----------------+---------------------+
| id | username      | password        | date_of_joining     |
+----+---------------+-----------------+---------------------+
|  1 | admin         | p@ssw0rd        | 2020-07-02 00:00:00 |
|  2 | administrator | change_password | 2020-07-02 11:30:50 |
|  3 | john          | change_password | 2020-07-02 11:47:16 |
|  4 | tom           | change_password | 2020-07-02 11:50:20 |
+----+---------------+-----------------+---------------------+
4 rows in set (0.00 sec)
```

---

### Оператор LIMIT

В случае, если наш запрос возвращает большое количество записей, мы можем ограничить результаты только тем, что нам нужно и тем количеством записей, которое мы хотим, используя [LIMIT](https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html):
```sql
mysql> SELECT * FROM logins LIMIT 2;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
+----+---------------+------------+---------------------+
2 rows in set (0.00 sec)
```
Если бы мы хотели ограничить результаты со смещением, мы могли бы указать смещение перед счетчиком LIMIT:
```sql
mysql> SELECT * FROM logins LIMIT 1, 2;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+
2 rows in set (0.00 sec)
```

>[!Note]
>Смещение отмечает порядок включения первой записи, начиная с 0. Для вышеуказанного он запускает и включает в себя 2-ю запись, и возвращает два значения.

---

### Оператор WHERE

Для фильтрации или поиска конкретных данных мы можем использовать условия с оператором `SELECT` с помощью оператора [WHERE](https://dev.mysql.com/doc/refman/8.0/en/where-optimization.html), чтобы тонко настроить результаты:
```sql
SELECT * FROM table_name WHERE <condition>;
```
Приведенный выше запрос вернет все записи, удовлетворяющие заданному условию. Рассмотрим пример:
```sql
mysql> SELECT * FROM logins WHERE id > 1;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+
3 rows in set (0.00 sec)
```
В приведенном выше примере выбираются все записи, в которых значение `id` больше `1`. Как мы видим, первая строка с значением `id` 1 была пропущена из вывода. Мы можем сделать нечто подобное для имен пользователей:
```sql
mysql> SELECT * FROM logins where username = 'admin';

+----+----------+----------+---------------------+
| id | username | password | date_of_joining     |
+----+----------+----------+---------------------+
|  1 | admin    | p@ssw0rd | 2020-07-02 00:00:00 |
+----+----------+----------+---------------------+
1 row in set (0.00 sec)
```
В приведенном выше запросе выбирается запись, в которой имя пользователя имеет значение `admin`. Мы можем использовать инструкцию `UPDATE` для обновления определенных записей, которые удовлетворяют определенному условию.

>[!Note]
>Строковые типы данных и типы данных даты должны быть заключены в одинарные кавычки (') или двойные кавычки ("), в то время как числа могут использоваться напрямую.

---

### Оператор LIKE

Еще одним полезным SQL-оператором является [LIKE](https://dev.mysql.com/doc/refman/8.0/en/pattern-matching.html), позволяющий выбирать записи по определенному шаблону. Приведенный ниже запрос извлекает все записи с именами пользователей, начинающимися с `admin`:
```sql
mysql> SELECT * FROM logins WHERE username LIKE 'admin%';

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  4 | administrator | adm1n_p@ss | 2020-07-02 15:19:02 |
+----+---------------+------------+---------------------+
2 rows in set (0.00 sec)
```
Символ `%` действует как регулярное выражение и соответствует всем символам после `admin`. Он используется для сопоставления нуля или более символов. Точно так же символ `_` используется для сопоставления ровно одного символа. Приведенный ниже запрос сопоставляет все имена пользователей с ровно тремя символами в них, которые в данном случае будет `tom`:
```sql
mysql> SELECT * FROM logins WHERE username like '___';

+----+----------+----------+---------------------+
| id | username | password | date_of_joining     |
+----+----------+----------+---------------------+
|  3 | tom      | tom123!  | 2020-07-02 15:18:56 |
+----+----------+----------+---------------------+
1 row in set (0.01 sec)
```