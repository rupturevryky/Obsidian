***
### Сканирование сети
![[План сканирвоания.png]]
***
<div style="background-color: 3d82ed ">
<li style="padding:10px"><b>Sweeping</b> - сканирется конечное количество портов, именно тот список, который был составлен (может запускать на целый сегмет, а можем и на какие-то конкретные IP-адреса, все зависит от того как определен скоуп).

<details style="background-color: 3d82ed; padding:10px">
    <summary style="cursor: pointer">Подробней</summary>
        Это означает, что на каждый ip будет отправлено только фиксированное количество запросов на конкретный порт, то есть не будут просмотрены все 65к портов на открытость/закрытость, на работу каких-то отдельных сервисов на хосте, все это будет просто отправлено в единичном формате.
</details>
<div style="background-color: 3d82ed; margin-top: 10 ">
<li style="padding:10px"><b>Port Scan</b> - это процесс, когда выполняется сканирование по всем возможным портам, которые позволяет открывать операционная система, то есть 65535 портов которые есть на хосте.
<details style="background-color: 3d82ed; padding:10px">
		<summary style="cursor: pointer">Подробней</summary>
    Все 65535 портов сканируются последовательно или с какой-то закономерностью чтобы покрыть весь этот диапазон -> такое сканирование производится намного дольше, это сканирование применяется тогда, когда есть уверенность, что на хосте могут быть открытые порты, но <b>нет никакой информации о текущей базовой системе исследования, нет понимания того какие сервисы там могут быть развёрнуты</b>, только тогда проводится такой тип сканирования, там необходимо сделать определенные допущения: все это будет растягивать время и только отодвигать процесс создания репорта, то есть оттягивать то ради чего все это и затевалось.
</details >

<div style="background-color: 3d82ed; margin-top: 10 ">
<li style="padding:10px"><b>OS Fingerprint</b> - это определение по результатам сканирования того, какая операционная система работает на хосте.
<details style="background-color: 3d82ed; padding:10px">
    <summary style="cursor: pointer">Подробней</summary>
        Иногда для оптимизации применяют различные методики - по известным портам отправляются сообщения, эти сообщения обрабатываются хостом и на основании ответов делается вывод - стоит какая-то операционная система. Тут же отправка сообщений, которые точно выведут предсказуемое поведение операционной системы у того или иного хоста, после этого все это записывается и дальше идут обработки всех данных которые были получены на предыдущих шагах. После того как выясняется какая стоит ОС мы переходим к Version Scan.
</details>

<div style="background-color: 3d82ed; margin-top: 10 ">
<li style="padding:10px"><b>Version Scan</b> - сканирование сервисов для определения какие именно версии работают на хосте.
<details style="background-color: 3d82ed; padding:10px">
    <summary  style="cursor: pointer">Подробней</summary>
        Это очень важно, т.к чаще всего найденные уязвимости относятся именно к версиям программы, операционной системы и т.д. -> это все в дальнейшем и влияет на поиск самих уязвимостей. Это нужно автоматизировать, как-то упростить, что нужно просить у огромной системы.
</details>

<div style="background-color: 3d82ed; margin-top: 10 ">
<li style="padding:10px"><b>Vuln Scan</b> - теперь после того как определены все версии нужно протестировать систему – то есть использовать сканеры уязвимостей.
<details style="background-color: 3d82ed; padding:10px">
    <summary  style="cursor: pointer">Подробней</summary>
        Сканеры уязвимостей рассматриваются как отдельные продукты, но так как мы рассматриваем nmap, будем говорить о нем больше всех, у него есть возможность проверить эти самые уязвимости. Сканеры знают какие данные нужно отправить приложению или ОС чтобы она ответила как уязвимая система. Это прописывается в отдельные скрипты или БД, которая содержится, например, в nmap и дальше анализируется и, если система уязвима, значит ей можно дальше воспользоваться.
</details>

***
### **Порты**

Порты могут быть не только открытыми или закрытыми. Из-за особенностей передачи пакетов и ответов на них разными протоколами для более точного определения состояния исследуемой цели nmap выделяет шесть состояний портов, их надо знать для понимания полученных результатов сканирования:

|Статус|Значение|
|---|---|
|открыт/open|Приложение принимает на порт пакет или запросы на соединение.|
|закрыт/closed|Порт отвечает на запросы, но не используется никаким приложением.|
|фильтруется/filtered|Запросы не доходят до этого порта, а значит, невозможно определить, открыт он или нет.|
|не фильтруется/unfiltered|Порт доступен, но Nmap не может определить, закрыт он или открыт. Как правило, помогает использование другого способа сканирования.|
|открыт-фильтруется / open-filtered|Не получается определить, открыт порт или фильтруется. Возникает, если открытый порт не отвечает. Как правило, помогает использование другого способа сканирования.|
|закрыт-фильтруется/closed-filtered|Не получается определить, закрыт порт или фильтруется. Как правило, помогает использование другого способа сканиров|
***
### [[Nmap]]
***
### Типы сканирований и протоколы
![[Типы сканирований и протоколы.png]]
<ol style=" margin-top: 10; color: #fff">
	<li style="padding:10px; background-color: 3d82ed;"><b>Full TCP</b> - используются все стандартные механизмы и ничего не переиначивается, применяется процесс трехпарного рукопожатия, когда отправляются в определенной последовательности биты управления, состояния и соединения, эти 3 пакета обязаны полететь, делается это с помощью стандартных тулз которые есть в ОС, есть такая функция в любых ОС которая называется connect – это означает, что ОС, где запускается сканер, открывает соединение с целевым хостом и начинается отправка данных, но тут же все закрывается. Тем самым оно 100% удостоверяется, что целевая система действительно имеет открытый порт и там находятся какие-то сервисы, более точного способа сканирования не существует. Но т.к существуют фаерволы и системы которые мониторят несанкционированное поведение сети, то были придуманы еще дополнительные типы сканирований.
	<li style="padding:10px; margin-top: 10; background-color: 3d82ed;"><b>Stealth TCP</b> - скрытое сканирование. Это сканирования от имени IP, который вам был назначен с вашим MAC - адресом. в Half-Open производятся небольшие видоизменения взаимодействия по протоколу, то есть полуоткрытые соединения, идет запрос на соединение, соединение открывается хостом сервер не понимает и отправляет хосту специальные запросы под его протокол и nmap уже понимает исходя из этого открыто там или закрыто.
	<ol>
		<li> <b>Inverse TCP</b>
			<p>Теперь про <b>Inverse TCP</b> – обратное сканирование это как раз то, что мы рассматривали у <b>XMAS</b> и <b>FIN</b>.
		</li>
			<ol>
				<li> <b>NULL Scan</b>
					<p>Но есть еще дополнительно <b>NULL Scan</b> – это когда не стоит вообще никаких флагов пакет просто отправляется в целевую систему, не устанавливаются никакие биты (Флагов в TCP заголовке 0).
				</li>
			</ol>
		<li> <b>ACK Probe</b> – это запрос соединения от всех ОС которые работают в исследуемой сети..
		</li>
	</ol>
	<li style="padding:10px; margin-top: 10; background-color: 3d82ed;"><b>Spoofed TCP</b> - сканирование от имени других хостов. То есть протоколы внутри TCP,
	которые находятся вместе с TCP в стеке, при которых можно подменить свой адрес и сканировать от чужого имени, а можно заставлять другие хосты сканировать за вас.
	<details style="background-color: 3d82ed; padding:10px">
	    <summary  style="cursor: pointer">Подробней</summary>
	        Единственный поддерживаемый nmap способ, когда может быть проведено сканирование другими IP-адресами – IDLE Scan (сканирование при помощи зомби) – это тот тип сканирование, при котором ваша машина, с которой вы запускаете скан не работает на прямую с тем хостом который имеет сервис, который вы хотите изучить. То есть вы отправляете третьему компьютеру несколько пакетов, и он от своего имени обращается к сервису.
	</details>
</ol>

## Популярные Порты
1. Сервисы: SSH (22), FTP (21), SMB/RPC (135/445), MSSQL (1433), PostgreSQL (5432), Redis (6379), Web (80,443), Alternative Web (8080,8443), etc…
2. Маршруты трафика до узлов во внутренней сети компании: сканирование собственной локальной сети (172.16.0.0/12 или 192.168.0.0/16), сканирование локальной сети организации 10.0.0.0/8
3. Доступные сервисы сетевого оборудования: Cisco Smart Install (4786), Web (80,443), Cisco UCS Director Express for Big Data + VNC (8787/ 599), SSH (22), Mikrotik Neighbor Discovery Protocol (5678), Winbox (8291) и пр.

На сетевых периметрах часто встречаются UDP-сервисы DNS (53), NTP (123), SNMP (161), VPN (500, 1194, 4500), RDG (3391). Реже встречаются сервисные службы типа echo (7), discard (9), chargen (19), а также DAYTIME (13), TFTP (69), SIP (5060), сервисы NFS (2049), RPC (111, 137-139, 761 и др.), СУБД (1434).  
  
Расширенный список:  
  
21 — ftp  
22 — ssh  
23 — telnet  
80, 8000, 8001, 8002, 8004, 8006, 8007, 8008, 8080, 8888 — http  
88 — kerberos  
139 — netbios  
143 — imap  
389 — ldap  
443, 8443, 9443 — https  
445 — smb  
623, 49152 — ipmi  
636 — ldaps  
873 — rsync  
1099 — websphere  
1433, 1434 — mssql  
1500 — tivoli_storage_manager  
1540, 1541 — 1С  
2001, 2010 — ibm_http  
2181 — zookeeper  
2222 — ansible  
2375, 2376 — docker  
2379 — k8s etcd  
2809, 9043, 9060, 9080, 9501, 9502, 9503 — websphere  
5558, 5559 — websphere_java_messaging_serevice  
7873 — websphere_rds_client  
8879 — websphere_soap  
3306 — mysql  
3389 — rdp  
4678 — cisco smart install  
4899 — radmin  
5800 — 5810,5900,5901 — vnc  
5432, 5433 — postgresql  
5555 — hp_data_protector  
5557 — citrix  
5666 — nagious  
8291 — mikrotik  
10050, 10051 — zabbix  
7001 — weblogic  
9000 — clickhouse  
27017, 27018 — mongodb  
50013 — sap  
1521 — 1527 — oracle  
3200 — 3299 — sap  
4786 — cisco_smart_install  
9200, 9300 — elasticsearch  
5985, 5986 — winrm  
50070 — hdfs_ui  
6443 — k8s  
8111 — click_house  
8500, 8501 — consul  
8200, 8201 — vault  
10250, 10255 — k8s